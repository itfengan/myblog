<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative的prop-types属性验证问题]]></title>
    <url>%2F2018%2F08%2F02%2FReactNative%E7%9A%84prop-types%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用 React Native 创建的组件是可以复用的，所以我们开发的组件可能会给项目组其他同事使用。但别人可能对这个组件不熟悉，常常会忘记使用某些属性，或者某些属性传递的数据类型有误。 在开发 React Native 自定义组件时，可以通过属性确认来声明这个组件需要哪些属性。这样，如果在调用这个自定义组件时没有提供相应的属性，则会在手机与调试工具中弹出警告信息，告知开发者该组件需要哪些属性。 新版本的问题React Native已经升级到0.51.0了，版本升级很快，但是对老项目也会有一些问题，常见的就是属性找不到的问题。例如： 主要原因是随着React Native的升级，系统废弃了很多的东西，过去我们可以直接使用 React.PropTypes 来进行属性确认，不过这个自 React v15.5 起就被移除了，转而使用prop-types库来进行替换 如何使用安装需要先安装这个第三方库 npm install --save prop-types 安装成功如下： 导入import propTypes from &#39;prop-types&#39;; 验证12345678static propTypes = &#123; title: PropTypes.string, leftIcon: PropTypes.string, rightIcon: PropTypes.string, leftPress: PropTypes.func, rightPress: PropTypes.func, style: PropTypes.object &#125; 这样，如果在调用这个自定义组件时没有提供相应的属性，则会在手机与调试工具中弹出警告信息，告知开发者该组件需要哪些属性。 完整语法1，要求属性是指定的 JavaScript 基本类型。例如： 属性: PropTypes.array,属性: PropTypes.bool,属性: PropTypes.func,属性: PropTypes.number,属性: PropTypes.object,属性: PropTypes.string, 2，要求属性是可渲染节点。例如： 属性: PropTypes.node, 3，要求属性是某个 React 元素。例如： 属性: PropTypes.element, 4，要求属性是某个指定类的实例。例如： 属性: PropTypes.instanceOf(NameOfAClass), 5，要求属性取值为特定的几个值。例如： 属性: PropTypes.oneOf([‘value1’, ‘value2’]), 6，要求属性可以为指定类型中的任意一个。例如： 属性: PropTypes.oneOfType([ PropTypes.bool, PropTypes.number, PropTypes.instanceOf(NameOfAClass),]) 7，要求属性为指定类型的数组。例如： 属性: PropTypes.arrayOf(PropTypes.number), 8，要求属性是一个有特定成员变量的对象。例如： 属性: PropTypes.objectOf(PropTypes.number), 9，要求属性是一个指定构成方式的对象。例如： 属性: PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number,}), 10，属性可以是任意类型。例如： 属性: PropTypes.any 将属性声明为必须 使用关键字 isRequired 声明它是必需的。 属性: PropTypes.array.isRequired,属性: PropTypes.any.isRequired,属性: PropTypes.instanceOf(NameOfAClass).isRequired, 源码（prop-types.js）123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Copyright (c) 2015-present, Facebook, Inc. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @flow * @nolint * @format */// TODO (bvaughn) Remove this file once flowtype/flow-typed/pull/773 is mergedtype $npm$propTypes$ReactPropsCheckType = ( props: any, propName: string, componentName: string, href?: string,) =&gt; ?Error;declare module 'prop-types' &#123; declare var array: React$PropType$Primitive&lt;Array&lt;any&gt;&gt;; declare var bool: React$PropType$Primitive&lt;boolean&gt;; declare var func: React$PropType$Primitive&lt;Function&gt;; declare var number: React$PropType$Primitive&lt;number&gt;; declare var object: React$PropType$Primitive&lt;Object&gt;; declare var string: React$PropType$Primitive&lt;string&gt;; declare var any: React$PropType$Primitive&lt;any&gt;; declare var arrayOf: React$PropType$ArrayOf; declare var element: React$PropType$Primitive&lt;any&gt;; /* TODO */ declare var instanceOf: React$PropType$InstanceOf; declare var node: React$PropType$Primitive&lt;any&gt;; /* TODO */ declare var objectOf: React$PropType$ObjectOf; declare var oneOf: React$PropType$OneOf; declare var oneOfType: React$PropType$OneOfType; declare var shape: React$PropType$Shape; declare function checkPropTypes&lt;V&gt;( propTypes: $Subtype&lt;&#123;[_: $Keys&lt;V&gt;]: $npm$propTypes$ReactPropsCheckType&#125;&gt;, values: V, location: string, componentName: string, getStack: ?() =&gt; ?string, ): void;&#125; 参考]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之按妞交互]]></title>
    <url>%2F2018%2F08%2F02%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8B%E6%8C%89%E5%A6%9E%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[ReactNative的Button是一个简单的跨平台按钮组件，可以进行一些简单的定制，但是支持的props有限，一般我们会使用TouchableXXX一系列的组件来定制我们需要的按钮 Button123456789101112131415161718render() &#123; console.log('render') return ( &lt;View style=&#123;styles.content&#125;&gt; &lt;Button //注意 没有style属性，设置无卵用 style=&#123;&#123; backgroundColor:'#ffffff', color:"#00aaaa" &#125;&#125; onPress=&#123;() =&gt; Alert.alert('hello')&#125; // disabled=&#123;true&#125; title="click" color="#00a056" /&gt; &lt;/View&gt; )&#125; 查看Props props 描述 必填 onPress 用户点击此按钮时所调用的处理函数 是 title 按钮内显示的文本 是 color 文本的颜色(iOS)，或是按钮的背景色(Android) 否 disabled 设置为 true 时此按钮将不可点击。 否 accessibilityLabel 用于给残障人士显示的文本 否 testID 用来在端到端测试中定位此视图。 否 通过上面的属性表格，并没有style属性（可以外部包一层View来定制），可以知道这个Button的组件的样式是有局限的，并且color属性，两端并不统一（一个是文本颜色，一个是背景色），使用非常简单，不再代码演示了。 TouchableXXX系列组件TouchableXXX系列组件有以下四种： 名称 描述 TouchableWithoutFeedback 响应用户的点击事件，如果你想在处理点击事件的同时不显示任何视觉反馈，使用它是个不错的选择 TouchableHighlight 在TouchableWithoutFeedback的基础上添加了当按下时背景会变暗的效果，可以指定按下抬起的颜色等。 TouchableOpacity 相比TouchableHighlight在按下去会使背景变暗的效果，TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 TouchableNativeFeedback 在Android上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似水波纹的视觉效果。注意，此组件只支持Android。 四者的关系？ 1234567891011121314//TouchableHighlightvar TouchableHighlight = React.createClass(&#123; propTypes: &#123; ...TouchableWithoutFeedback.propTypes,//TouchableOpacityvar TouchableOpacity = React.createClass(&#123; mixins: [TimerMixin, Touchable.Mixin, NativeMethodsMixin], propTypes: &#123; ...TouchableWithoutFeedback.propTypes,//TouchableNativeFeedbackvar TouchableNativeFeedback = React.createClass(&#123; propTypes: &#123; ...TouchableWithoutFeedback.propTypes, 可以看出： 因为TouchableWithoutFeedback有其它三个组件的共同属性，所以我们先来学习一下TouchableWithoutFeedback。 接下来分别记录的具体使用 注意一点： 无论是TouchableWithoutFeedback还是其他三种Touchable组件，都是在根节点都是只支持一个组件，如果你需要多个组件同时相应单击事件，可以用一个View将它们包裹着，它的这种根节点只支持一个组件的特性和ScrollView很类似。 TouchableWithoutFeedback一个Touchable系列组件中最基本的一个组价，只响应用户的点击事件不会做任何UI上的改变，在使用的过程中需要特别留意。 使用详情详情点击查看：中文网TouchableWithoutFeedback React Native按钮详解|Touchable系列组件使用详解 整体来说 TouchableWithoutFeedback：无ui变化 TouchableHighlight：定制程度较高，透明度，按下抬起颜色等 TouchableOpacity：只有透明度反馈 TouchableNativeFeedback：支持Android 5.0以上的Ripper效果，仅支持Android设备 自定义ButtonGithub地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import React, &#123;Component&#125; from 'react'import &#123; View, Text, StyleSheet, TouchableHighlight,&#125; from 'react-native'// default propsconst backgroundColor = '#000000';const pressBackgroundColor = backgroundColor;const textColor = '#FFFFFF';const pressTextColor = textColor;export default class CommonButton extends Component &#123; // 构造 constructor(props) &#123; super(props); // 初始状态 this.state = &#123; //默认文字 text: this.props.text, //是否不可用 disabled: false, //是否按下 pressed: false, &#125;; this._onPressIn = this._onPressIn.bind(this) this._onPressOut = this._onPressOut.bind(this) &#125; static defaultProps = &#123; //背景颜色 backgroundColor: backgroundColor, //按下背景色 pressBackgroundColor: pressBackgroundColor, //文字色 textColor: textColor, //按下文字色 pressTextColor: pressTextColor, //文字大小 fontSize: 17, //圆角 radius: 0, // onPress onPressFunc: null, //onLongPress onLongPressFunc: null, //padding paddingLeft: 0, paddingRight: 0, paddingTop: 0, paddingBottom: 0, //text text: '没有设定', width: undefined, height: undefined &#125; setDisabled(isDisabled) &#123; this.setState(&#123; disabled: true, &#125;) &#125; setButtonText(newText) &#123; this.setState(&#123; text: newText, &#125;) &#125; _onPressIn() &#123; this.setState(&#123; pressed: true, &#125;) &#125; _onPressOut() &#123; this.setState(&#123; pressed: false, &#125;) &#125; render() &#123; return ( &lt;View&gt; &lt;TouchableHighlight style=&#123;&#123; width: this.props.width, height: this.props.height, justifyContent: 'center', alignItems: 'center', backgroundColor: this.props.backgroundColor, paddingLeft: this.props.paddingLeft, paddingRight: this.props.paddingRight, paddingTop: this.props.paddingTop, paddingBottom: this.props.paddingBottom, borderRadius: 8, &#125;&#125; activeOpacity=&#123;1&#125; // 底层的颜色被隐藏的时候调用。 onHideUnderlay=&#123;null&#125; //当底层的颜色被显示的时候调用。 onShowUnderlay=&#123;null&#125; // 有触摸操作时显示出来的底层的颜色。 underlayColor=&#123;this.props.pressBackgroundColor&#125; //disable disabled=&#123;this.state.disabled&#125; //onPressIn onPressIn=&#123;this._onPressIn&#125; //onPressOut onPressOut=&#123;this._onPressOut&#125; //onPress onPress=&#123;this.props.onPressFunc&#125; //onLongPress onLongPress=&#123;this.props.onLongPressFunc&#125; &gt; &lt;View&gt; &lt;Text style=&#123;&#123; //文字颜色 color: this.state.pressed ? this.props.pressTextColor : this.props.textColor, fontSize: this.props.fontSize &#125;&#125;&gt; &#123;this.state.text&#125; &lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ) &#125;&#125;const styls = StyleSheet.create(&#123; content: &#123;&#125;&#125;) 嘻嘻(o^^o)]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之组件生命周期]]></title>
    <url>%2F2018%2F08%2F01%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期是一定要知道的，这样才知道整个组件的工作流程，知道哪些操作适合在哪个回调中进行……(o^^o) 一个栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123;Component&#125; from 'react';import &#123; View, Text, StyleSheet,&#125; from 'react-native';export default class App extends Component&lt;Props&gt; &#123; /** * 构造函数，初始化需要的state * @param props */ constructor(props) &#123; super(props); console.log('constructor') // 初始状态 this.state = &#123; result: '点击前', &#125;; &#125; /** * 描述：控件渲染前触发 * 次数：一次 * 推荐： */ componentWillMount() &#123; console.log('componentWillMount') &#125; /** * 描述：控件渲染后触发 * 次数：一次 * 推荐： */ componentDidMount() &#123; console.log('componentDidMount') &#125; /** * 描述：组件接收到新的props时被调用 * 次数：多次 * 推荐： */ componentWillReceiveProps() &#123; console.log('componentWillReceiveProps') &#125; /** * 描述：当组件接收到新的props和state时被调用 * 次数：多次 * 推荐： */ shouldComponentUpdate() &#123; console.log('shouldComponentUpdate') return true; &#125; /** * 描述：组件重新渲染完成后会调用此方法 * 次数：多次 * 推荐： */ componentDidUpdate() &#123; console.log('componentDidUpdate') &#125; /** * 描述：控件渲染后触发 * 次数：1次 * 推荐： */ componentDidMount() &#123; console.log('componentDidMount') &#125; /** * 描述：组件卸载和销毁之前被调用 * 次数：一次 * 推荐：用于清理一些无用的内容，比如：定时器清除 */ componentWillUnmount() &#123; console.log('componentWillUnmount') &#125; componentWillUpdate() &#123; console.log('componentWillUpdate') &#125; render() &#123; console.log('render') return ( &lt;View style=&#123;styles.content&#125;&gt; &lt;Text style=&#123;styles.text&#125; onPress=&#123; () =&gt; &#123; this.setState(&#123; result: '点击后' &#125;) &#125; &#125;&gt; &#123;this.state.result&#125; &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; content: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', &#125;, text: &#123; padding: 50, fontSize: 20, color: '#ffffff', backgroundColor: '#00a056' &#125;&#125;) console 123456789constructorApp.js:39 componentWillMountApp.js:103 renderApp.js:86 componentDidMountApp.js:108 onPress callApp.js:66 shouldComponentUpdateApp.js:100 componentWillUpdateApp.js:103 renderApp.js:76 componentDidUpdate 组件的生命周期通过上面的栗子，有灵性的小哥哥已经基本猜到大致的生命周期了 下面再看看这张我偷来的帅图 再结合这张酷表 生命周期 调用次数 能否使用 setSate() 描述 getDefaultProps（es6:static defaultProps） 1(全局调用一次) 否 初始化默认属性 getInitialState(es6:constructor(props)) 1 否 构造函数，初始化需要的state componentWillMount 1 是 控件渲染前触发 render &gt;=1 否 渲染控件的方法 componentDidMount 1 是 控件渲染后触发 componentWillReceiveProps &gt;=0 是 组件接收到新的props时被调用 shouldComponentUpdate &gt;=0 否 当组件接收到新的props和state时被调用 componentWillUpdate &gt;=0 否 props或者state改变，并且此前的shouldComponentUpdate方法返回为 true会调用该方法 componentDidUpdate &gt;=0 否 组件重新渲染完成后会调用此方法 另外还有一个场景需要知道的，代码我就不贴了 父组件中有一个子组件，点击父组件调用setState，那么父子组件的生命周期如何回调？ 12345678910111213141516171819//加载过程constructorApp.js:42 componentWillMountApp.js:107 renderChildComponent.js:26 ChildComponent,constructorChildComponent.js:41 ChildComponent,componentWillMountChildComponent.js:106 ChildComponent,renderChildComponent.js:88 ChildComponent,componentDidMountApp.js:89 componentDidMount//点击后，调用父组件的setState后shouldComponentUpdateApp.js:103 componentWillUpdateApp.js:107 renderChildComponent.js:59 ChildComponent,componentWillReceivePropsChildComponent.js:68 ChildComponent,shouldComponentUpdateChildComponent.js:102 ChildComponent,componentWillUpdateChildComponent.js:106 ChildComponent,renderChildComponent.js:78 ChildComponent,componentDidUpdateApp.js:79 componentDidUpdate 可以看到： 组件的加载是从内到外一级一级的，这个和android类似 修改父组件state，触发update整个流程，但是不再次触发子组件的constructor 推荐的操作 constructor()方法里初始化state static defaultProps指定默认属性 componentDidMount()：该方法在render()方法后自动调用，网络请求一般放在这个方法中 shouldComponentUpdate()：该方法返回一个boolean值，用来决定是否需要重新渲染组件，默认返回true，你可以自己重写此方法，通过条件判断来决定你是否需要更新组件 componentWillUnmount()：在组件被移除前调用，在该方法中，释放一些不需要的资源，比如停止定时器 不要在 constructor 或者 render 里 setState() constructor 已含 this.state={} render 里 setState 会造成setState -&gt; render -&gt; setState -&gt; render 能做的setState，只要是render前，就放在componentWillMount，render后，就放在 componentDidMount。這两个 function 是 react lifecycle 中，最常使用的两个 更多以后再添加总结 参考React-Native生命周期的触发场景和一些小建议 React Native 中组件的生命周期 React Native之React速学教程(中)/)]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之ref]]></title>
    <url>%2F2018%2F08%2F01%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8Bref%2F</url>
    <content type="text"><![CDATA[概述 ref属性是一个特殊的属性，可以把它挂载到任何组件 它可以是一个回调函数（也可以是一个字符串，基本废弃这种用法） 这个回调函数在组件被挂载后立即被执行，应用到的组件作为参数传递 回调函数可以立即使用组件，也可以将参数的组件引用保存起来，后续使用（调用组件方法或者获取组件参数） ref属性指定回调方法栗子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import React, &#123;Component&#125; from 'react';import &#123; View, Text, StyleSheet,&#125; from 'react-native';export default class App extends Component&lt;Props&gt; &#123; // 构造 constructor(props) &#123; super(props); // 初始状态 this.state = &#123; result: '点击前' &#125;; &#125; render() &#123; return ( &lt;View style=&#123;styles.content&#125;&gt; &lt;Text style=&#123;styles.button&#125; onPress=&#123; () =&gt; &#123; this._Test.print() &#125; //() =&gt; &#123; // this.setState((prestate, props) =&gt; &#123; // console.warn("setState") // return &#123;result: '点击了'&#125; // &#125;) &#125; &#125;&gt;&#123;this.state.result&#125;&lt;/Text&gt; &lt;RefTest ref=&#123; //指定ref属性的回调函数 (e) =&gt; &#123; console.warn("ref的回调执行了！") //参数e则为当前RefTest组件的引用 this._Test = e; &#125; &#125;&gt; &lt;/RefTest&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; content: &#123; flex: 1, backgroundColor: '#00a056', flexDirection: 'row' &#125;, button: &#123; padding: 30, backgroundColor: '#ffffff', fontSize: 17, alignSelf: 'center' &#125;, text: &#123; padding: 30, backgroundColor: '#ffffff', fontSize: 30, &#125;&#125;)class RefTest extends Component&lt;Props&gt; &#123; // 构造 constructor(props) &#123; super(props); // 初始状态 this.state = &#123; data: 'old' &#125;; &#125; print() &#123; this.setState((preState, props) =&gt; &#123; return &#123; data: 'new' &#125; &#125;) console.warn("print方法执行了：" + this.state.data) &#125; render() &#123; return ( &lt;View style=&#123;&#123; alignSelf: 'center', left: 10, backgroundColor: '#ffff00', &#125;&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt; 当前数据：&#123;this.state.data&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 可以看到： 父组件拥有的子组件，子组件有ref属性 首次进入的时候，组件初次绑定 ref的回调会执行一次，父组件保存该引用 点击后，使用组件引用，调用组件方法print 若点击后，父组件setState，则子组件 卸载后，重新调用子组件Rend（）方法，这个过程，子组件的ref回调会被调用两次（卸载一次，挂载一次） 需要知道的： 在父组件在子组件指定ref的回调中保存引用对子组件的 这个回调在父组件每次setState（父Render（）调用） 组件的render方法被调用时，ref才会被调用，组件才会返回ref setState涉及先卸载，后挂载，ref回调执行两次]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之样式]]></title>
    <url>%2F2018%2F07%2F31%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8B%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文整理React Native中的布局方式，FlexBox弹性布局的使用 宽高RN中，尺寸是没有单位的，它已经代表了设备独立像素 123&lt;View style=&#123; &#123;width:100,height:100,margin:40,backgroundColor:'gray'&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,margin:20&#125;&#125;&gt;尺寸&lt;/Text&gt;&lt;/View&gt; 运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了布局在任何不同dpi的手机屏幕上显示不会发生改变； RN和Web css上的FlexBox的区别 flexDirection: React Native中默认为flexDirection:&#39;column&#39;，在Web CSS中默认为flex-direction:&#39;row&#39; alignItems: React Native中默认为alignItems:&#39;stretch&#39;，在Web CSS中默认align-items:&#39;flex-start&#39; flex: 相比Web CSS的flex接受多参数，如:flex: 2 2 10%;，但在 React Native中flex只接受一个参数 不支持属性：align-content，flex-basis，order，flex-basis，flex-flow，flex-grow，flex-shrink 以上是React Native中的FlexBox 和Web CSSS上FlexBox的不同之处，记住这几点，你可以像在Web CSSS上使用FlexBox一样，在React Native中使用FlexBox。 Layout Props父视图属性（容器属性）： flexDirection enum(‘row’, ‘column’,’row-reverse’,’column-reverse’) flexWrap enum(‘wrap’, ‘nowrap’) justifyContent enum(‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’) alignItems enum(‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’) 学习父容器属性之前，先学习下基本概念 和Web的Css不同的是，RN的Flexbox默认的主轴是 竖直的（column） flexDirectionflexDirection enum(&#39;row&#39;, &#39;column&#39;,&#39;row-reverse&#39;,&#39;column-reverse&#39;)flexDirection属性定义了父视图中的子元素沿横轴或侧轴方片的排列方式。 row: 从左向右依次排列 row-reverse: 从右向左依次排列 column(default): 默认的排列方式，从上向下排列 column-reverse: 从下向上排列 flexWrapflexWrap enum(&#39;wrap&#39;, &#39;nowrap&#39;)flexWrap属性定义了子元素在父视图内是否允许多行排列，默认为nowrap。 nowrap flex的元素只排列在一行上，可能导致溢出。 wrap flex的元素在一行排列不下时，就进行多行排列。 justifyContentjustifyContent enum(&#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;space-between&#39;, &#39;space-around&#39;)justifyContent属性定义了浏览器如何分配顺着父容器主轴的弹性（flex）元素之间及其周围的空间，默认为flex-start。 flex-start(default) 从行首开始排列。每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前一个对齐。 flex-end 从行尾开始排列。每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。 center 伸缩元素向每行中点排列。每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。 space-between 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。 space-around 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。 alignItemsalignItems enum(&#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)alignItems属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch 子视图属性（规范自己的）alignSelfalignSelf enum(&#39;auto&#39;, &#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)alignSelf属性以属性定义了flex容器内被选中项目的对齐方式。注意：alignSelf 属性可重写灵活容器的 alignItems 属性。 auto(default) 元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。 stretch 元素被拉伸以适应容器。 center 元素位于容器的中心。 flex-start 元素位于容器的开头。 flex-end 元素位于容器的结尾。 flexflex numberflex 属性定义了一个可伸缩元素的能力，默认为0。 其他属性以下属性是React Native所支持的除Flex以外的其它布局属性。 视图边框尺寸内部边距外边距边缘定位(position)position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。 absolute：生成绝对定位的元素，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(相对于父布局的位置)（注意：忽略父组件的padding，默认直接在父组件的左上角，除非设置当前组件的left，top，right，bottom,或者margin之类的） relative：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（相对于自身本应该在的位置） 例子1: 123456789101112131415161718192021222324252627282930313233343536373839render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: 'center', &#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.loadData&#125;&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;Image style=&#123;styles.header&#125;/&gt; &lt;Text style=&#123;styles.name&#125;&gt;absolute&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125; const styles = StyleSheet.create(&#123; container: &#123; flexDirection: 'row', paddingLeft: 15, paddingRight: 15, paddingTop: 10, paddingBottom: 10, backgroundColor: '#999999' &#125;, header: &#123; width: 100, height: 100, backgroundColor: '#00a056' &#125;, name: &#123; position: 'relative', // left: 15, alignSelf: 'flex-start', fontSize: 13, backgroundColor: '#ffff00', color: '#999999' &#125;&#125;); 参考：React Native布局详细指南]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之网络请求]]></title>
    <url>%2F2018%2F07%2F30%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[React Native 中虽然也内置了XMLHttpRequest 网络请求Api（也就是ajax），但XMLHttpRequest 是一个设计粗糙的API，不符合职责分离的原则，配置和调用方式比较混乱，而且基于事件的异步模型不如现代的Promise友好。所以，React Native官方推荐使用Fetch Api Fetch基本使用最简单的使用 如果只是请求一下服务器，不需要任何操作 1fetch('http://chenxiaoping.com/demo')添加请求头 添加请求头和请求参数（服务端支持json参数） 1234567891011fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;)&#125;) 添加请求头和请求参数（服务端不支持json参数） 1234567fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;, body: 'key1=value1&amp;key2=value2'&#125;) Response对象参数解析Response对象中包含了多种属性： status (number) ： HTTP请求的响应状态行。 statusText (String) ： 服务器返回的状态报告。 ok (boolean) ：如果返回200表示请求成功，则为true。 headers (Headers) ： 返回头部信息。 url (String) ：请求的地址。 Response对象还提供了多种方法： formData()：返回一个带有FormData的Promise。 json() ：返回一个带有JSON对象的Promise。 text()：返回一个带有文本的Promise。 clone() ：复制一份response。 error()：返回一个与网络相关的错误。 redirect()：返回了一个可以重定向至某URL的response。 arrayBuffer()：返回一个带有ArrayBuffer的Promise。 blob() ： 返回一个带有Blob的Promise。 解析json和修改json数据 12345678910111213141516loadData() &#123; return fetch('https://facebook.github.io/react-native/movies.json',) .then((response) =&gt; response.json()) .then((json) =&gt; &#123; json['description']='hello' Alert.alert(json.description) &#125;) .catch((error) =&gt; &#123; this.setState(() =&gt; &#123; return &#123; buttonText: 'doLoad', &#125; &#125;); console.error(error); &#125;) &#125; response： 1234567891011&#123; "title": "The Basics - Networking", "description": "Your app fetched this from a remote endpoint!", "movies": [ &#123; "id": "1", "title": "Star Wars", "releaseYear": "1977" &#125;, &#123; "id": "2", "title": "Back to the Future", "releaseYear": "1985" &#125;, &#123; "id": "3", "title": "The Matrix", "releaseYear": "1999" &#125;, &#123; "id": "4", "title": "Inception", "releaseYear": "2010" &#125;, &#123; "id": "5", "title": "Interstellar", "releaseYear": "2014" &#125; ]&#125; 可以看到弹窗为‘hello’ 超时1fetch(input, init).then(function(response) &#123; ... &#125;); 参数 input 定义要获取的资源。这可能是： 一个 USVString 字符串，包含要获取资源的 URL。 一个 Request 对象。 init 可选 一个配置项对象，包括所有对请求的设置。可选的参数有： method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers 对象或 ByteString。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者 include。 cache: 请求的 cache 模式: default, no-store, reload, no-cache, force-cache, or only-if-cached. 根本找不到 timeout 配置 1234567891011121314151617// 超时版的fetch _fetch(fetch, timeout) &#123; return Promise.race([ fetch, new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), timeout); &#125;) ]); &#125; // 使用 _fetch(fetch('url'), 1000).then((info)=&gt; &#123; return info.text(); &#125;).then((info)=&gt; &#123; console.log(info); &#125;).catch((err)=&gt; &#123; throw new Error(err); &#125;); 代码中用Promise.race()将fetch和一个新的Promise包装在了一起,新的Promise和fetch谁率先返回就把该Promise实例返回值传递给下面的.then()或者是.catch() 让fetch也可以timeout 可以设置超时版的的fetch fetch添加超时时间只需几行代码–fetch timeout 简单封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159export default class FetchUtil &#123; init() &#123; this.url = ''; this.method = 'GET'; this.headers = &#123;&#125;; this.body_type = 'form'; this.bodys = &#123;&#125;; this.credentials = 'omit'; //默认返回json对象 this.return_type = 'json'; this.overtime = 0; this.firstThen = undefined; return this; &#125; setUrl(url) &#123; this.url = url; return this; &#125; setMethod(val) &#123; this.method = val; return this; &#125; setBodyType(val) &#123; this.body_type = val; return this; &#125; setReturnType(val) &#123; this.return_type = val; return this; &#125; setOvertime(val) &#123; this.overtime = val; return this; &#125; setHeader(name, val = null) &#123; if (typeof name == 'string') &#123; this.headers[name] = val; &#125; else if (typeof name == 'object') &#123; Object.keys(name).map((index) =&gt; &#123; this.headers[index] = name[index]; &#125;); &#125; return this; &#125; setBody(name, val = null) &#123; if (typeof name == 'string') &#123; this.bodys[name] = val; &#125; else if (typeof name == 'object') &#123; Object.keys(name).map((index) =&gt; &#123; this.bodys[index] = name[index]; &#125;); &#125; return this; &#125; setCookieOrigin() &#123; this.credentials = 'same-origin'; return this; &#125; setCookieCors() &#123; this.credentials = 'include'; return this; &#125; thenStart(then) &#123; this.firstThen = then; return this; &#125; dofetch() &#123; let options = &#123;&#125;; options.method = this.method; options.credentials = this.credentials; options.headers = this.headers; if (&#123;&#125; != this.bodys &amp;&amp; this.method != 'GET') &#123; if ('form' == this.body_type) &#123; this.setHeader("Content-Type", "application/x-www-form-urlencoded;charset=UTF-8"); let data = ''; Object.keys(this.bodys).map((index) =&gt; &#123; let param = encodeURI(this.bodys[index]); data += `$&#123;index&#125;=$&#123;param&#125;&amp;`; &#125;); options.body = data; &#125; else if ('file' == this.body_type) &#123; let data = new FormData(); Object.keys(this.bodys).map((index) =&gt; &#123; data.append(index, this.bodys[index]); &#125;); options.body = data; &#125; else if ('json' == this.body_type) &#123; options.body = JSON.stringify(this.bodys); &#125; &#125; return Promise.race([ fetch(this.url, options), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('request timeout')), this.overtime ? this.overtime : 30 * 1000); &#125;) ]).then( (response) =&gt; &#123; if (this.firstThen) &#123; let tempResponse = this.firstThen(response); if (tempResponse) &#123; return tempResponse; &#125; &#125; return response; &#125; ).then( (response) =&gt; &#123; if ('json' == this.return_type) &#123; return response.json(); &#125; else if ('text' == this.return_type) &#123; return response.text(); &#125; else if ('blob' == this.return_type) &#123; return response.blob(); &#125; else if ('formData' == this.return_type) &#123; return response.formData(); &#125; else if ('arrayBuffer' == this.return_type) &#123; return response.arrayBuffer(); &#125; &#125; ); &#125;&#125;//uselet fetchUtil = new FetchUtil(); fetchUtil.init() .setUrl('https://www.google.com/') .setMethod('GET') .setOvertime(15 * 1000) .setHeader(&#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;) .dofetch() .then((response) =&gt; &#123; //这里的response已经被转成object了 console.warn( typeof response.title); &#125;) .then((data) =&gt; &#123; Alert.alert(data); &#125;) .catch((error) =&gt; &#123; console.warn( '=&gt; catch: ', error); // console.log('=&gt; catch: ', error); &#125;);]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之State]]></title>
    <url>%2F2018%2F07%2F28%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8BState%2F</url>
    <content type="text"><![CDATA[我们使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用state。 state属性主要用来存储组件自身需要的数据，是组件自己私有的，我们一般通过修改 state 属性的值来更新数据，React 内部会监听 state 的变化，一旦发生变化就会主动触发组件的 render() 方法来更新 Dom 结构 state的使用一般来说，你需要在 constructor()方法中初始化 state（这是ES6的写法，ES5 中一般在 getInitialState() 方法中来初始化 state），然后在需要修改时调用 setState() 方法。 不要使用 this.state 来修改 state 属性值，应该调用 setState() 方法，this.state 是无效的。 setState（）方法setState() 的完整表达式： setState(updater, [callback]) setState() 方法会把对组件 state 的改变加入到队列中，并且告诉 React 这个组件及其子组件需要重新渲染。 第一个参数：updater 函数setState(updater, callback) 方法的第一个参数是一个固定格式的 updater 函数： 1(prevState, props) =&gt; stateChange prevState 是一个对之前状态（previous state）的引用，我们是不能直接修改这个参数的值，要想修改 state 的值，我们应该根据 prevState 和 props 参数来创建一个新的 JavaScript 对象。 例子1： 123this.setState((prevState, props) =&gt; &#123; return &#123;counter: prevState.counter + props.step&#125;;&#125;); 你也可以传一个对象而不是函数，来作为setState(updater, callback) 方法的第一个参数，React 会将该参数 merge 到 state 中。 例子2: 1this.setState(&#123;quantity: 2&#125;); 第二个参数：callbacksetState(updater, callback) 方法的第二个参数 callback 是一个可选参数。（基本是空的，一般不这么使用） 为了更好的性能表现，React 并不能保证 setState() 一被调用 state 就能更新。所以，如果在调用 setState() 之后，马上就读取 this.state 的值的话，可能会出现误差。 因此，这种情况下，推荐使用 componentDidUpdate 或者 setState(updater, callback) 方法的 callback 来获取最新的状态。 React 官方更推荐使用 componentDidUpdate()，而不是 callback 来监听 update 事件（注： 除非 shouldComponentUpdate() 方法返回 false，setState() 将永远都会引发重新渲染）。 例子1: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123;Component&#125; from 'react';import &#123; View, StyleSheet, TouchableOpacity, ToastAndroid, Platform, Text,&#125; from 'react-native';export default class App extends Component&lt;Props&gt; &#123; // 构造 constructor(props) &#123; super(props); // 初始状态 this.state = &#123; num: 1 &#125;; &#125; shouldComponentUpdate() &#123; //返回 false 则setState不刷新 return false; &#125; static defaultProps = &#123; add: 100 &#125; componentDidUpdate() &#123; if(Platform.OS=='ios')&#123; return; &#125; ToastAndroid.show(""+this.state.num,ToastAndroid.SHORT) &#125; render() &#123; return ( &lt;View style=&#123;&#123;flex:1,justifyContent:'center',alignItems: 'center'&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; this.setState((prevState, props) =&gt; &#123; return &#123;num: prevState.num + props.add&#125;; &#125;); &#125;&#125; style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.state.num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: '#00a056', paddingRight: 70, paddingTop: 10, paddingBottom: 10, paddingLeft: 70, shadowColor: '#00a056', shadowOffset: &#123;width: 3, height: 3&#125;, shadowOpacity: 0.5, shadowRadius: 4 &#125;, text: &#123; color: '#ffffff', fontSize: 30, &#125;&#125;) 如上图效果： shouldComponentUpdate 不重写或者返回true，则象左侧ios模拟器一样，可以修改状态 返回false，则不重写 官方不推荐我们使用setState的第二个参数Callback的形式获取，我们可以在componentDidUpdate回调中，获取最新的State 如何正确操作state不要使用this.state来修改state12// Wrongthis.state.comment = 'Hello'; 记住，this.state 是不可变的。 1234567891011//事实证明，并改变不了render() &#123; return ( &lt;View style=&#123;&#123;flex: 1, justifyContent: 'center', alignItems: 'center'&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; this.state.num = 3 &#125;&#125; style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.state.num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) 应该调用 setState() 方法： 123456789101112131415// Correctthis.setState(&#123;comment: 'Hello'&#125;);//或者this.setState((prevState, props) =&gt; &#123; return &#123;num: prevState.num + props.add&#125;; &#125;);//prevState 可以获取上个state 数值//props 可以获取当前props所有数值，可以做一些操作//不要这么使用this.setState((prevState, props) =&gt; &#123; return &#123;num: this.state.num+1&#125;; &#125;);//考虑到setState可能是异步调用的，所以推荐使用prevState（上一个值），而不是依赖this.state来计算最新的state，这样可能会有误差 state的改变是一个覆盖（合并）过程当你调用 setState() 方法时，React 会将将你当前所提供的对象合并到当前的状态中。 例子1: 12345678910111213141516constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125;componentDidMount() &#123; fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; ⬆面的栗子，state更新至替换了comments，posts不受影响 state传递？注意： 父组件和子组件之间不能通过 state 来交互，父组件只能将自己的 state 值传给子组件的 props。 这种数据传递的方式通常被称为 “自顶向下（top-down）”或者“单向（unidirectional）”数据流。 任何state都是由一个特定的组件所拥有的，任何state数据修改默认只会影响当前组件， 可以通过回调传值（后面会整理） React Native建议由顶层的父组件定义state值，并将state值作为子组件的props属性值传递给子组件，这样可以保持单一的数据传递。 参考[【1】React Native] React 中的状态（State）]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[^_^夏日～]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%A4%8F%E6%97%A5%2F</url>
    <content type="text"><![CDATA[夏日的夜晚 夏日的夜晚，猫坐在床边 你吹着头发，不说话就很甜 想和你一起看星空，只谈夜色和微风 没有工作，没有早起 只有甜甜的梦 和梦里的你 ^_^ ～]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.0-知识碎片（三）]]></title>
    <url>%2F2018%2F07%2F24%2FRxjava2-0-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于Rxjava2.0的操作符小结 一：创建相关creat操作符12345678910Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("item1"); subscriber.onNext("item2"); subscriber.onCompleted(); &#125; &#125;); just123456Observable observable = Observable.just("Hello", "Hi", "Aloha");// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); from1234567String[] words = &#123;"Hello", "Hi", "Aloha"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); interval操作符不多bb，看以下代码 1234567891011121314151617181920212223242526272829public void rxJava() &#123; Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Long&gt;() &#123; public Disposable mDisposable; @Override public void accept(Long aLong) &#123; if (aLong == 10) &#123; mDisposable.dispose(); &#125; System.out.println("计时器" + aLong); &#125; &#125;, throwable -&gt; &#123; &#125;, () -&gt; &#123; System.out.println("action"); &#125;, disposable -&gt; mDisposable = disposable); &#125;//log07-24 11:24:52.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器007-24 11:24:53.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器107-24 11:24:54.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器207-24 11:24:55.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器307-24 11:24:56.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器407-24 11:24:57.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器507-24 11:24:58.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器607-24 11:24:59.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器707-24 11:25:00.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器807-24 11:25:01.718 12306-12332/com.fengandev.rxjavademo I/System.out: 计时器9 可以简易的封装，获取一个倒计时Observable 123456789101112131415161718192021222324/** * 产生一个倒计时的 Observable * @param time * @return */ public Observable&lt;Long&gt; countdown(final long time) &#123; return Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long, Long&gt;() &#123; @Override public Long apply(@NonNull Long aLong) throws Exception &#123; return time - aLong; &#125; &#125;).take( time + 1 ); &#125;//使用 public void rxJava() &#123; countdown(10).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; System.out.println("倒计时"+aLong); &#125; &#125;); &#125; range操作符range 发射特定整数序列的 Observable range( int start , int end ) //start :开始的值 ， end ：结束的值 12345678 Observable.range(0,5) .subscribe(integer -&gt; System.out.println(integer));//log01234 老规矩，包前不包后 empty和error和neverempty Observable observable1=Observable.empty();//直接调用onCompleted。 1234567891011121314151617181920212223242526272829//Observable observable1=Observable.empty();//直接调用onCompleted。@Test public void testRxJava() &#123; Observable&lt;String&gt; empty = Observable.empty(); empty.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println("onSubscribe"); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError"); &#125; @Override public void onComplete() &#123; System.out.println("onComplete"); &#125; &#125;); &#125;//log://onSubscribe//onComplete never Observable observable3=Observable.never();//啥都不做 123456789101112131415161718192021222324252627@Testpublic void testRxJava() &#123; Observable&lt;String&gt; empty = Observable.never(); empty.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println("onSubscribe"); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError"); &#125; @Override public void onComplete() &#123; System.out.println("onComplete"); &#125; &#125;);&#125;//log//onSubscribe error Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常 功能操作map操作符map操作符算是Rxjava中最简单的一个操作符了，在2.x中的用法和1.x差不多；它的作用就是对发射的每一个事件应用一个函数，每一个事件都按照map操作符指定的函数去变化转换，下面我们看一个栗子🌰 12345678910111213141516171819202122232425262728@Test public void rxJava() &#123; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; Log.e("fengan", "apply----&gt;" + Thread.currentThread().getName()); return "this is value = " + integer; &#125; &#125;).subscribeOn(Schedulers.single())// .observeOn(Schedulers.single()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.e("fengan", "accept----&gt;" + Thread.currentThread().getName()); Log.e("fengan", "accept----&gt;" + s); Log.e("fengan","========"); &#125; &#125;); &#125; log 123456789101112apply----&gt;RxSingleScheduler-1accept----&gt;RxSingleScheduler-1accept----&gt;this is value = 1========apply----&gt;RxSingleScheduler-1accept----&gt;RxSingleScheduler-1accept----&gt;this is value = 2========apply----&gt;RxSingleScheduler-1accept----&gt;RxSingleScheduler-1accept----&gt;this is value = 3======== 从这个例子，我们能看出 我们发射的integer事件，被转换为String，继续进行 我们也顺便验证了两个问题（在碎片化2整理的线程调度） 只指定subscribeOn未指定observeOn的情况下，观察者的事件的接受（下游）按照subscribeOn指定的线程进行 Schedulers.single()是在指定线程中按照队列的形式进行，先进先出（体现在：一个事件发布和接受完毕后，才发送第二个事件） debounce操作符debounce：防抖； only emit an item from an Observable if a particular time-span has passed without it emitting another item, 当一个事件发送出来之后，在约定时间内没有再次发送这个事件，则发射这个事件，如果再次触发了，则重新计算时间。 参考链接 123456789101112131415161718192021222324252627 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); &#125; &#125;).debounce(500,TimeUnit.MILLISECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125; &#125;);//2//4//5 onTerminateDetach操作符Rxjava导致内存泄漏的问题 一张图搞定-RxJava2的线程切换原理和内存泄露问题 看完这两个参考链接，基本也就知道了onTerminateDetach的使用方法和作用 defer操作符只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。 1234567891011121314151617@Testpublic void rxjava() &#123; Observable.defer(new Callable&lt;ObservableSource&lt;Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;Integer&gt; call() throws Exception &#123; return Observable.just(1,2,3); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125; &#125;);&#125;123 flatMap操作符把一个发射器Observable 通过某种方法转换为多个Observables，然后再把这些分散的Observables装进一个单一的发射器Observable。但有个需要注意的是，flatMap并不能保证事件的顺序，如果需要保证，需要用到我们下面要讲的ConcatMap。 12345678910111213141516171819202122232425@Testpublic void rxJava() &#123; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); res.add("i am value =" + integer); Log.e("fengan","flatMap size"+res.size()); return Observable.fromIterable(res); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.e("fengan","accept="+s); &#125; &#125;);&#125; log 123456flatMap size1accept=i am value =1 flatMap size1 accept=i am value =2 flatMap size1 accept=i am value =3 结论 验证了我之前的一个误区（size大小一直为1）：误以为所有事件发送完毕之后，在flatmap统一处理，其实不是，事件源每发射一个事件，flatmap就处理转换一个事件 flatMap的作用是，接受一个事件，作出处理完之后，重新发射一个新的事件 刚才说到flatMap并不能保证事件的顺序，请看下面的例子就明白了 concatMap操作符flatMap操作符可以将一个Observable转换为另一个Observable发射出去,并且可以将多个事件转化为1个，但是最后输出的事件序列顺序是不确定的，如果想要最后输出的事件顺序和源数据的顺序一致只要换成concatMap就可以了。flatMap和Map操作符的不同是map一次只能转换一个事件。 先看一个flatmap的使用例子，如下 12345678910111213Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;).subscribeOn(Schedulers.io()).flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt; &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; res.add("I am value " + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(res).delay(delayTime, TimeUnit.MILLISECONDS); &#125;).subscribe(s -&gt; Log.e("fengan", "accept=" + s)); log 123456789accept=I am value 3accept=I am value 3accept=I am value 2accept=I am value 2accept=I am value 2accept=I am value 3accept=I am value 1accept=I am value 1accept=I am value 1 可见不是按照源数据到顺序一致，若想一致使用concatMap就可以了 repeat操作符repeat 重复地发射数据 repeat( ) //无限重复 repeat( int time ) //设定重复的次数 123456789101112Observable.just(1,2,3) .repeat(3) .subscribe(integer -&gt; System.out.println(integer));123123123 fromArray和fromIterble操作符一个是发射一个数组一个是发射一个集合 toList将数组转换为集合 delay操作符123456789101112public void rxJava() &#123; Observable.just(1, 2, 3) .delay(3, TimeUnit.SECONDS) .observeOn(Schedulers.io()) .subscribe(integer -&gt; &#123; int a = integer; System.out.println(a); &#125;); &#125;//注意：延迟3秒钟，然后在发射数据//是延迟三秒，发送1，2，3数据//而不是--延迟3秒--发送1--延迟3秒---发送2 是延迟三秒，发送1，2，3数据 而不是–延迟3秒–发送1–延迟3秒—发送2 若想达到这种效果，可以类似这么做 123456789101112public void rxJava() &#123; Observable.just(1, 2, 3) .concatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;Integer&gt; apply(Integer integer) throws Exception &#123; return Observable.just(integer) .delay(3, TimeUnit.SECONDS); &#125; &#125;) .subscribe(integer -&gt; System.out.println(integer)); &#125;//--延迟三秒---发送1---延迟三秒---发送2---延迟3秒---发送3 doOnNext操作符12345678910111213141516171819202122@Testpublic void testRxJava() &#123; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); &#125; &#125;).doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println("前置操作" + integer); integer+=1; &#125; &#125;) .subscribe(System.out::println);&#125;//log前置操作11前置操作22 在每次 OnNext() 方法被调用前执行 使用场景：从网络请求数据，在数据被展示前，缓存到本地 合并操作concat操作符按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。 12345Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4); Observable&lt;Integer&gt; observable2=Observable.just(4,5,6); Observable.concat(observable1,observable2) .subscribe(item-&gt;Log.d("JG",item.toString()));//1,2,3,4,4,5,6 startWith操作符在数据序列的开头增加一项数据。startWith的内部也是调用了concat 123Observable.just(1,2,3,4,5) .startWith(6,7,8) .subscribe(item-&gt;Log.d("JG",item.toString()));//6,7,8,1,2,3,4,5 merge操作符合并被观察者 123456789final String[] aStrings = &#123;"A1", "A2", "A3", "A4"&#125;; final String[] bStrings = &#123;"B1", "B2", "B3"&#125;; final Observable&lt;String&gt; aObservable = Observable.fromArray(aStrings); final Observable&lt;String&gt; bObservable = Observable.fromArray(bStrings); Observable.merge(aObservable, bObservable)//使用merge操作符将两个被观察者合并 .subscribe(getObserver());//这里的观察者依然不重要//"A1", "B1", "A2", "A3", "A4", "B2", "B3" 操作符merge将两个被观察者合并,这里要注意merge之后的Observable是不能保证和原来的Observable发射顺序相同. Zip操作符zip我们想到”压缩“，那么在这个操作符是什么意思呢，请看下面图片 12345678910@Test public void rxJava() &#123; Observable.zip(Observable.just("A", "B", "C"), Observable.just(1,2,3,4,5), new BiFunction&lt;String, Integer, String&gt;() &#123; @Override public String apply(String s, Integer integer) throws Exception &#123; return s+integer; &#125; &#125;).subscribe(s -&gt; System.out.println("value=" + s)); &#125; log 123value=A1value=B2value=C3 结论： zip 组合事件的过程就是分别从发射器A和发射器B各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1永远是和A 结合的，2永远是和B结合的。 最终接收器收到的事件数量是和发送器发送事件最少的那个发送器的发送事件数目相同，所以代码中，4和5是没有配对的，所以也就无法发射合并事件 combineLatest操作符先看一张图，我想你应该已经大致明白意思了 使用场景，表单验证 combineLatest是RxJava本身提供的一个常用的操作符，它接受两个或以上的Observable和一个FuncX闭包。当传入的Observable中任意的一个发射数据时，combineLatest将每个Observable的最近值(Lastest)联合起来（combine）传给FuncX闭包进行处理。要点在于： combineLatest是会存储每个Observable的最近的值的 任意一个Observable发射新值时都会触发操作-&gt;“combine all the Observable’s lastest value together and send to Function” 看一个例子，可以说明 12345678910111213141516171819202122232425262728@Test public void testRxJava() &#123; final String[] aStrings = &#123;"A1", "A2", "A3", "A4"&#125;; final String[] bStrings = &#123;"B1", "B2", "B3"&#125;; final Observable&lt;String&gt; aObservable = Observable.fromArray(aStrings).delay(1,TimeUnit.MILLISECONDS); final Observable&lt;String&gt; bObservable = Observable.fromArray(bStrings); Observable.combineLatest(aObservable, bObservable, new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s1, String s2) throws Exception &#123; return s1+s2; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); &#125;//log//A1B3//A2B3//A3B3//A4B3可见，发送A1的时候B1 B2 B3都已经发射完毕所以，存储每个Observable的最近的值的，也就是B3当B1，B2，B3发射的 A被观察者一个都没发射，所以得至少两个才会合并，这个看图可以解释 ##过滤操作 take等操作符1234567891011121314151617181920//take 取前n个数据Observable.just(1, 2, 3,4,5,6,7) .take(3) .subscribe(System.out::println);//log123//takelast 取后n个数据 Observable.just(1, 2, 3, 4, 5, 6, 7) .takeLast(3) .subscribe(System.out::println);//log567//first 只发送第一个数据 //last 只发送最后一个数据//skip() 跳过前n个数据发送后面的数据//skipLast() 跳过最后n个数据，发送前面的数据 filter操作符顾名思义，过滤发送的事件 12345678910111213 @Test public void testRxJava() &#123; Observable.just(1, 2, 3) .filter(integer -&gt; &#123; if (integer==2) &#123; return false; &#125; return true; &#125;).subscribe(System.out::println); &#125;//log13 ofType过滤指定类型的数据，与filter类似， 123456789101112@Testpublic void rxjava() &#123; Observable.just(1,"1",-1) .ofType(Integer.class) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125;//log1-1 first和last123456789101112131415161718Observable.just(1, 2, 3) .first(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125; &#125;);//1 Observable.just(1, 2, 3) .last(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125; &#125;);//3 未完待续参考：手把手教你使用 RxJava 2.0（一） RxJava combineLatest操作符处理复杂表单验证问题 Android - RxJava2.0 操作符整理归纳]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.0-知识碎片(二)]]></title>
    <url>%2F2018%2F07%2F23%2FRxjava2-0-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Rxjava2.0中的线程调度小节 Scheduler的种类 Schedulers.io( )： 用于IO密集型的操作，例如读写SD卡文件，查询数据库，访问网络等，具有线程缓存机制，在此调度器接收到任务后，先检查线程缓存池中，是否有空闲的线程，如果有，则复用，如果没有则创建新的线程，并加入到线程池中，如果每次都没有空闲线程使用，可以无上限的创建新线程。 Schedulers.newThread( )： 在每执行一个任务时创建一个新的线程，不具有线程缓存机制，因为创建一个新的线程比复用一个线程更耗时耗力，虽然使用Schedulers.io( )的地方，都可以使用Schedulers.newThread( )，但是，Schedulers.newThread( )的效率没有Schedulers.io( )高。 Schedulers.computation()： 用于CPU 密集型计算任务，即不会被 I/O 等操作限制性能的耗时操作，例如xml,json文件的解析，Bitmap图片的压缩取样等，具有固定的线程池，大小为CPU的核数。不可以用于I/O操作，因为I/O操作的等待时间会浪费CPU。 Schedulers.trampoline()： 在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。 Schedulers.single()： 拥有一个线程单例(注意是子线程)，所有的任务都在这一个线程中执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。 Scheduler.from(@NonNull Executor executor)： 指定一个线程调度器，由此调度器来控制任务的执行策略。 AndroidSchedulers.mainThread()： 在Android UI线程中执行任务.需要添加RxAndroid依赖 注意 方式 子线程 主线程 备注 Schedulers.io() yes – 线程池 Schedulers.newThread() yes – 创建新的 Schedulers.computation() yes – 占用CPU，不要i/o耗时 Schedulers.trampoline() yes yes 当前线程 Schedulers.single() yes – 固定一个子线程 Scheduler.from(@NonNull Executor executor) yes yes 指定线程 AndroidSchedulers.mainThread() – yes 主线程，RxAndroid 在RxJava2中，废弃了RxJava1中的Schedulers.immediate( ) 在RxJava1中，Schedulers.immediate( )的作用为在当前线程立即执行任务，功能等同于RxJava2中的Schedulers.trampoline( )，不同的是，Schedulers.trampoline( )是停下当前的任务，先执行插入进来的任务，等执行完后，再将暂停的任务继续执行下去。 Schedulers.trampoline( )在RxJava1中的作用是当其它排队的任务完成后，在当前线程排队开始执行接到的任务，有点像RxJava2中的Schedulers.single()，但也不完全相同，因为Schedulers.single()不是在当前线程而是在一个线程单例中排队执行任务. ​ ​ subscribeOn和observeOn介绍subscribeOnObservable&lt;T&gt; subscribeOn(Scheduler scheduler) subscribeOn通过接收一个Scheduler参数，来指定对数据的处理运行在特定的线程调度器Scheduler上。 若多次设定，则只有一次起作用。 observeOnObservable&lt;T&gt; observeOn(Scheduler scheduler) observeOn同样接收一个Scheduler参数，来指定下游操作运行在特定的线程调度器Scheduler上。若多次设定，每次均起作用。 使用实例实例一：1234567891011121314151617181920212223242526272829@Testpublic void rxjavaThreadScheuler()&#123; Integer [] nums = &#123;1,2,3&#125;; Observable.fromArray(nums) .observeOn(Schedulers.single()) .subscribeOn(Schedulers.io()) .map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; System.out.println("mapA"+"Thread="+Thread.currentThread().getName()+"\r\n"+"integer="+integer); return "num"+integer; &#125; &#125;) .map(new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) throws Exception &#123; System.out.println("mapB"+"Thread="+Thread.currentThread().getName()+"\r\n"+"String="+s); return Integer.parseInt(s.substring(3,s.length())); &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println("subscribe"+"Thread="+Thread.currentThread().getName()+"\r\n"+"integer="+integer); System.out.println("========"); &#125; &#125;);&#125; 123456789101112131415161718192021mapAThread=RxSingleScheduler-1integer=1mapBThread=RxSingleScheduler-1String=num1subscribeThread=RxSingleScheduler-1integer=1========mapAThread=RxSingleScheduler-1integer=2mapBThread=RxSingleScheduler-1String=num2subscribeThread=RxSingleScheduler-1integer=2========mapAThread=RxSingleScheduler-1integer=3mapBThread=RxSingleScheduler-1String=num3subscribeThread=RxSingleScheduler-1integer=3======== 结论： 打印的所有线程均在Schedulers.single()中执行， subscribeOn(Schedulers.io())貌似没有生效，其实 Observable.fromArray(nums)的执行线程，是在Schedulers.io()线程中执行，我们通过实例二验证 实例二：123456789101112131415161718192021222324@Testpublic void rxjavaThreadScheuler() &#123; Integer[] nums = &#123;1, 2, 3&#125;; Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (Integer integer : nums) &#123; emitter.onNext(integer); System.out.println("emitter.onNext()" + "Thread=" + Thread.currentThread().getName() + "\r\n" + "integer=" + integer); &#125; &#125;) .observeOn(Schedulers.single()) .subscribeOn(Schedulers.io()) .map(integer -&gt; &#123; System.out.println("mapA" + "Thread=" + Thread.currentThread().getName() + "\r\n" + "integer=" + integer); return "num" + integer; &#125;) .map(s -&gt; &#123; System.out.println("mapB" + "Thread=" + Thread.currentThread().getName() + "\r\n" + "String=" + s); return Integer.parseInt(s.substring(3, s.length())); &#125;) .subscribe(integer -&gt; &#123; System.out.println("subscribe" + "Thread=" + Thread.currentThread().getName() + "\r\n" + "integer=" + integer); System.out.println("========"); &#125;);&#125; logcat 1234567891011121314151617181920212223242526272829//可见，事件的发布，是在.subscribeOn(Schedulers.io())指定的io线程emitter.onNext()Thread=RxCachedThreadScheduler-1integer=1emitter.onNext()Thread=RxCachedThreadScheduler-1integer=2emitter.onNext()Thread=RxCachedThreadScheduler-1integer=3//其他均在.observeOn(Schedulers.single())指定的Single线程mapAThread=RxSingleScheduler-1integer=1mapBThread=RxSingleScheduler-1String=num1subscribeThread=RxSingleScheduler-1integer=1========mapAThread=RxSingleScheduler-1integer=2mapBThread=RxSingleScheduler-1String=num2subscribeThread=RxSingleScheduler-1integer=2========mapAThread=RxSingleScheduler-1integer=3mapBThread=RxSingleScheduler-1String=num3subscribeThread=RxSingleScheduler-1integer=3======== 结论： subscribeOn()指定的是事件的发布执行的线程，observeOn()指定的是各种操作符和subscribe的onNext，onError，onComplete执行等线程，那么调用多次subscribeOn()或者多次observeOn()，会以哪次为准呢，请看实例三 实例三：多次切换场景1234567891011121314151617181920212223242526272829303132333435363738394041424344public void rxjavaThreadScheuler() &#123; Integer[] nums = &#123;1, 2, 3&#125;; Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; &#123; for (Integer integer : nums) &#123; emitter.onNext(integer); Log.e("rxjava", "emitter.onNext()---&gt;" + Thread.currentThread().getName()); &#125; emitter.onComplete(); &#125;) .subscribeOn(AndroidSchedulers.mainThread())//指定主线程发布事件 .observeOn(Schedulers.single())//切换mapA .map(integer -&gt; &#123; Log.e("rxjava", "mapA---&gt;" + Thread.currentThread().getName()); return "num" + integer; &#125;) .observeOn(AndroidSchedulers.mainThread())//切换mapB .map(s -&gt; &#123; Log.e("rxjava", "mapB线程---&gt;" + Thread.currentThread().getName()); return Integer.parseInt(s.substring(3, s.length())); &#125;) .observeOn(Schedulers.computation())//切换Observer执行线程 .subscribeOn(Schedulers.io())//再此指定发布线程为io .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.e("rxjava", "onSubscribe---&gt;" + Thread.currentThread().getName()); &#125; @Override public void onNext(Integer integer) &#123; Log.e("rxjava", "onNext---&gt;" + Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; Log.e("rxjava", "onError---&gt;" + Thread.currentThread().getName()); &#125; @Override public void onComplete() &#123; Log.e("rxjava", "onComplete---&gt;" + Thread.currentThread().getName()); &#125; &#125;); &#125; logcat 123456789101112131415rxjava: onSubscribe---&gt;main//Observer的onSubscribe回调和发布事件的线程一致，也就是第一次subscribeOn()，若未指定，则在rxjava: emitter.onNext()---&gt;main//第一次subscribeOn()rxjava: emitter.onNext()---&gt;mainrxjava: mapA---&gt;RxSingleScheduler-1//最近一次observeOn（）指定线程，若未指定，默认和subscribeOn的一致，若subscribeOn也未指定，默认是Schedulers.trampoline()rxjava: emitter.onNext()---&gt;mainrxjava: mapA---&gt;RxSingleScheduler-1rxjava: mapA---&gt;RxSingleScheduler-1rxjava: mapB线程---&gt;main//最近一次observeOn（）指定线程rxjava: mapB线程---&gt;mainrxjava: mapB线程---&gt;mainrxjava: onNext---&gt;RxComputationThreadPool-1//Observer的onNext，由最近一次的observeOn（）指定rxjava: onNext---&gt;RxComputationThreadPool-1rxjava: onNext---&gt;RxComputationThreadPool-1rxjava: onComplete---&gt;RxComputationThreadPool-1//Observer的onComplete，由最近一次的observeOn（） 结论： 多个subscribeOn()以第一个为主 多个observeOn（）指定以下操作执行线程 若不指定observeOn（），默认按subscribeOn()指定的线程一致 若不指定subscribeOn()，默认是Schedulers.trampoline()（在当前线程，停下之前任务，先执行本次任务） 注意：Observer的onSubscribe(Disposable d)回调，以subscribeOn()为主，而不是以observeOn（）为主 其他三个回调onNext，onError，onComplete以observeOn（）为主 实例四Schedulers.trampoline()： log 12345678910111213System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:0System.out: 接收线程:RxCachedThreadScheduler-1----&gt;接收:0System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:1System.out: 接收线程:RxCachedThreadScheduler-1----&gt;接收:1System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:2System.out: 接收线程:RxCachedThreadScheduler-1----&gt;接收:2System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:3System.out: 接收线程:RxCachedThreadScheduler-1----&gt;接收:3System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:4System.out: 接收线程:RxCachedThreadScheduler-1----&gt;接收:4//可以看到//Schedulers.trampoline()指定Consumer回调执行线程和发布事件线程一样//Schedulers.trampoline()的作用在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。 结论： Schedulers.trampoline()的作用在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。【本实例的体现：当observe接受的时候，事件停止了发送】 实例五Schedulers.single() log 1234567891011121314System.out: 发射线程:RxSingleScheduler-1----&gt;发射:0System.out: 发射线程:RxSingleScheduler-1----&gt;发射:1System.out: 发射线程:RxSingleScheduler-1----&gt;发射:2System.out: 处理线程:RxSingleScheduler-1----&gt;处理:0System.out: 处理线程:RxSingleScheduler-1----&gt;处理:1System.out: 处理线程:RxSingleScheduler-1----&gt;处理:2System.out: 接收线程:RxSingleScheduler-1----&gt;接收:0System.out: 接收线程:RxSingleScheduler-1----&gt;接收:1System.out: 接收线程:RxSingleScheduler-1----&gt;接收:2//发布和接受都是single线程//接收在Schedulers.single()的线程单例中排队执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行 //所以可以达到。 完全发射---完全处理---完全接受的流程 参考连接]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.0-知识碎片(一)]]></title>
    <url>%2F2018%2F07%2F23%2FRxjava2-0-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Observable.create(ObservableOnSubscribe)和subscribe()基本使用 Observable.create(ObservableOnSubscribe)的使用获得一个Observable有很多种方式，通过我们下面的动图可以看到 今天的碎片化整理，就只整理最普通的一种方式Observable.create(ObservableOnSubscribe) 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * ObservableEmitter:Emitter是发射器的意思， * 它可以发出三种类型的事件， * 通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。 * 发射满足规则： * 1，Observable可以发送无限个onNext, Observer也可以接收无限个onNext * 2，发送了一个onComplete后, Observable的onComplete或者onError之后的事件将会继续发送, 而Observer收到onComplete/onError事件之后将不再继续接收事件. * 3，Observable可以发送无限个onNext可以不发送onComplete或onError. * 4，Observable不可以发送多个onComplete和多个onError（onComplete和onError加一起只能发射一次） * 5，Observable发射多个onComplete不报错（只收到第一个onComplete就不再接受了）。发射多个onError会报错 */@Testpublic void rxjava() &#123; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext("hello"); emitter.onNext("rxjava"); emitter.onComplete(); emitter.onNext("无法接受"); &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println("onSubscribe"); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext:value=" + s); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:error" + e.getMessage()); &#125; @Override public void onComplete() &#123; System.out.println("onComplete"); &#125; &#125;);&#125; logcat： 1234onSubscribeonNext:value=helloonNext:value=rxjavaonComplete 发送规则 发射满足规则： 1，Observable可以发送无限个onNext, Observer也可以接收无限个onNext 2，发送了一个onComplete后, Observable的onComplete或者onError之后的事件将会继续发送, 而Observer收到onComplete/onError事件之后将不再继续接收事件. 3，Observable可以发送无限个onNext可以不发送onComplete或onError. 4，Observable不可以发送多个onComplete和多个onError（onComplete和onError加一起只能发射一次） 5，Observable发射多个onComplete不报错（只收到第一个onComplete就不再接受了）。发射多个onError会报错 这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe() 以上几个规则用示意图表示如下: 示意图 只发送onNext事件 next 发送onComplete事件 complete 发送onError事件 error 参考链接 onSubscribe(Disposable d)的参数Disposable12345678910111213141516171819202122232425262728293031323334353637383940414243@Test public void rxjava() &#123; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; public Disposable mDisposable; @Override public void onSubscribe(Disposable d) &#123; System.out.println("onSubscribe"); this.mDisposable = d; &#125; @Override public void onNext(Integer integer) &#123; if (integer == 3) &#123; System.out.println("onNext:isDisposed=" + mDisposable.isDisposed()); mDisposable.dispose(); System.out.println("onNext:isDisposed=" + mDisposable.isDisposed()); &#125; System.out.println("onNext:valuse=" + integer); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError"); &#125; @Override public void onComplete() &#123; System.out.println("onComplete"); &#125; &#125;); &#125; logcat： 123456onSubscribeonNext:valuse=1onNext:valuse=2onNext:isDisposed=falseonNext:isDisposed=trueonNext:valuse=3 由代码可看出： onSubscribe方法最先调用，并且只调用一次 Disposable.dispose()调用后，onNext将接受不到发出的4，5事件（但是emitter.onNext(4);​ emitter.onNext(5)确实执行了； Disposable的用处不止这些, 后面讲解到了线程的调度之后, 我们会发现它的重要性.后续补充 subscribe()的多个重载的方法1234561,public final Disposable subscribe() &#123;&#125;2,public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;3,public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; 4,public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;5,public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;6,public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 下游无法接受 带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写 Observer参数，如例子，比较完整的onSubscribe，onNext，onComplete，onError 如果我们不需要其他回调，可选择我们需要的Consumer 的具体参数 参考链接]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SharedPreferences的缺陷]]></title>
    <url>%2F2018%2F07%2F19%2FSharedPreferences%E7%9A%84%E7%BC%BA%E9%99%B7%2F</url>
    <content type="text"><![CDATA[SharedPreferences在Android使用非常普遍，本文记录一下它的不足之处和使用注意事项 前言SharedPreferences是Android SDK提供的工具，可以存储应用的一些配置信息，这些信息会以键值对的形式保存在/sdcard/data/data/packageName/shared_prefs/路径下的一个xml文件中。它提供了多种数据类型的存储，包括：int、long、boolean、float、String以及Set&lt;String&gt;。 使用方式 context.getSharedPreference(name, mode); PreferenceManager.getDefaultSharedPreferences(context); 这两种方式其实具体实现是一样的，只不过一个是开发者自己定义名字，另一个是使用包名+”_preference”作为存储文件名。 问题若我们大量使用PreferenceManager.getDefaultSharedPreferences(context);，将各种配置项全部存储到一个sp中，就可能会导致一个问题：该文件过大，读取配置项过慢 所以推荐，根据情况，将不同的配置文件保存在不同的sp中，而不是全部使用默认的sp，导致同一个sp文件过大 第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。 解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。 这些key和value会永远存在于内存之中，占用大量内存。 其他注意 被加载进来的这些大对象，会永远存在于内存之中，不会被释放。 ContextImpl这个类，在getSharedPreference的时候会把所有的sp放到一个静态变量里面缓存起来： static的sSharedPrefsCache，它保存了你所有使用的sp 1234567891011121314151617@GuardedBy("ContextImpl.class")private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt;sSharedPrefsCache;private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123; if (sSharedPrefsCache == null) &#123; sSharedPrefsCache = new ArrayMap&lt;&gt;(); &#125; final String packageName = getPackageName(); ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName); if (packagePrefs == null) &#123; packagePrefs = new ArrayMap&lt;&gt;(); sSharedPrefsCache.put(packageName, packagePrefs); &#125; return packagePrefs;&#125; 存储JSON等特殊符号很多的value 在sp里面存json或者HTML；这么做不是不可以，但是，如果这个json相对较大，那么也会引起sp读取速度的急剧下降。 JSON或者HTML格式存放在sp里面的时候，需要转义，这样会带来很多 &amp; 这种特殊符号，sp在解析碰到这个特殊符号的时候会进行特殊的处理，引发额外的字符串拼接以及函数调用开销。而JSON本来就是可以用来做配置文件的，你干嘛又把它放在sp里面呢？ 多次edit多次apply 12345SharedPreferences sp = getSharedPreferences("test", MODE_PRIVATE);sp.edit().putString("test1", "sss").apply();sp.edit().putString("test2", "sss").apply();sp.edit().putString("test3", "sss").apply();sp.edit().putString("test4", "sss").apply(); 每次edit都会创建一个Editor对象，额外占用内存；当然多创建几个对象也影响不了多少；但是，多次apply也会卡界面你造吗？ 有童鞋会说，apply不是在别的线程些磁盘的吗，怎么可能卡界面？我带你仔细看一下源码。 1234567891011121314151617181920212223public void apply() &#123; final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() &#123; public void run() &#123; try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;; QueuedWork.add(awaitCommit); Runnable postWriteRunnable = new Runnable() &#123; public void run() &#123; awaitCommit.run(); QueuedWork.remove(awaitCommit); &#125; &#125;; SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); notifyListeners(mcr);&#125; 注意两点，第一，把一个带有await的runnable添加进了QueueWork类的一个队列；第二，把这个写入任务通过enqueueDiskWrite丢给了一个只有单个线程的线程池执行。 到这里一切都OK，在子线程里面写入不会卡UI。但是，你去ActivityThread类的handleStopActivity里看一看： 12345678910private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123; // 省略无关。。 // Make sure any pending writes are now committed.（确保所有延迟写入完成） if (!r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; // 省略无关。。&#125; 如果在Activity Stop的时候，已经写入完毕了，那么万事大吉，不会有任何等待，这个函数会立马返回。但是，如果你使用了太多次的apply，那么意味着写入队列会有很多写入任务，而那里就只有一个线程在写。当App规模很大的时候，这种情况简直就太常见了 虽然apply是在子线程执行的，但是请不要无节制地apply；commit我就不多说了吧？直接在当前线程写入，如果你在主线程干这个 SP多进程不可靠 sp有一个貌似可以提供「跨进程」功能的FLAG——MODE_MULTI_PROCESS 文档也说了，这玩意在某些Android版本上不可靠，并且未来也不会提供任何支持，要是用跨进程数据传输需要使用类似ContentProvider的东西。而且，SharedPreference的文档也特别说明： Note: This class does not support use across multiple processes. 12345678910111213141516171819202122@Overridepublic SharedPreferences getSharedPreferences(File file, int mode) &#123; checkMode(mode); SharedPreferencesImpl sp; synchronized (ContextImpl.class) &#123; final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) &#123; sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; &#125; &#125; if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123; // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); &#125; return sp;&#125; 这个flag保证了啥？保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个sp的时候，如果有这个flag，会重新读一遍文件，仅此而已 总结 不要存放大的key和value！会引起界面卡、频繁GC、占用内存等等 毫不相关的配置项就不要丢在一起了！文件越大读取越慢，防止全部放进defalut的sp！ 读取频繁的key和不易变动的key尽量不要放在一起，影响速度。（如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失） 不要乱edit和apply，每次edit会创建新的EditorImpl对象，尽量批量修改一次提交！ 尽量不要存放JSON和HTML，这种场景请直接使用json（文件存取）！ Commit发生在UI线程中，apply发生在工作线程中，对于数据的提交最好是批量操作统一提交。虽然apply发生在工作线程（不会因为IO阻塞UI线程）但是如果添加任务较多也有可能带来其他严重后果（参照ActivityThread源码中handleStopActivity方法实现）。 跨进程通信不可靠]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks服务端部署]]></title>
    <url>%2F2018%2F07%2F18%2Fshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[基于Ubuntu 16.04的Shadowsocks服务端安装 安装步骤1，首先检查下Python 版本，要有 2.6 or 2.7.12python --versionPython 2.7.4 2，安装python包管理器1apt-get install python-pip 3，安装shadowsocks1pip install shadowsocks 4，修改配置文件1vim /etc/shadowsocks/config.json 1234567891011121314&#123; "server":"0.0.0.0", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"yourpsw", "timeout":300, "method":"bf-cfb", "fast_open": true, "workers": 10&#125;注意：server 0，0，0，0（其他可能出问题）method bf-cfb（其他可能出问题） 5，开启1sudo ssserver -c /etc/shadowsocks/config.json 6，设置为开机启动 编辑 1vim /etc/rc.local 然后在exit 0之前加入1sudo ssserver -c /etc/shadowsocks/config.json 重启 1● reboot 重启后查看进程 1ps aux | grep shadowsocks 参考：参考1 参考2 参考3]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql关联阿里云dms]]></title>
    <url>%2F2018%2F06%2F14%2Fmysql%E5%85%B3%E8%81%94%E9%98%BF%E9%87%8C%E4%BA%91dms%2F</url>
    <content type="text"><![CDATA[将远程服务器中的mysql绑定到阿里云DMS中 阿里云DMS绑定mysql 数据管理DMS登录云服务器的IP段（经典网络）：DMS的ip段 120.55.177.0/24 121.43.18.0/24 101.37.74.0/24 10.153.176.106/24 10.137.42.136/24 11.193.54.0/24 数据管理DMS登录云服务器的IP段（VPC）： 100.104.175.0/24 100.104.72.0/24 100.104.5.0/24 100.104.205.0/24 添加白名单1，登录mysql： 1mysql -h host -u username -p password 2，切换至mysql库： 1use mysql; 3 查看当前允许登录IP及用户 1select Host,User from user; 4 删除不必要而表中存在的IP和用户 1DELETE FROM user WHERE User='username' and Host='host'; (host值为“%”或空表示所有IP都可登录，一般来说此类行需要删掉) 5 增加需要而表中没有的IP和用户 1GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION; 6 使更新的配置生效 1FLUSH PRIVILEGES; 登录mysql失败问题错误 ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES) vim /etc/my.cnf(注：windows下修改的是my.ini) 123456789101112131415161718192021[mysqld]sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# 一般配置选项basedir = /usr/local/mysqldatadir = /usr/local/mysql/dataport = 3306socket = /tmp/mysql.sockcharacter-set-server=utf8#在此添加【主意是在[mysqld]内部】skip-grant-tablesback_log = 300max_connections = 1000max_connect_errors = 50table_open_cache = 4096max_allowed_packet = 32M#binlog_cache_size = 4M :wq 保存 接下来我们需要重启MySQL： 各个平台重启mysql的方式 1service mysqld restart 重启之后输入#mysql即可进入mysql。 接下来就是用sql来修改root的密码 123456mysql&gt; use mysql;mysql&gt; update user set password=password("你的新密码") where user="root";mysql&gt; flush privileges;mysql&gt; quit到这里root账户就已经重置成新的密码了。 5.编辑my.cnf,去掉刚才添加的内容，然后重启MySQL。 查看当前mysql用户表host为% 代表任意域名下都可以访问 12345678910mysql&gt; select Host,User from user;+-----------------+-----------+| Host | User |+-----------------+-----------+| % | dms || 120.55.177.0/24 | dms || localhost | mysql.sys || localhost | root |+-----------------+-----------+4 rows in set (0.00 sec)]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative碎片整理之Props]]></title>
    <url>%2F2018%2F04%2F28%2FReactNative%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E4%B9%8BProps%2F</url>
    <content type="text"><![CDATA[props的属性都是父组件传递的，所以无法修改它，但是我们可以指定默认prop； 基本介绍大多数组件创建的时就可以使用各种参数来定制（可以理解为Android自定义View的传值）。但这是不准确的，props在RN中代表着属性，是为了描述一个组件的特征而存在，它是由父组件传递给子组件的（调用方传入）而且一经指定，在被指定的组件的生命周期则不在改变（这与state不同），所以要使用，我们首先在父组件中定义子组件的属性，但不可以添加默认属性（可以在子组件中添加默认属性），props除了传递属性值，还有约束作用… 普通使用以常见的基础组件Image为例，在创建一个图片时，可以传入一个名为source的 prop 来指定要显示的图片的地址，以及使用名为style的 prop 来控制其尺寸。 12345678910111213import React, &#123; Component &#125; from 'react';import &#123; Image &#125; from 'react-native';export default class Bananas extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; ); &#125;&#125; 以上就是prop的最简单的理解，基础组件Image的style和resource都是它的prop属性 自定义Props123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123;Component&#125; from 'react';import &#123; View, StyleSheet, Alert, TouchableOpacity, Text,&#125; from 'react-native';class MyText extends Component &#123; // 构造 constructor(props) &#123; super(props); &#125; //指定默认props static defaultProps = &#123; myText: '默认值' &#125; render() &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; Alert.alert('Alert') &#125;&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.myText&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;MyText myText='测试'/&gt; &lt;MyText myText='android'/&gt; &lt;MyText myText='ios'/&gt; &#123;/*传入未指定的pros*/&#125; &lt;MyText test='hello'/&gt; &#123;/*未传入pros*/&#125; &lt;MyText /&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; continer: &#123; color: '#ffffff', fontSize: 17, backgroundColor: '#00a056', margin: 20, padding: 10, shadowColor: '#00a056', shadowOffset: &#123;width: 3, height: 3&#125;, shadowOpacity: 0.5, shadowRadius: 4 &#125;&#125;) props约束使用PropTypes 已经被取消了 react native关于 从react中引入PropTypes报错的问题 方法中调用this.props的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, &#123;Component&#125; from 'react';import &#123; View, StyleSheet, Alert, TouchableOpacity, Text,&#125; from 'react-native';class MyText extends Component &#123; // 构造 constructor(props) &#123; super(props); &#125; //指定默认props static defaultProps = &#123; name: '冯英俊', age: 1, &#125; //点击弹出传入的信息 _onClickEvent() &#123; Alert.alert(this.props.name, "年纪" + this.props.age) &#125; render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this._onClickEvent&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.name&#125;你的年纪是&#123;this.props.age&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;MyText name='刘德华' age=&#123;20&#125;/&gt; &lt;MyText age=&#123;18&#125;/&gt; &lt;MyText name='刘德华' age=&#123;22&#125;/&gt; &lt;MyText name='刘德华' age=&#123;30&#125;/&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; continer: &#123; color: '#ffffff', fontSize: 17, backgroundColor: '#00a056', margin: 20, padding: 10, shadowColor: '#00a056', shadowOffset: &#123;width: 3, height: 3&#125;, shadowOpacity: 0.5, shadowRadius: 4 &#125;&#125;) React Native绑定this(bind(this)) 【React Native】React Native的bind方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_onClickEvent() &#123; Alert.alert(this.props.name, "年纪" + this.props.age)&#125;//修改为：render() &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; this._onClickEvent()&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.name&#125;你的年纪是&#123;this.props.age&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; )&#125;//或者render() &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt;&#123; Alert.alert(this.props.name, "年纪" + this.props.age) &#125;&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.name&#125;你的年纪是&#123;this.props.age&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;//或者render() &#123; return ( &lt;TouchableOpacity onPress=&#123;this._onClickEvent.bind(this)&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.name&#125;你的年纪是&#123;this.props.age&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;//或者 箭头函数完成bind render() &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; this._onClickEvent('hello') &#125;&#125;&gt; &lt;Text style=&#123;styles.continer&#125;&gt; hello &#123;this.props.name&#125;你的年纪是&#123;this.props.age&#125;! &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125; 关于ReactNative的this更多内容后面会再整理 参考：ReactNative中文网]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Dalvik和ART的区别]]></title>
    <url>%2F2018%2F03%2F05%2F%E6%B5%85%E6%9E%90Dalvik%E5%92%8CART%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Dalvik是Google公司自己设计用于Android平台的虚拟机，Dalvik经过优化，更加适合Android平台（具体优点见下面和JVM比较）。 2014年6月谷歌I/O大会上，Android L(5.0)改动幅度比较大，删除了Dalvik，而是用ART代替。 之前对本块的知识理解比较零散，再此本文总结下Dalvik和ART的原理，和二者的区别，以及Jvm和Dalvik的区别，以及Android的Apk编译打包的流程 Dalvik的相关知识 Google公司自己设计用于Android平台的java虚拟机 支持.dex（即Dalvik Executable）格式的java应用程序运行 基于寄存器，寄存器CPU的一部分（适合内存和处理器有限的系统） 允许有限的内存同时运行多个Dalvik虚拟机的实例 每个Dalvik应用作为一个独立的Linux进程执行，防止一个程序崩溃导致所有程序崩溃 Jvm的相关知识 基于栈（内存的一部分） javac把程序源码编译成JAVA字节码后，JVM通过逐条解释字节码翻译成机器指令 Dalvik和Jvm的区别与联系图表区别 本质 字节码文件 效率 Dalvik 基于寄存器 一个.Dex文件 高 Jvm 基于栈 多个.class文件 低 首要区别 DVM基于寄存器，Jvm基于栈，基于寄存器的编译花费时间更短（在.dex字节码中，变量会赋值给65535个可用寄存器中的任何一个，Dalvik指令直接操作这些寄存器，而不是访问堆栈中的元素。） dex字节码更适合于内存和处理器速度有限的系统 基于寄存器的Dalvik实现虽然牺牲了一些平台无关性，但是它在代码的执行效率上要更胜一筹。 每一个Android 的App是独立跑在一个VM中的。因此一个App crash只会影响到自身的VM，不会影响到其他。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个 Dalvik应用作为一个独立的Linux进程执行。 字节码区别 JVM字节码由.class组成，每个java文件对应一个.class DVM字节码只包含一个.dex文件，这个文件包含了程序中所有的类 Dalvik可执行文件体积小。Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码。 简单来讲，dex格式文件就是将多个class文件中公有的部分统一存放，去除冗余信息。 ART的相关知识（Android Runtime）Android Runtime（缩写为 ART），是一种在Android操作系统上的运行环境，由Google公司研发，并在2013年作为Android 4.4系统中的一项测试功能正式对外发布，在Android 5.0及后续Android版本中作为正式的运行时库取代了以往的Dalvik虚拟机。ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机。它与Dalvik的主要不同在于：Dalvik采用的是JIT技术，而ART采用Ahead-of-time（AOT）技术。 ART同时也改善了性能、垃圾回收(Garbage Collection)、应用程序除错以及性能分析。 JIT最早在Android 2.2系统中引进到Dalvik虚拟机中，在应用程序启动时，JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作。 与Dalvik虚拟机不同的是，ART引入了AOT这种预编译技术，在应用程序安装的过程中，ART就已经将所有的字节码重新编译成了机器码。应用程序运行过程中无需进行实时的编译工作，只需要进行直接调用。因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升。 为了保证向下兼容，ART使用了相同的Dalvik字节码文件（dex），即在应用程序目录下保留了dex文件供旧程序调用然而.odex文件则替换成了可执行与可链接格式（ELF）可执行文件。一旦一个程序被ART的dex2oat命令编译，那么这个程序将会指通过ELF可执行文件来运行。因此，相对于Dalvik虚拟机模式，ART模式下Android应用程序的安装需要消耗更多的时间，同时也会占用更大的储存空间（指内部储存，用于储存编译后的代码）,但节省了很多Dalvik虚拟机用于实时编译的时间。 Google公司在Android 4.4中带来的ART模式仅仅是ART的一个预览版，系统默认仍然使用的是Dalvik虚拟机，4.4上面提供的预览版ART相对于Android 5.0以后的ART运行时库有较大的不同，尤其体现在兼容性上。 总结一下上诉内容： Android 4.4系统后出现（预览版），系统默认仍然使用的是Dalvik虚拟机，5.0以后是正式版取代了Dalvik虚拟机 ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机 为了保证向下兼容，ART使用了相同的Dalvik字节码文件（dex）（而在安装过程中，会通过dex2oat工具生成OAT文件，具体见下面分析） Android运行时ART加载OAT文件过程分析查看其他博客分析 ART核心是OAT文件 是APK在安装的过程中，会通过dex2oat工具生成一个OAT文件 APK安装过程中生成的OAT文件的输入只有一个DEX文件，也就是来自于打包在要安装的APK文件里面的classes.dex文件（实际上，一个OAT文件是可以由若干个DEX生成的） OAT文件是一种Android私有ELF 它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容 Dalvik和ART的区别与联系 Dalvik和ART使用的的都是.dex字节码，事实上我们把apk解压后确实只有classes.dex文件，但是在ART虚拟机在安装过程中通过dex2oat工具将一个或者诺干个dex生成一个OAT文件 ART（Ahead-of-time AOT预编译技术）：应用程序在安装过程中，ART将所有的字节码重新编译成了机器码，所以应用程序运行中无需进行实时编译工作，只需要进行直接调用，因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升，但是安装需要更多的内存空间（存储编译后的代码）和时间，节省了很多Dalvik虚拟机用于实时编译的时间 Dalvik（Just-in-time JIT即时编译技术）：（jvm也是JIT即时编译），在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行。虽然安装过程比较快，但是拖慢了应用每次启动的速度 编译技术 （时机）字节码编译机器码 占用空间 安装时间 运行效率（） Dalvik JIT（即时编译） 首次安装时 小 快 慢 ART AOT（预编译技术） 应用每次启动时 大（10-20%） 满 快 几张截图总结查看原文]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal的理解]]></title>
    <url>%2F2018%2F03%2F02%2FThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ThreadLocal相关整理 JDK1.2提供 根据JDK文档中的解释： ThreadLocal的作用是提供线程内的局部变量，这种变量在多线程环境下访问时能够保证各个线程里变量的独立性。 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立改变该变量的副本，而不会影响其他线程所对应的副本。 ThreadLocal的使用： 可以看到我们用ThreadLocal存放了一个String字符串，在不同的线程set数值后，只在当前线程管用，所以说，如同上述所说的 一个ThreadLocal可以被多个线程共享 每个线程对同一个ThreadLocal的set get操作只针对当前线程管用 ThreadLocal的原理以及源码介绍大概了解了ThreadLocal如何使用，那么请问，ThreadLocal如何保证不同线程的独立性的呢？ ThreadLocal几个内部方法protected T initialValue()（如果不想初始值返回null，需要重写initialValue方法）123protected T initialValue() &#123; return null;&#125; public T get()（该方法返回当前线程变量副本。如果这是线程第一次调用该方法，则创建并初始化此副本。）/** 1234567891011121314151617 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; public void set(T value)/** 12345678910111213141516 * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 由get和set源码可以看出，数据的存取都是先获取ThreadLocalMap对象，从ThreadLocalMap存取 ThreadLocalMap是一个map，它的key，就是threadLocal本身，值就是存放的变量副本 每个线程对应一个本地变量的map，每个可以存放多个线程本地变量（即不同的ThreadLocal） public void remove()（jdk1.5后出现）/** 123456789101112131415* Removes the current thread's value for this thread-local* variable. If this thread-local variable is subsequently* &#123;@linkplain #get read&#125; by the current thread, its value will be* reinitialized by invoking its &#123;@link #initialValue&#125; method,* unless its value is &#123;@linkplain #set set&#125; by the current thread* in the interim. This may result in multiple invocations of the* &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.** @since 1.5*/public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 通过remove源码可以看到， 先通过ThreadLocal的getMap（Thread.currentThread()）方法拿到当前线程的ThreadLocalMap 然后再在当前线程的ThreadLocalMap中get，set，remove 关于remove需要知道的几点： 为什么移除某个ThreadLocal的值： 目的是减少内存缓存，remove之后如果再次访问此线程局部变量的值，将返回initiValue初始值 线程结束后，该线程对应的所有局部变量将自动被垃圾回收，但是显示调用remove清楚线程局部变量不是必须操作，但是可以加快内存回收的速度 ThreadLocal和同步机制synchonzied的区别 ThreadLocal：以空间换时间 synchonzied：以时间换空间 synchonzied同步机制： 为多线程对相同资源的并发访问控制，保证了多线程之间的数据共享，同步会带来巨大的性能开销，所以同步操作应该是细粒度的（对象中的不同元素使用不同的锁，而不是整个对象一个锁），以时间换空间的意思是：使用同步真正的风险是复杂性和可能破坏资源安全,而不是性能。 ThreadLocal线程局部变量机制： 空间换取时间，不同线程访问同一ThreadLocal，数据的存取是当前线程的数据副本，也就是说不同线程在某一时间访问到的并不是同一对象，所以效率比较高，但是占用内存比较大，当线程结束之后，remove会加快内存的回收速度。 Synchronized着重于线程间的数据共享，而ThreadLocal则着重于线程间的数据隔离。 ThreadLocal的弊端（内存泄露）内存泄露原因ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部的强引用，那么在系统GC的时候，这个ThreadLocal就会被回收掉 ThreadLocal被回收掉之后，那么当前Thread的ThreadLocalMap中间就会出现key为null的Entry key为null的话就意味着，没有办法访问这些key对应的值，就会存在以下的这样一个强引用链 value —Entry—TreadLocalMap–Thread 内存泄露解决ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。 以下操作会导致内存泄露 使用static的ThreadLocal，延长了ThreadLocal的生命周期，导致某个线程Thread结束后，但是Thread内部的ThreadLocalMap中存在这个静态的ThreadLocal，导致ThreadLocalMap没法被回收，导致该Thread没法被回收 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。因为如上所说 get(),set(),remove()会清理线程ThreadLocalMap里所有key为null的value Android中ThreadLocal的体现Handler消息机制熟悉Handler机制的都知道 在ActivityThread的main方法中Looper.prepareMainLooper();或者在自己创建的线程中Looper.pepare()的时候 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 创建了一个Looper对象并使用sThreadLocal的set方法进行保存 并且这个ThreadLocal在Looper类中是静态的，如下 那就是说，这个静态的ThreadLocal，可以供任何线程访问，但是任意线程中取出来的looper，都只是线程局部变量，都是在副本 所以说，每个线程对应一个looper， 对于ThreadLocal的总结，暂时整理到这里，后续补充 ♨]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.X的gradle依赖implementation]]></title>
    <url>%2F2018%2F01%2F24%2F3-x%E7%9A%84gradle%E4%BE%9D%E8%B5%96implementation%2F</url>
    <content type="text"><![CDATA[依赖方式有很多，我们这里只弄清楚implementation和Compile的区别，就好了 implementation和Compile的区别先看下图 假设： LibraryA—–—–implementation———LibraryC App Module 无法使用LibraryC LibraryB—–—–compile———LibraryD App Module 可以使用LibraryD 好处 可以加快编译速度 隐藏对外不必要的接口 为什么能够加快编译速度呢 这对于大型项目含有多个Moudle模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译LibraryA模块就行， 如果使用的是api或者旧时代的compile，由于App Moudle 也可以访问到 LibraryC,所以 App Moudle部分也需要重新编译。 其他几种方式首先是2.x版本的依赖方式： Compile Provided APK Test compile Debug compile Release compile 再来看看3.0的 Implementation API Compile only Runtime only Unit Test implementation Test implementation Debug implementation Release implementation 2.x版本依赖的可以看看下面的说明，括号里对应的是3.0版本的依赖方式。 compile（api）这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。当我们依赖一些第三方的库时，可能会遇到com.android.support冲突的问题，就是因为开发者使用的compile依赖的com.android.support包，而他所依赖的包与我们本地所依赖的com.android.support包版本不一样，所以就会报All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes这个错误。 support包冲突 provided（compileOnly）只在编译时有效，不会参与打包可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在debug模式的编译和最终的debug apk打包时有效 releaseCompile（releaseImplementation）Release compile 仅仅针对Release 模式的编译和最终的Release apk打包。 参考： Android Studio3.x新的依赖方式（implementation、api、compileOnly） ###]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈启动流程]]></title>
    <url>%2F2017%2F12%2F29%2F%E8%B0%88%E8%B0%88%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习一]]></title>
    <url>%2F2017%2F12%2F25%2FReactNative%20start%2F</url>
    <content type="text"><![CDATA[ReactNative 学习一 1，为什么学习ReactNative好处 因为现在许多主流的应用都有React Native的影子，它对比原生开发更为灵活，对比H5体验更为高效，而且跨平台的支持特性。 相对ionic这类PhoneGap，它效率更高，和原生之间的交互更方便。 多个版本迭代后的今天，它已经拥有了丰富第三方插件支持。 React Native解决不了的，可以通过各位熟悉的原生来解决。 更方便的热更新。 坏处 尽管是跨平台，但是不同平台Api的特性与显示并不一定一致。 相对增大了app的体积。 调试’相对‘麻烦。 Android上的兼容性问题。 总的来说React Native适合作为项目中的补充，而不是作为核心去开发APP。 2，搭建开发环境 Webstrom（号称web开发神器，目前对前端的了解有限，因为和android stuido师出同门，所以不商量直接选用他，当然stom也试了试，但是快捷键不如Webstrom熟悉） HomeBrew（Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件 Node（基于 Chrome V8 引擎的 JavaScript 运行环境） Androd Studio（安卓老本家没啥说的） ReactNative的命令行工具（react-native-cli，React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务 详细搭建步骤查看ReactNative中文网 一步一步安装完毕后，没错，你已经起飞了； 3，创建一个项目 终端cd到你想初始化项目的文件夹 1react-native init FirstRNApp 然后会发现创建了一个FirstRNApp文件夹，这就是创建的第一个项目 几个关键的文件 android文件夹，就是一个可以用android studio打开的android项目。 ios文件夹，是一个可以用xcode打开的ios项目。 index.android.js，这是android的React Native入口文件。 index.ios.js，这是ios的React Native入口文件。 package.json，类似android studio的build.gradle，你依赖的库都写在里面。 node_module文件夹，你依赖的库下载下来都存放在里面，属于git的忽略文件，你要找的依赖库源码也在里面，包括React和React Native。 jscode文件夹，是自己创建的文件夹，用来存放自己写的js文件。 需要注意的点package.json 类似于android studio中的build.gradle添加远程依赖，不同的是，package.json大多数时候不需要我们手动添加，我们只需要在根目录通过命令行，npm install xxxxxx --save 就可以依赖一个库了。 install之后，库的依赖信息，自动被写到package.json里面，对应的库也会被下载到node_module文件夹中，类似android studio依赖后把aar同步到本地。 node_module node_module是一个忽略文件，提交的时候不需要提交到git上，类似android studio远程依赖下来的aar，也不会提交到git上。其他人在使用React Native项目时，只需要npm install，工程就会根据package.json，去同步下载各个依赖库到node_module。 注：有时候还需要运行react-native link 或 react-native link xxx，这是因为有些第三方库是通过原生代码加React Native实现的，通过这个命令，可以自动把相关的配置代码，自动添加到android和ios工程中。 运行这个项目作为安卓端有两种方式，ios也同样有两种 cd到项目根目录 1react-native run-android【react-native run-ios】 或者用android stuido直接打开项目中的android文件夹（上面有说过，这是一个可以独立打开的安卓项目） 遇到的小坑1，无法从资产的index.android.bundle中加载脚本。确保你的包被正确打包或者你正在运行一个packager服务器 搜索了一波，这个错误很常见，解决的办法也很常见，如下 打开自己的项目文件夹,在Android/app/src/main目录下创建一个空的assets文件夹 cd到项目根目录，执行 1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res 事实证明并没有解决我的问题 解决我的问题的是下面这行 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res 我们可以回头看上面创建完项目的截图，老版的是分别有index.android.js和index.ios.js 而我创建的却没有这两个文件，只有一个index.js,修改完之后，我们创建的assets目录下会生成bundle的两个文件 运行成功（android端） 相关资料 [恋猫月亮博客]https://www.jianshu.com/p/97692b1c451d) 中文网 报错 本文仅作个人学习总结，如有出入不够严谨的地方，请联系更改。 ReactNative才刚刚起步学习，麻烦和坑后续还会经常碰到。但是，既然选择了学习，就要坚持下来！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈加密算法]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%B0%88%E8%B0%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在应用开发的过程中，客户端和移动端要频繁的进行数据传输，涉及到重要隐私信息的时候，就需要进行数据加密，，即使传输的过程中被截取，也不会信息泄漏。对于加密算法，不少开发者也早有耳闻，例如：Base64，MD5，RSA，AES，DES加密等等，今天就总结一下加密算法 对称加密和非对称加密对称加密：对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。 对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。 非对称加密：非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。 目前最常用的非对称加密算法是RSA算法，是Rivest, Shamir, 和Adleman于1978年发明 对称加密和非对称加密虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密使用的密钥用非对称加密，参考网上，看下面的一个例子： 铁头需要在银行的网站上做一笔交易，他的游览器生成了一个随机数作为对称密钥 铁头的游览器向银行请求非对称加密的公钥 银行将公钥发送给铁头 铁头用这个公钥将自己的对称密钥进行加密 铁头将加密后的对称密钥发送给银行 银行用非对称加密的私有密钥对这个对称密钥进行解密获取到铁头的对称密钥 铁头与银行可以使用对称密钥来对沟通的内容进行加密与解密了。 对称和非对称加密总结 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。 非对称加密例子 RSA（参考这里） 对称加密例子 AES（参考这里） 项目中除了登陆，支付等接口采用rsa非对称加密，之外的采用aes对称加密 高级加密标准（英语：Advanced Encryption Standard，缩写：AES） 这个标准用来替代原先的DES DES（参考这里） DES加密算法出自IBM 近些年使用越来越少 DES使用56位密钥，以现代计算能力，24小时内即可被破解。 AES和DES对比 AES安全性、效率、灵活性要高于DES 对称加密优先采用AES 其他加密 MD5 特点：单向加密算法，是不可逆的一种的加密方式 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 加大MD5安全性 进行多次MD5加密 MD5加盐 用string明文的hashcode作为盐，然后进行MD5加密 随机生成一串字符串作为盐，然后进行MD5加密 Base64 平时开发中遇见的各种数据加密方式，最终都会对加密后的二进制数据进行Base64编码，起到一种二次加密的效果 其实呢Base64从严格意义上来说的话不是一种加密算法，而是一种编码算法 更多 所以，在客户端和服务端数据传送加密，最多使用的是非对称RSA和对称AES，参考这里]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android签名]]></title>
    <url>%2F2017%2F07%2F02%2FAndroid%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[签名文件生成与配置 当我们使用Android Studio运行app，一般有两种模式：debug和release模式，如果我们没有配置签名，则会使用默认的签名文件（一般在Mac：/Users/fengan/.android/debug.keystore），一般我们需要自己配置应用的签名文件 创建Keystore配置信息签名V1和V2的区别微信开放平台填写应用签名的获取参考：链接一 链接二]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字的作用]]></title>
    <url>%2F2017%2F03%2F15%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[transient的相关知识整理 transient的相关知识官方解释1Variables may be marked transient to indicate that they are not part of the persistent state of an object. 遇到问题我们都知道一个对象只要实现了Serializable接口，这个对象就可以被序列化，那么在实际开发过程中，可能会遇到这样的问题，这个类的有些属性需要序列号，而其他属性不需要序列化，比如说：一个用户有一些敏感信息，比如密码或者银行卡号之类，为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 解决问题再次之前，有一个姿势点： 父类序列化 一个情景：一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，序列化该子类对象，然后反序列化后，输出父类定义的某变量的数值，该变量数值与序列化前不同 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 特性使用案例 我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化 上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。 参考： java学习—序列化与Transient关键字 Transient关键字使用场景]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS中看不到源码问题解决]]></title>
    <url>%2F2017%2F03%2F13%2FSources-for-%E2%80%98Android-API-xx-Platform%E2%80%99-not-found%2F</url>
    <content type="text"><![CDATA[在Android Studio翻源码多时候，明明下载了对应的SDK，却点进去都是.class看不到源码，本文记录一下解决办法 首先确保下载了对应的SDK 找到以下路径，并打开文件 ~/Library/Preferences/AndroidStudioXXX/options/jdk.table.xml 修改前 修改后 重启AS]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview使用总结]]></title>
    <url>%2F2017%2F03%2F12%2FWebview%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[WebView相关知识整理 WebView使用总结前言： 最近，修改了项目中网页中点击图片跳转查看大图页面的需求，激发了我归纳总结WebView的想法，今天再次整理一下。 包含：使用过程，关键类，js交互，注意事项，以及几个常见的需求解决思路等。 献上一张框架图 基本简介内核在4.4以前的版本是WebKit的内核，4.4以后才换成chromium的内核 可使用第三方WebView组件Crosswalk和TBS服务，具体区别后面再整理 作用 显示和渲染web页面 直接加载Html文件（网络或者本地asserts） 与js互调 状态 webView.onResume() ； 激活WebView为活跃状态，能正常执行网页的响应 webView.onPause()； 当页面被失去焦点被切换到后台不可见状态，需要执行onPause，通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。 webView.pauseTimers() Webview后台耗电的问题 当应用程序(存在webview)被切换到后台时，需要暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。 可以调用此方法 webView.resumeTimers() 恢复pauseTimers状态 注意： 由于pauseTimers和resumeTimers是全局生效的, 并不只影响单个WebView, resumeTimers注意不要遗漏, 否则遗漏的WebView会出现异常. 最好在重写的WebView rootLayout.removeView(webView); webView.destroy(); 销毁Webview，在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview 但是注意：webview调用destory时,webview仍绑定在Activity上 这是由于自定义webview构建时传入了该Activity的context对象 因此需要先从父容器中移除webview,然后再销毁webview: 前进回退网页 Webview.canGoBack() 是否可以后退 Webview.goBack() 后退网页 Webview.canGoForward() 是否可以前进 Webview.goForward() 前进网页 Webview.goBackOrForward(intsteps) 以当前的index为起始点前进或者后退到历史记录中指定的steps 如果steps为负数则为后退，正数则为前进 常见用法： 问题 在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身 目标 点击返回后，是网页回退而不是推出浏览器 解决方案 在当前Activity中处理并消费掉该 Back 事件 1234567public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123; mWebView.goBack(); return true; &#125; return super.onKeyDown(keyCode, event);&#125; 常用类WebSettings12345678910111213141516171819202122232425262728293031//声明WebSettings子类WebSettings webSettings = webView.getSettings();//如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持插件webSettings.setPluginsEnabled(true); //设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小//缩放操作webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件//其他细节操作webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存 webSettings.setAllowFileAccess(true); //设置可以访问文件 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式//优先使用缓存: webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //缓存模式如下： //LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 //LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。 //LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. //LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。 常见缓存用法 123456789101112if (NetStatusUtil.isConnected(getApplicationContext())) &#123; webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//根据cache-control决定是否从网络上取数据。&#125; else &#123; webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//没网，则从本地获取，即离线加载&#125;webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能webSettings.setDatabaseEnabled(true); //开启 database storage API 功能webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;webSettings.setAppCachePath(cacheDirPath); //设置 Application Caches 缓存目录 每个 Application 只调用一次 WebSettings.setAppCachePath()，WebSettings.setAppCacheMaxSize() WebViewClient主要辅助WebView处理各种通知、请求事件12345678910111213141516171819202122232425262728293031323334353637383940new WebViewClient()&#123;// 使得打开网页时不调用系统浏览器， 而是在本WebView中显示 @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; return super.shouldOverrideUrlLoading(view, request); &#125;// 开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。 @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); &#125;// 在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。 @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); &#125;// 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 @Override public void onLoadResource(WebView view, String url) &#123; super.onLoadResource(view, url); &#125;// 该方法传回了错误码，根据错误类型可以进行不同的错误分类处理 @Override public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123; super.onReceivedError(view, request, error); &#125;// webView默认是不处理https请求的，页面显示空白，需要进行如下设置： @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;// super.onReceivedSslError(view, handler, error); handler.proceed(); //表示等待证书响应 // handler.cancel(); //表示挂起连接，为默认方式 // handler.handleMessage(null); //可做其他处理 &#125; &#125;; WebChromClient辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。 获得网页的加载进度并显示 12345678910webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; if (newProgress &lt; 100) &#123; String progress = newProgress + "%"; progress.setText(progress); &#125; else &#123; &#125; &#125;); onReceivedTitle（） 123456webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onReceivedTitle(WebView view, String title) &#123; titleview.setText(title)； &#125; JS交互原文 Android调Js 使用建议 两种方法混合使用，即Android 4.4以下使用方法1，Android 4.4以上方法2 12345678910111213// Android版本变量final int version = Build.VERSION.SDK_INT;// 因为该方法在 Android 4.4 版本才可使用，所以使用时需进行版本判断if (version &lt; 18) &#123; mWebView.loadUrl("javascript:callJS()");&#125; else &#123; mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;);&#125; 通过loadUrl方式调用jsHtml代码 12345678910111213141516171819// 文本名：javascript&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Carson_Ho&lt;/title&gt;// JS代码 &lt;script&gt;// Android需要调用的方法 function callJS()&#123; alert("Android调用了JS的callJS方法"); &#125;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; Android代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 设置与Js交互的权限 webSettings.setJavaScriptEnabled(true); // 设置允许JS弹窗 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); // 先载入JS代码 // 格式规定为:file:///android_asset/文件名.html mWebView.loadUrl("file:///android_asset/javascript.html"); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 必须另开线程进行JS方法调用(否则无法调用) mWebView.post(new Runnable() &#123; @Override public void run() &#123; // 注意调用的JS方法名要对应上 // 调用javascript的callJS()方法 mWebView.loadUrl("javascript:callJS()"); &#125; &#125;); &#125; &#125;); // 由于设置了弹窗检验调用结果,所以需要支持js对话框 // webview只是载体，内容的渲染需要使用webviewChromClient类去实现 // 通过设置WebChromeClient对象处理JavaScript的对话框 //设置响应js 的Alert()函数 mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public boolean onJsAlert(WebView view, String url, String message, final JsResult result) &#123; AlertDialog.Builder b = new AlertDialog.Builder(MainActivity.this); b.setTitle("Alert"); b.setMessage(message); b.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; result.confirm(); &#125; &#125;); b.setCancelable(false); b.create().show(); return true; &#125; &#125;); &#125; 特别注意：JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。 onPageFinished()属于WebViewClient类的方法，主要在页面加载结束时调用 所以一般等onPageFnished回调之后，我们才显示H5的页面，加载未完全的时候，则显示loading页面 通过evaluateJavascript调用js优点 该方法比第一种方法效率更高、使用更简洁。 因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。 Android 4.4 后才可使用 12345678// 只需要将第一种方法的loadUrl()换成下面该方法即可 mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;);&#125; Js调Android 缓存问题原文 参考链接Carson_Ho]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析volatile关键字]]></title>
    <url>%2F2017%2F03%2F07%2F%E6%B5%85%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[在看java并发的书的时候，看到了关于java的单例模式使用了volatile关键字，但是对volatile关键字的真正含义一直很模糊，本文就尝试浅析总结一下volatile的作用和具体用法。 单例模式中的volatile关键字查看原文 123456789101112131415public class TestInstance &#123; private volatile static TestInstance instance; public static TestInstance getInstance() &#123; //1 if (instance == null) &#123; //2 synchronized (TestInstance.class) &#123;//3 if (instance == null) &#123; //4 instance = new TestInstance();//5 &#125; &#125; &#125; return instance;//6 &#125;&#125; 在并发情况下，如果没有volatile关键字，在第5行会出现问题 instance = new TestInstance();//5 可以分解以下三部 1，申请内存 2，通过构造方法初始化对象 3，将对象指向申请的内存 但当A线程进行第五部初始化的时候，可能是因为构造函数里面的操作太多，所以A线程还没有初始化完毕，但已经被赋值了，也就是以上的顺序由1-2-3变成了1-3-2。此时B线程进来判断TestInstance不为null，错以为已经实例化完毕返回了一个未初始化的对象（因为构造函数未完全，初始设置值未完全的对象），就出问题了。如果声明称volatile，2和3步骤不会被排序 volatile的作用与特点通过上诉单例模式中volatile的使用，那么volatile关键字具体的作用到底是什么呢？ 首先看一张图 由上图，需要知道的几点 java内存模型规定了所有的变量都存储在主内存中 Java内存模型分为主内存，和工作内存 主内存是所有的线程所共享的，工作内存是每个线程自己有一个，不是共享的。 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝 线程对变量的所有操作（读取、赋值），都必须在工作内存中进行，而不能直接读写主内存中的变量 不同线程之间也无法直接访问对方工作内存中的变量 基于上诉的主内存和工作内存的描述，那么 volatile的作用： volatile赋予了变量可见——禁止编译器对成员变量进行优化，它修饰的成员变量在每次被线程访问时，都强迫从内存中重读该成员变量的值；而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存，这样在任何时刻两个不同线程总是看到某一成员变量的同一个值，这就是保证了可见性。 ​ 从网上看见了一篇博客可以很好的说明，我将相关部分截了个图如下： 多线程的三个特性相关文章 原子性（Atomicity） 1原子性是指一个原子操作在cpu中不可以暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。原子操作保证了原子性问题。 需要注意的是：i++不是原子操作： x++（包含三个原子操作）a.将变量x 值取出放在寄存器中 b.将将寄存器中的值+1 c.将寄存器中的值赋值给x 1synchronized块之间的操作也具备原子性 可见性(Visibility) 1可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。 有序性(Ordering) 1Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。（比如上述单例模式中对象初始化的顺序对另外一个线程来讲可能会错序） volatile和synchronized的区别和联系相关文章 用法上： synchronized往往作用于方法或代码块 volatile往往修饰变量。 实现机制： synchronized是利用锁实现互斥访问，多线程访问会阻塞 Volatile没有利用锁，而是利用内存共享，强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，多线程访问不回阻塞 区别： syncchronized不仅保证了可见性，还保证了原子性，因为只有获得锁对象的线程才能进入同步代码块，从而保证同步代码块的所有语句全部都能执行。多个线程争抢syncchronized锁对象的时候，会出现阻塞 volatile只保证了可见性，不能保证原子性，不可保证同步，多个线程同时访问不会发生阻塞 ​ volatile关键字的正确使用（一句话概括volatile）一个线程修改某个变量后，其他线程需要知道这个变量修改后的最新的值，此时就需要使用volatile，保证多线程访问的是主内存的值，而不是访问各自线程的工作内存的副本值（其实仍然访问的是副本值，只不过副本值有修改后立即刷新到主内存中）也就是说保证了线程的可见性，但是不能像syncchronized保证原子性，volatile没有利用锁的机制，多线程访问时不会发生阻塞，也就是说volatile修饰的变量可以保证在一个线程中修改的时候，其他线程可以继续访问，一旦该变量修改完毕，其他线程再获取的一定是修改后的最新的值 synchronized同步的死锁是怎么产生的多线程死锁案例： 什么是死锁： 多个线程同时被阻塞,它们中的一个或者全部都在等待某个资源被释放.由于线程被无限期地阻塞,因此程序不能正常运行 多线程相关知识]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全的CopyOnWriteArrayList]]></title>
    <url>%2F2017%2F02%2F16%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84CopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[最近翻阅EventBus源码，在subscribe方法中，看到了CopyOnWriteArrayList这个类，一时竟不知其原理是什么，本文简要记录一下CopyOnWriteArrayList的相关介绍 先看一段EventBus的subscribe（）的代码 这段代码是EventBus中subscribe方法，里面涉及到了subscriptionsByEventType的遍历过程中按照优先级排序 关于EventBus的具体源码我将在后面会整理，这里我们只关注CopyOnWriteArrayList即可 可以看到，在遍历的过程中，调用了subscriptions.add(i,newSubscription)来按照优先级进行排序，我相信任何一个懂java的都知道如果使用普通Arraylist，都会报错（并发修改异常），那么我们下面来证实一下 不使用CopyOnWriteArrayList先写一段代码证明CopyOnWriteArrayList确实是线程安全的。 ReadThread.java 12345678910111213141516import java.util.List;public class ReadThread implements Runnable &#123; private List&lt;Integer&gt; list; public ReadThread(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (Integer ele : list) &#123; System.out.println("ReadThread:"+ele); &#125; &#125;&#125; WriteThread.java 1234567891011121314import java.util.List;public class WriteThread implements Runnable &#123; private List&lt;Integer&gt; list; public WriteThread(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; this.list.add(9); &#125;&#125; TestCopyOnWriteArrayList.java 123456789101112131415161718192021222324252627282930313233import java.util.Arrays;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class TestCopyOnWriteArrayList &#123; private void test() &#123; //1、初始化CopyOnWriteArrayList List&lt;Integer&gt; tempList = Arrays.asList(new Integer [] &#123;1,2&#125;); CopyOnWriteArrayList&lt;Integer&gt; copyList = new CopyOnWriteArrayList&lt;&gt;(tempList); //2、模拟多线程对list进行读和写 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); System.out.println("copyList size:"+copyList.size()); &#125; public static void main(String[] args) &#123; new TestCopyOnWriteArrayList().test(); &#125;&#125; 运行上面的代码，没有报出 java.util.ConcurrentModificationException 说明了CopyOnWriteArrayList并发多线程的环境下，仍然能很好的工作。 CopyOnWriteArrayList如何做到线程安全CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。 当有新元素加入的时候，如下图，创建新数组，并往新数组中加入一个新元素,这个时候，array这个引用仍然是指向原数组的。 当元素在新数组添加成功后，将array这个引用指向新数组。 CopyOnWriteArrayList的源码12345678910111213141516171819public boolean add(E e) &#123; //1、先加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //2、拷贝数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //3、将元素加入到新数组中 newElements[len] = e; //4、将array引用指向到新数组 setArray(newElements); return true; &#125; finally &#123; //5、解锁 lock.unlock(); &#125;&#125; 由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况：1、如果写操作未完成，那么直接读取原数组的数据；2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。 可见，CopyOnWriteArrayList的读操作是可以不用加锁的。 CopyOnWriteArrayList使用场景通过上面的分析，CopyOnWriteArrayList 有几个缺点：1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc 2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求； CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。 思想如上面的分析CopyOnWriteArrayList表达的一些思想：1、读写分离，读和写分开2、最终一致性3、使用另外开辟空间的思路，来解决并发冲突 参考文章： 1]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofit和动态代理]]></title>
    <url>%2F2017%2F02%2F07%2Fretrofit%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理类在运行前不存在，运行时由程序动态生成的代理方式称为动态代理 关于RetrofitSquare公司的OkHttp简直是完美的一个网络请求库，而在其上又封装了一层的Retrofit库，使其调用Restful Api更方便 简述Retrofit调用流程因为本篇只是简述动态代理在Retrofit的使用，所以不过多总结Retrofit的详细使用，在上家公司的项目都网络层，用的retrofit，现在这家公司的项目因为刚开始是我独立开发，所以网络层框架我也是用的Retrofit，功能强大，详细使用，以后再总结 熟悉Retrofit使用的都对下面几个步骤比较熟悉了： 定义一个ApiService接口，通过注解可以标记请求方法，请求参数，以及添加的头信息 然后创建Retrofit对象，通过建造者模式设置BaseUrl等一些参数，通过Retrofit对象create一个你定义的接口对象 拿到接口对象调用具体的方法完成请求 具体的代码大概如下： 1234public interface ApiService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .build();ApiService service = retrofit.create(ApiService.class); 1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("fengan"); ApiService是如何产生的因为接口是不可以直接new出来的，那么ApiService是如何产生的呢？ ApiService service = retrofit.create(ApiService.class);方法内部到底做了什么？ 没错，就是动态代理 为了更好的理解动态代理，下面过一下简易版的Retrofit， a v1234567public interface Callback&lt;T&gt; &#123; void onSuccess(Object t); void onFailed(Exception e);&#125; 123456789 /** * 约定最后一个参数是callback */public interface GithubService &#123; @GET("users/&#123;user&#125;/repos") void list&lt;Repos&gt;(@Path("user") String user,Callback&lt;List&lt;Repo&gt;&gt; callback);&#125; 用到了两个注解，一个是方法注解，一个是参数注解 123456789@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface GET &#123; String value() default "";&#125; 123456789@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.PARAMETER)public @interface Path &#123; String value();&#125; Repo实体类是使用GsonFormat根据json自动生成的。现实使用中，我们在构建Retrofit过程传入GsonFactory Retrofit这个类应该是一个builder模式，里面可以设置baseUrl，姑且忽略其他所有参数。还有一个create方法 1234567891011121314151617181920212223public class Retrofit &#123; private String baseUrl; private Retrofit(Builder builder) &#123; this.baseUrl = builder.baseUrl; &#125; public &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; return null &#125; static class Builder &#123; private String baseUrl; Builder baseUrl(String host) &#123; this.baseUrl = host; return this; &#125; Retrofit build() &#123; return new Retrofit(this); &#125; &#125;&#125; 最关键的就是create这个方法了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; /** * 缓存中去 */ Object o = serviceMap.get(clazz); /** * 取不到则取构造代理对象 */ if (o == null) &#123; o = (T) Proxy.newProxyInstance(Retrofit.class.getClassLoader(), new Class[]&#123;clazz&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; final Callback&lt;?&gt; callback = (Callback&lt;?&gt;) args[args.length - 1]; final GET get = method.getAnnotation(GET.class); if (get != null) &#123; /** * 获得GET注解的值 */ String getValue = get.value(); System.out.println(getValue); /** * 获得所有参数上的注解 */ Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations(); if (methodParameterAnnotationArrays != null) &#123; int count = methodParameterAnnotationArrays.length; for (int i = 0; i &lt; count; i++) &#123; /** * 获得单个参数上的注解 */ Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i]; if (methodParameterAnnotations != null) &#123; for (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123; /** * 如果是Path注解 */ if (methodParameterAnnotation instanceof Path) &#123; /** * 取得path注解上的值 */ Path path = (Path) methodParameterAnnotation; String pathValue = path.value(); System.out.println(pathValue); /** * 这是对应的参数的值 */ System.out.println(args[i]); Request.Builder builder = new Request.Builder(); /** * 使用path注解替换get注解中的值为参数值 */ String result = getValue.replaceAll("\\&#123;" + pathValue + "\\&#125;", (String) args[i]); System.out.println(result); /** * 开始构造请求 */ Request request = builder.get() .url(baseUrl + "/" + result) .build(); okHttpClient.newCall(request).enqueue(new okhttp3.Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; /** * 失败则回调失败的方法 */ callback.onFailed(e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; /** * 请求成功 */ String body = response.body().string(); /** * 使用fastjson进行zhuan转换 */ Type type = callback.getClass().getGenericInterfaces()[0]; Object o1 = JSON.parse(body); /** * 回调成功 */ callback.onSuccess(o1); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; &#125; &#125; return null; &#125; &#125;); /** * 扔到缓存中 */ serviceMap.put(clazz, o); &#125; return (T) o; &#125; 然后我们就可以根据Retrofit那样进行调用了 123456789101112131415Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .build();GithubService githubService = retrofit.create(GithubService.class);githubService.listRepos("lizhangqu", new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onSuccess(Object t) &#123; System.out.println(t); &#125; @Override public void onFailed(Exception e) &#123; &#125;&#125;); retrofit动态代理原理原理就是先拿到最后一个参数，也就是回调，再拿到方法上的注解，获得具体的值，然后拿到除了回调之外的其他参数，获得参数上的注解，然后根据注解取得对应的值，还有原来的参数值，将方法上的注解的值中进行替换。使用OkHttp构造请求，请求完成后根据将结果解析为回调中的类型。整个过程如下 拦截到方法、参数，再根据我们在方法上的注解，去拼接为一个正常的Okhttp请求，然后执行。 java中的动态代理在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法： 12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义： 12345678public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 使用如下： 定义被代理对象 123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println("I want to rent my house"); &#125; @Override public void hello(String str) &#123; System.out.println("hello: " + str); &#125;&#125; 定义动态代理类，任何动态代理类都必须实现InvotionHandler这个接口，重写invoke方法 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println("before rent house"); System.out.println("Method:" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println("after rent house"); return null; &#125;&#125; 使用 123456789101112131415161718192021222324public class Client&#123; public static void main(String[] args) &#123; // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello("world"); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发小结]]></title>
    <url>%2F2017%2F01%2F20%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android开发中，事件分发是非常重要的，了解熟悉整个事件分发过程有助于更好的分析各种点击滑动失效问题,也是一个安卓开发必会的一部分，但是时间长了，对整个流程多少会有些模糊，所以在此记录一下 网上看到一张图，可以很详细的描述整个事件分发的过程 原文的链接 问题一： 当ViewGroup重写的onInterceptTouchEvent，并且始终返回了true，那么子view就永远无法接受到了事件 但是在实际开发中可能会有这种需求，在按下（ACTION_DOWN）的时候，需要子view进行时间反馈，但在滑动（ACTION_MOVE）或者抬起（ACTION_UP）的时候需要父布局进行拦截操作，这个时候可以使用requestDisallInterceptRouchEvent(boolean disallowIntercept)，该方法在子view中调用，getParent().requestDisallInterceptRouchEvent(true)请求父布局禁用拦截事件功能 相关资料 具体例子，在我做的项目中，在viewpager中的每一页fragment中都折线图，viewpager是可以左右切换的，每一页的fragment中的折线图也是可以手势缩放的，所以这就和viewpager滑动有冲突，利用requestDisallInterceptRouchEvent，我们可以自定义折线图控件继承项目中使用的（项目中使用的mpandroid），重写onTouchEvent，当水平滑动的时候，getParent().requestDisallInterceptRouchEvent(true)，请求父布局不拦截事件，交给子view处理。 相关源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.nongfaziran.workiot.view;import android.annotation.SuppressLint;import android.content.Context;import android.graphics.PointF;import android.util.AttributeSet;import android.view.MotionEvent;import com.github.mikephil.charting.charts.LineChart;/** * Created by fengan on 2018/2/3. * email:fengan1102@gmail.com * 解决折线图在viewpager滑动冲突 */public class LineChartInViewPager extends LineChart &#123; PointF downPoint = new PointF(); public LineChartInViewPager(Context context) &#123; super(context); &#125; public LineChartInViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public LineChartInViewPager(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @SuppressLint("ClickableViewAccessibility") @Override public boolean onTouchEvent(MotionEvent evt) &#123; switch (evt.getAction()) &#123; case MotionEvent.ACTION_DOWN: downPoint.x = evt.getX(); downPoint.y = evt.getY(); break; case MotionEvent.ACTION_MOVE: if (getScaleX() &gt; 1 &amp;&amp; Math.abs(evt.getX() - downPoint.x) &gt; 5) &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; &#125; return super.onTouchEvent(evt); &#125;&#125; 未完待续]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈线程池]]></title>
    <url>%2F2016%2F12%2F25%2F%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池有关知识整理 前置知识线程基本概念，线程基本概念和Android启动线程的三种方式(点击查看) new Thread（）的弊端 总是new Thread（）开启线程，线程执行完会被回收，导致频繁的GC 多线程缺乏统一管理，各线程之间互相竞争 无法实现停止线程（如果一个item滑出页面，则要停止该item上图片的加载，但是如果使用这种方式来创建线程，则无法实现线程停止执行） 使用线程池的好处 提高线程的复用性，避免频繁创建线程进而导致频繁的GC 控制线程并发数，合理利用资源 线程可控性，比如可以定时执行和取消执行某个线程的任务 线程池的实现 Android中的线程池其实源于Java，Android开发中线程池的使用和Java中线程池的使用基本一致 Java中和线程有关的东东叫做Executor，Executor本身是一个接口 这个接口有一个非常有用的实现类叫做ThreadPoolExecutor Android中常用的线程池都是通过对ThreadPoolExecutor进行不同配置来实现的 类的继承结构 Windows：Ctrl+H Mac：Control+H 关于ThreadPoolExecutorThreadPoolExecutor有四个重载的构造方法，我们这里来说说参数最多的那一个重载的构造方法，这样大家就知道其他方法参数的含义了 构造函数源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 这里是7个参数(我们在开发中用的更多的是5个参数的构造方法)，OK，那我们来看看这里七个参数的含义： corePoolSize：核心线程的数量 maximumPoolSize：最大线程数量 keepAliveTime：非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长 unit：第三个参数的单位，有纳秒、微秒、毫秒、秒、分、时、天等 workQueue：线程池中的任务队列，该队列存储已经被提交，但是尚未执行的任务，存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。 threadFactory 为线程池提供创建新线程的功能，这个我们一般使用默认即可 handler 拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。 关于workQueue workQueue是一个BlockingQueue类型 BlockingQueue是一个特殊的队列 从BlockingQueue中取数据时， 如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态 当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒 如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态(直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒 BlockingQueue的种类 ArrayBlockingQueue:这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。 LinkedBlockingQueue:这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE PriorityBlockingQueue:这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。 SynchronousQueue:这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。 ThreadPoolExecuto线程池执行任务时：execute一个线程之后： 如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行 如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行 如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务 如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务 如何配置这些参数（参考AsycTask） 核心线程数为手机CPU数量+1（cpu数量获取方式Runtime.getRuntime().availableProcessors()） 最大线程数为手机CPU数量×2+1 线程队列的大小为128 系统帮我们配置好的线程池四种对比 FixedThreadPool 核心线程数量固定的线程池 1ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); 源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程数和最大线程数一样 FixedThreadPool中没有非核心线程，所有的线程都是核心线程 线程的超时时间为0 核心线程即使在没有任务可执行的时候也不会被销毁（这样可让FixedThreadPool更快速的响应请求） LinkedBlockingQueue却没有参数，这说明线程队列的大小为Integer.MAX_VALUE（2的31次方减1) 所有的核心线程都在执行任务的时候，新的任务只能进入线程队列中进行等待，直到有线程被空闲出来 SingleThreadExecutor singleThreadExecutor和FixedThreadPool很像，不同的就是SingleThreadExecutor的核心线程数只有1 ​ 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 最大好处就是可以避免我们去处理线程同步问题 只有一个核心线程，确保所有任务都在同一线程中按顺序完成。因此不需要处理线程同步的问题。 FixedThreadPool的参数传个1效果一样 CachedThreadPool 最大的优势是它可以根据程序的运行情况自动来调整线程池中的线程数量 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool中是没有核心线程的，但是它的最大线程数却为Integer.MAX_VALUE 它是有线程超时机制的，超时时间为60秒 最大线程数为无限大 添加一个新任务进来的时候，如果线程池中有空闲的线程，则由该空闲的线程执行新任务 没有空闲线程，则创建新线程来执行任务 CachedThreadPool中没有新任务的时候，它里边所有的线程都会因为超时而被终止 任务队列SynchronousQueue相当于一个空集合，导致任何任务都会被立即执行 可以在有大量任务请求的时候使用CachedThreadPool ScheduleThreadPool 具有定时定期执行任务功能的线程池 12345public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 核心线程数量是固定的 非核心线程是无穷大,当非核心线程闲置时，则会被立即回收。 支持延迟执行任务；定时执行任务；延迟定时执行任务 线程池的其他功能 shutDown（）：关闭线程池，不影响已经提交的任务 shutDownNow（）：关闭线程池，并尝试终止正在执行的线程 allowCoreThreadTimeOut(boolean value)：允许核心线程闲置超时被回收 submit：一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值 线程池简单封装ThreadPoolManager.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by fengan on 2017/12/25. * email:fengan1102@gmail.com */public class ThreadPoolManager &#123; private static ThreadPoolManager Instance; private final ThreadPoolExecutor threadPoolExecutor; private ThreadPoolManager() &#123;//核心线程数量//最大线程数量//非核心线程的超时时长//时间单位//缓冲队列，用于存放等待任务，Linked的先进先出//创建线程的工厂//用来对超出maximumPoolSize的任务的处理策略 threadPoolExecutor = new ThreadPoolExecutor(corePoolSize,//核心线程数量 maximumPoolSize,//最大线程数量 keepAliveTime,//非核心线程的超时时长 unit,//时间单位 new LinkedBlockingQueue&lt;Runnable&gt;(),//缓冲队列，用于存放等待任务，Linked的先进先出 Executors.defaultThreadFactory(), //创建线程的工厂 new ThreadPoolExecutor.AbortPolicy() //用来对超出maximumPoolSize的任务的处理策略 ); threadPoolExecutor.allowCoreThreadTimeOut(true);//设置核心线程超时时间可用 &#125; public static ThreadPoolManager getInstance() &#123; if (Instance == null) &#123; synchronized (ThreadPoolManager.class) &#123; if (Instance == null) &#123; Instance = new ThreadPoolManager(); &#125; &#125; &#125; return Instance; &#125; //当前设备可用处理器核心数*2 + 1,能够让cpu的效率得到最大程度执行（有研究论证的） private final int corePoolSize = Runtime.getRuntime().availableProcessors() * 2 + 1; //最大线程数等于核心线程数 private final int maximumPoolSize = corePoolSize; //超时时间，1小时 private final long keepAliveTime = 1; private final TimeUnit unit = TimeUnit.HOURS; /** * 执行任务 */ public void execute(Runnable runnable) &#123; if (runnable == null) return; threadPoolExecutor.execute(runnable); &#125; /** * 从线程池中移除任务 */ public void remove(Runnable runnable) &#123; if (runnable == null) return; threadPoolExecutor.remove(runnable); &#125;&#125; 再次比较四种常见的线程池详细比较不管哪种线程池，都是靠ThreadPoolExecutor的七个参数的构造来实现的 核心线程 最大线程 特点 FixThreadPool 有 无（非核心线程） 不会被回收 只有固定数量的核心线程，线程都活动时，新任务等待 SingleThreadPool 1 无（非核心线程） 不会被回收 所有任务都在统一线程执行，不需要处理线程同步问题 CachedThreadPool 无 Integer.MAX_VALUE 超时时间60秒 任何任务立即执行 ScheduledThreadPool 有 Integer.MAX_VALUE 非核心线程闲置，立即回收 可以延迟和定时执行 相关资料： 参考1 参考2 参考3]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask的弊端]]></title>
    <url>%2F2016%2F12%2F20%2FAsyncTask%E7%BC%BA%E9%99%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android开发中，AsyncTask可以替代Handler和Thread来处理后台操作和通知Ui刷新，适用于处理异步数据，并将更新Ui的场景，AsyncTask适用于后台操作只有几秒的短时操作。但是AsyncTask本身存在很多糟糕的问题，如果使用中不注意，将会影响程序的健壮性。 AsyncTask和Handler对比注意：按照Android官方文档支出,AsyncTask被推荐为处理短时间(10秒以内)的操作,即本地的轻量IO操作.不适合使用网络这样时间不定的操作. 共同点都是为了解决耗时操作的问题，主要区别在于一个流程完善，拿来就用（AsyncTask），一个偏向自主定制，扩展性高（Handler+Thread）。 AsyncTask比Handler轻量级，对吗？ 通过看源码，发现AsyncTask实际上就是一个线程池，而网上的说法是AsyncTask比handler要轻量级，显然上不准确的，只能这样说，AsyncTask在代码上比handler要轻量级别，而实际上要比handler更耗资源，因为AsyncTask底层是一个线程池！而Handler仅仅就是发送了一个消息队列，连线程都没有开。 但是，如果异步任务的数据特别庞大，AsyncTask这种线程池结构的优势就体现出来了。 AsyncTask实现的原理,和适用的优缺点 AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程. 使用的优点: l 简单,快捷 l 过程可控 使用的缺点: l 在使用多个异步操作的同时，共同进行Ui变更时,就变得复杂起来. l 最大并发数不超过5 Handler异步实现的原理和适用的优缺点 在Handler 异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程）àthread(子线程)运行并生成Message-àLooper获取Message并传递给HandleràHandler逐个获取Looper中的Message，并进行UI变更。 使用的优点： l 结构清晰，功能定义明确 l 对于多个后台任务时，简单，清晰 使用的缺点： l 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性） AsyncTask的使用： 必选方法： 1， doinbackground(params…) 后台执行，比较耗时的操作都可以放在这里。 注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作 ，通常需要较长的时间。在执行过程中可以调用 Public progress(progress…)来更新任务的进度。 2， onpostexecute(result)相当于handler处理UI的方式，在这里可以使用在 doinbackground得到的结果处理操作UI。此方法在主线程执行，任务执行的结果作为此方法的参数返回。 可选方法： 1， onprogressupdate(progress…) 可以使用进度条增加用户体验度。此方法在主线程执行，用户显示任务执行的进度。 2， onpreExecute() 这里是最新用户调用excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。 3， onCancelled() 用户调用取消时，要做的操作 AsyncTask三个状态： pending,running,finished 使用AsyncTask类，遵守的准则： 1， Task的实例必须在UI thread中创建； 2， Execute方法必须在UI thread中调用 3， 不要手动的调用onPfreexecute()，onPostExecute(result) Doinbackground(params…),onProgressupdate(progress…)这几个方法； 4， 该task只能被执行一次，否则多次调用时将会出现异常; AsyncTask缺陷总结： 生命周期 很多开发者会认为在一个Activity中创建的AsyncTask会随着Activity销毁而销毁，事实并非如此，AsyncTask会随着doInBackground（）方法执行完毕才销毁，然后，cancel（）被调用，那么onCancel会执行；否则执行postExecute方法会执行。如果在AsyncTask没有执行完毕，就销毁了Activity，AsyncTask可能会崩溃，因为它想要处理的view已经不存在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确地取消。 另外，即使我们正确地调用了cancle() 也未必能真正地取消任务。因为如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，那么这个操作会继续下去。 内存泄漏 如果AsyncTask未声明成静态，则会持有外部类Activity的引用，当Activity销毁之后，AsyncTask还在执行，它将在内存中依旧保持这个引用，会造成内存泄漏 结果丢失 当屏幕旋转Activity销毁重新创建（未配置android:configChanges=”orientation|screenSize”的情况）之前运行的AsyncTask会持有之前Activity的引用，这时调用onPostExecute()再去更新界面将不再生效。 并行还是串行 当想要串行执行时，直接执行execute()方法，如果需要并行执行，则要执行executeOnExecutor(Executor)。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2016%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型设计模式的是一种创建型的设计模式，如果创建过程笔记复杂耗时的话，可以考虑使用原型设计模式；通过克隆已有的对象来获取一个新的对象，你可以直接使用它，也可以修改克隆对象的部分属性再使用，使得我们的程序更加高效 使用场景 如果一个类的初始化需要很多资源，这个资源包括数据或者硬件资源等，通过原型拷贝已有的对象来避免这些消耗 通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 如何实现首先我们得实现Cloneable接口，复写clone方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.it.fengan.designpattern.pattern;/** * Created by fengan on 2017/12/22. * email:fengan1102@gmail.com */public class Worker implements Cloneable &#123; private String name; private String des; private double money; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDes() &#123; return des; &#125; public void setDes(String des) &#123; this.des = des; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Worker&#123;" + "name='" + name + '\'' + ", des='" + des + '\'' + ", money=" + money + '&#125;'; &#125; @Override public Worker clone() &#123; Worker worker = null; try &#123; worker = (Worker) super.clone(); worker.money = this.money; worker.name = this.name; worker.des = this.des; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return worker; &#125;&#125; 注意 clone这个方法不是Cloneable接口中的（Cloneable是一个空接口） clone是Object中的方法 Cloneable是一个标识接口，它表明这个类的对象是可以拷贝的 如果没有实现Cloneable接口却调用了clone()函数将抛出异常。 浅拷贝和深拷贝浅拷贝 12345678910@Override protected User clone() &#123; User user = null; try&#123; user = (User)super.clone(); &#125; catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return user; &#125; 那么在实现clone方法的时候，需要注意个问题，像上面那样，直接调用 1user = (User)super.clone(); 这样只是简单的拷贝了对象，实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段。 深拷贝 123456789101112@Override public WordDocument clone() &#123; try &#123; WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText; doc.mImages = (ArrayList&lt;String&gt;) this.mImages.clone(); return doc; &#125; catch (CloneNotSupportedException e) &#123; &#125; return null; &#125; Android中的应用Intenet源码 123456789101112131415161718192021222324252627282930313233343536373839* * &lt;p&gt;These are the possible flags that can be used in the Intent via * &#123;@link #setFlags&#125; and &#123;@link #addFlags&#125;. See &#123;@link #setFlags&#125; for a list * of all possible flags. */public class Intent implements Parcelable, Cloneable &#123; ... @Override public Object clone() &#123; return new Intent(this); &#125; public Intent(Intent o) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;String&gt;(o.mCategories); &#125; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; ...&#125; 可以见到，我们的Intent是深度拷贝，而且是直接new一个的深度拷贝。可见其设计初衷不是因为其不是为了解决构建复杂对象的资源消耗问题。 总结 原型模式本质上就是对象拷贝，与 C++ 中的拷贝构造函数有些类似，它们之间容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要的途径就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通常可以通过返回一个对象拷贝的形式实现只读的限制。 优点：原型模式是在内存中二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点。 缺点：这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发中应该注意这个潜在问题]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2016%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都能得到通知并可以自动作出处理 比如说：报纸的订阅，一旦订阅，当有新的报纸发布，所有的订阅者都会收到消息 基本概念组成 观察者：Observer，也叫订阅者，即Subscriber（Rxjava） 被观察者：Observable java中的体现java中提供了Observable和Observe接口供我们快速实现这种模式 代码实现 假如有下面这样的一个实体类 12345678910111213141516171819202122public class Weather &#123; private String description; public Weather(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; @Override public String toString() &#123; return "Weather&#123;" + "description='" + description + '\'' + '&#125;'; &#125;&#125; 定义观察者接口（因为观察者可能有很多类型，所以我们定义成一个接口，如果想要订阅这个事件，实现这个接口即可，另外一般订阅之后，在实现接口中的方法的参数中会拿到发布的数据，数据的类型不固定所以这个观察者接口需要定义范型） 123public interface Observer&lt;T&gt; &#123; void onUpdate(Observable&lt;T&gt; observable,T data);&#125; 定义被观察者对象（可以设计成单例模式，类似EventBus，内部维持一个集合，用来保存观察者对象；register方法和unregister方法用来将观察者对象从集合中添加和移除出来，post方法用来发布，循环遍历集合，依次调用观察者的相关回调方法，并将发布的参数传入） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.it.fengan.designpattern.pattern;import java.util.ArrayList;import java.util.List;/** * Created by fengan on 2017/12/12. * email:fengan1102@gmail.com */public class Observable&lt;T&gt; &#123; private static Observable observable; private Observable() &#123; &#125; public static Observable getInstance() &#123; if (observable == null) &#123; synchronized (Observable.class) &#123; if (observable == null) &#123; observable = new Observable(); &#125; &#125; &#125; return observable; &#125; private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); public void register(Observer&lt;T&gt; observer) &#123; if (observer == null) &#123; throw new RuntimeException("observer error"); &#125; synchronized (Observable.class) &#123; if (!observers.contains(observer)) &#123; observers.add(observer); &#125; &#125; &#125; public void unregister(Observer&lt;T&gt; observer) &#123; observers.remove(observer); &#125; public void post(T data) &#123; for (Observer observer : observers) &#123; observer.onUpdate(this, data); &#125; &#125;&#125; 注册和反注册过程 1234567891011121314151617181920212223@Test public void testObserver() &#123; Observer&lt;Weather&gt; objectObserver1 = new Observer&lt;Weather&gt;()&#123; @Override public void onUpdate(Observable&lt;Weather&gt; observable, Weather data) &#123; Log.e("testObserver", "objectObserver1:data=" + data.toString()); &#125; &#125;; Observer&lt;Weather&gt; objectObserver2 = new Observer&lt;Weather&gt;()&#123; @Override public void onUpdate(Observable&lt;Weather&gt; observable, Weather data) &#123; Log.e("testObserver", "objectObserver2:data=" + data.toString()); &#125; &#125;; Observable observable = Observable.getInstance(); observable.register(objectObserver1); observable.register(objectObserver2); Weather weather = new Weather("晴天"); observable.post(weather); observable.unregister(objectObserver2); observable.post(weather); &#125; logcat输出 12312-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver1:data=Weather&#123;description='晴天'&#125;12-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver2:data=Weather&#123;description='晴天'&#125;12-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver1:data=Weather&#123;description='晴天'&#125; Android中的应用 一对一的观察者（一般称之为回调，只有一个观察者） 1234567Button btn=new Button(this);btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.e("TAG","click"); &#125;&#125;); 只要是set系列的设置监听器的方法最多都只能算回调，但是有一些监听器式add进去的，这种就是观察者模式了（比如RecyclerView中的addOnScrollListener方法） RecycleView.java 123456789101112131415161718192021222324252627282930313233343536373839private List&lt;OnScrollListener&gt; mScrollListeners;/** * Add a listener that will be notified of any changes in scroll state or position. * * &lt;p&gt;Components that add a listener should take care to remove it when finished. * Other components that take ownership of a view may call &#123;@link #clearOnScrollListeners()&#125; * to remove all attached listeners.&lt;/p&gt; * * @param listener listener to set or null to clear */public void addOnScrollListener(OnScrollListener listener) &#123; if (mScrollListeners == null) &#123; mScrollListeners = new ArrayList&lt;&gt;(); &#125; mScrollListeners.add(listener);&#125;/** * Remove a listener that was notified of any changes in scroll state or position. * * @param listener listener to set or null to clear */public void removeOnScrollListener(OnScrollListener listener) &#123; if (mScrollListeners != null) &#123; mScrollListeners.remove(listener); &#125;&#125;/** * Remove all secondary listener that were notified of any changes in scroll state or position. */public void clearOnScrollListeners() &#123; if (mScrollListeners != null) &#123; mScrollListeners.clear(); &#125;&#125; Android的广播机制，其本质也是观察者模式，这里为了简单方便，直接拿本地广播的代码说明，即LocalBroadcastManager 1234LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter);localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver);localBroadcastManager.sendBroadcast(Intent intent) 开源库（EventBus） 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件 1234EventBus.getDefault().register(Object subscriber);EventBus.getDefault().unregister(Object subscriber);EventBus.getDefault().post(Object event); 重量级的库，它就是RxJava 创建一个被观察者 123456789Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext("Hello, world!"); sub.onCompleted(); &#125; &#125; ); 创建一个观察者，也就是订阅者 12345678910Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;; 观察者进行事件的订阅 1myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2016%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式属于对象的行为模式，其用意是针对一组算法，将每一个算法封装到具有公共接口的独立的类中，从而在不影响客户端的情况下可以切换相应的算法。 未使用策略模式案例12345678910111213141516171819202122232425262728293031323334public class TravelStrategy &#123; enum Strategy&#123; WALK,PLANE,SUBWAY &#125; private Strategy strategy; public TravelStrategy(Strategy strategy)&#123; this.strategy=strategy; &#125; public void travel()&#123; if(strategy==Strategy.WALK)&#123; print("walk"); &#125;else if(strategy==Strategy.PLANE)&#123; print("plane"); &#125;else if(strategy==Strategy.SUBWAY)&#123; print("subway"); &#125; &#125; public void print(String str)&#123; System.out.println("出行旅游的方式为："+str); &#125; public static void main(String[] args) &#123; TravelStrategy walk=new TravelStrategy(Strategy.WALK); walk.travel(); TravelStrategy plane=new TravelStrategy(Strategy.PLANE); plane.travel(); TravelStrategy subway=new TravelStrategy(Strategy.SUBWAY); subway.travel(); &#125;&#125; 通过switch或者if语句，来判断选择哪一种策略算法，一旦策略增加或者减少修改，就不得不增加新的语句，这就违背了面向对象的原则之一，对修改封闭。 使用策略模式案例定义策略接口（抽象策略） 123public interface Strategy &#123; void travel();&#125; 将不同的算法封装到实现该策略接口的具体的类中（具体策略） 12345678public class WalkStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("walk"); &#125;&#125; 12345678public class PlaneStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("plane"); &#125;&#125; 12345678public class SubwayStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("subway"); &#125;&#125; 策略环境（持有抽象策略引用的环境类） 1234567891011121314151617public class TravelContext &#123; Strategy strategy; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void travel() &#123; if (strategy != null) &#123; strategy.travel(); &#125; &#125;&#125; 具体使用 1234567891011public class Main &#123; public static void main(String[] args) &#123; TravelContext travelContext=new TravelContext(); travelContext.setStrategy(new PlaneStrategy()); travelContext.travel(); travelContext.setStrategy(new WalkStrategy()); travelContext.travel(); travelContext.setStrategy(new SubwayStrategy()); travelContext.travel(); &#125;&#125; 若想增加新的策略（添加新的策略实现类即可） 12345678public class BikeStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("bike"); &#125;&#125; 123TravelContext travelContext=new TravelContext(); travelContext.setStrategy(new BikeStrategy()); travelContext.travel(); 总结 面向对象的对修改封闭，对扩展开放。 Android源码中的使用 属性动画的插值器 策略接口 12345public interface TypeEvaluator&lt;T&gt; &#123; public T evaluate(float fraction, T startValue, T endValue);&#125; 多个策略实现例如 1234567public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 1234567public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; &#123; public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125;&#125; 其他略… 其他使用场景举例例如：一个电商类平台等购物车系统，除了把货品的单价乘以数量之外，可能会有一些优惠活动。比如说，对高级会员提供5折优惠，对中级会员提供7折优惠，对初级会员提供9折优惠 那么这就涉及到了三种算法 首先定义折扣抽样策略接口 12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 初级会员折扣策略 12345678910public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的9折折扣"); return booksPrice*0.9; &#125;&#125; 123456789public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于高级会员的折扣为5折"); return booksPrice * 0.5; &#125;&#125; 12345678910public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为7折"); return booksPrice * 0.7; &#125;&#125; 策略环境类 1234567891011121314151617181920public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; 客户端的使用 12345678910111213public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote); &#125;&#125; 可以看出 策略模式的重心不是提供算法，而是对多种算法的封装 各个算法相对独立平等 算法可以相互切换，但在同一时刻只能使用一种策略 面向对象的：对修改封闭，对拓展开放 避免使用switch和if多重条件语句，方便维护 缺点：客户端事先知道有多少种策略，并且每个策略的区别]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式，将一个复杂对象的构建与它的表示分离，使得构建过程可以以分部进行的链式调用来完成 若不用Build模式定义一个Person类1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; private String name; private int age; private double height; private double weight; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getHeight() &#123; return height; &#125; public void setHeight(double height) &#123; this.height = height; &#125; public double getWeight() &#123; return weight; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125;&#125; 可能会定义一个构造方法。123456public Person(String name, int age, double height, double weight) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight;&#125; 对应不同的需求，可能会定义好几种构造方法1234567891011121314public Person(String name) &#123; this.name = name;&#125;public Person(String name, int age) &#123; this.name = name; this.age = age;&#125;public Person(String name, int age, double height) &#123; this.name = name; this.age = age; this.height = height;&#125; 使用的时候就变成这样了12345Person p1=new Person();Person p2=new Person("张三");Person p3=new Person("李四",18);Person p4=new Person("王五",21,180);Person p5=new Person("赵六",17,170,65.4); 这样的坏处： 构造函数有多个参数，不好确定每个参数具体意思，可读性不强 若参数较多的时候，麻烦 若使用Builder模式具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Person &#123; private String name; private int age; private double height; private double weight; privatePerson(Builder builder) &#123; this.name=builder.name; this.age=builder.age; this.height=builder.height; this.weight=builder.weight; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getHeight() &#123; return height; &#125; public void setHeight(double height) &#123; this.height = height; &#125; public double getWeight() &#123; return weight; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125; static class Builder&#123; private String name; private int age; private double height; private double weight; public Builder name(String name)&#123; this.name=name; return this; &#125; public Builder age(int age)&#123; this.age=age; return this; &#125; public Builder height(double height)&#123; this.height=height; return this; &#125; public Builder weight(double weight)&#123; this.weight=weight; return this; &#125; public Person build()&#123; return new Person(this); &#125; &#125;&#125; 大概流程 定义静态Builder类 Builder类中声明和外部类一样的变量 定义多个set方法，返回结果为Builder本身（this） Builder类中增加build（）方法，返回外部类Person对象 外部类Person中声明一个参数为Builder的构造函数 使用1234567Person.Builder builder=new Person.Builder();Person person=builder .name("张三") .age(18) .height(178.5) .weight(67.4) .build(); Android中哪些地方使用到Builder模式对话框的创建，AlertDialog123456789101112131415161718AlertDialog.Builder builder=new AlertDialog.Builder(this);AlertDialog dialog=builder.setTitle("标题") .setIcon(android.R.drawable.ic_dialog_alert) .setView(R.layout.myview) .setPositiveButton(R.string.positive, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .setNegativeButton(R.string.negative, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .create();dialog.show();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android中单例模式整理记录 什么是单例模式 使用时，单例模式的对象只有一个实例存在，不允许自由的构造对象 单例模式使用场景 确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例 … … 如何使用单例 私有构造函数，禁止外部使用构造函数创建对象 通过一个静态方法或者枚举来提供返回单例实例 确保单例类的对象在反序列化的时候不会重新构建对象 确保在多线程下，也只有一个实例 单例模式分类 1,饿汉式1234567891011public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; private Singleton getInstance() &#123; return instance; &#125; &#125; 2,懒汉式12345678910111213public class Singleton &#123; private static Singleton instance ; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饿汉式和懒汉式的区别 饿汉式：在声明静态对象的时候就初始化 懒汉式：声明一个静态变量，并且在用户第一次调用getInstance的时候进行初始化 ​ 优点：单例在使用的时候才会初始化，一定程度上节约了资源 ​ 缺点：第一次加载的时候会初始化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成了不必要的同步开销，一般不介意这么用。 3,Double check lock（DCL）123456789101112131415public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; DCL : 介绍DCL 在getInstance 方法中 对instance 进行两次判空：相信很多人对此都有些疑惑。为什么要判断两次，第一个判空是为了避免不必要的同步，第二层判断是为了在null 情况下创建实例。instance=new Singleton(); 语句看起来是有代码，单实际是一个原子操作，最终会被编译成多条汇编指令，大致做了三件事： 1.给Singleton 分配内存 2.调用Singleton 的构造函数，初始化成员字段 3.将instance 对象指向分配的内存空间（此时instance 就不是null 了）但是jdk 1.5 以后java 编译器允许乱序执行 。所以执行顺序可能是1-3-2 或者 1-2-3.如果是前者先执行3 的话 切换到其他线程，instance 此时 已经是非空了，此线程就会直接取走instance ，直接使用，这样就回出错。DCL 失效。解决方法 SUN 官方已经给我们了。将instance 定义成 privatevolatilestatic Singleton instance =null: 即可DCL 的优点，资源利用率高，第一次执行getInstance 时才会被实例化，效率高。缺点：第一次加载反应慢，也由于java 内存 模型的原因偶尔会失败，在高并发环境下，有一定缺陷，虽然发生概率很小。(很常用) 4.静态内部类单例模式12345678910111213public class Singleton &#123; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 加载singleton 类时不会初始化instance 只有在调用getInstance 方法时，才会导致instance 被初始化,这个方法不仅能够确保线程安全，也能够保证 单例对象的唯一性,同时也延迟了单例的实例化，是推荐使用的单例模式实现方式。 5，防止反序列化过程中创建多个对象加入下列方法 123protected Singleton readResolve() throws ObjectStreamException &#123; return SingletonHolder.instance;&#125; 而当实现了readResolve方法后，jvm就会有readResolve返回指定对象，也就保证了单例性。实验证明，如果没有声明readResolve方法，存入对象的hashcode和取出对象的hashcode不一致。 推荐下列方式（如果需要序列化的话）： 1234567891011121314151617public class Singleton implements Serializable &#123; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static volatile final Singleton instance = new Singleton(); &#125; protected Singleton readResolve() throws ObjectStreamException &#123; return SingletonHolder.instance; &#125;&#125; 6,volatile关键字的使用当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 volatile 性能： volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 7,Android源码或者框架使用 ImageLoader EventBus InputMethodManager AccessibilityManager ActivityManager(自定义关闭所有Activity的工具类)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随滑动改变的的动态矩形背景]]></title>
    <url>%2F2016%2F10%2F11%2F%E9%9A%8F%E6%BB%91%E5%8A%A8%E6%94%B9%E5%8F%98%E7%9A%84%E7%9A%84%E5%8A%A8%E6%80%81%E7%9F%A9%E5%BD%A2%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[可能看到这个标题有点懵逼,本屌的表达能力有限,最近工作比较清闲,朋友公司正在做到这个效果,所以就帮基友写了一个小Demo. github移步:https://github.com/itfengan/DynamicRectangleView 朋友公司需要达到的效果 Demo中的效果 使用过程layout&lt;com.fengan.dynamicrectangledemo.DynamicRectangleView android:id=&quot;@+id/drv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot; app:fengan_limit_percent=&quot;0.2&quot; app:fengan_percent=&quot;0.5&quot; &gt;&lt;/com.fengan.dynamicrectangledemo.DynamicRectangleView&gt; code @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SeekBar seekBar = (SeekBar) findViewById(R.id.sb); final DynamicRectangleView dynamicRectangleView = (DynamicRectangleView) findViewById(R.id.drv); seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) { dynamicRectangleView.setPercent((float)i/100); } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); findViewById(R.id.btn_scrollview).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startActivity(new Intent(MainActivity.this,ScrollViewActivity.class)); } }); } attrs.xml(有灵性的哥哥们应该猜得到分别对应的什么意思咯) &lt;resources&gt; &lt;declare-styleable name=&quot;DynamicRectangleView&quot;&gt; &lt;attr name=&quot;fengan_percent&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;fengan_limit_percent&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;fengan_start_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;fengan_end_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; fengan_percent:右侧短边占左侧的百分比 fengan_limit_percent:当滑动到最小的百分比 fengan_start_color:渐变色的初始颜色(ps:朋友公司效果图是渐变色,当然也可以不需要) fengan_end_color:渐变色的终止颜色 DynamicRectangleView.java package com.fengan.dynamicrectangledemo; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.LinearGradient; import android.graphics.Paint; import android.graphics.Path; import android.graphics.Shader; import android.util.AttributeSet; import android.util.Log; import android.view.View; /** * Created by fengan on 2017/10/11/011. */ public class DynamicRectangleView extends View { // Default values private final static int DEFAULT_START_COLOR = Color.parseColor(&quot;#88D94600&quot;); private final static int DEFAULT_END_COLOR = Color.parseColor(&quot;#D94600&quot;); private final static float DEFAULT_PERCENT = (float) 0.5;//右边高度占左边高度的百分比 private final static float DEFAULT_LIMIT_PERCENT = (float) 0.2;//最小高度占左边高度的百分比 private Paint mPaint; private float OriginalRightHeight; private float OriginalLeftHeight; private float currentRightHeight; private float currentLeftHeight; private float minHeight; private float maxHeight; private int mStartColor; private int mEndColor; private float mPercent; private float mLimitPercent; private Path mPath; public DynamicRectangleView(Context context) { this(context, null); } public DynamicRectangleView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public DynamicRectangleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); // Retrieve attributes from xml final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DynamicRectangleView); try { mPercent = typedArray.getFloat(R.styleable.DynamicRectangleView_fengan_percent, DEFAULT_PERCENT); mLimitPercent = typedArray.getFloat(R.styleable.DynamicRectangleView_fengan_percent, DEFAULT_LIMIT_PERCENT); mStartColor = typedArray.getColor(R.styleable.DynamicRectangleView_fengan_start_color, DEFAULT_START_COLOR); mEndColor = typedArray.getColor(R.styleable.DynamicRectangleView_fengan_end_color, DEFAULT_END_COLOR); } finally { typedArray.recycle(); } initView(context); } private void initView(Context context) { mPaint = new Paint(); mPath = new Path(); mPaint.setAntiAlias(true); // mPaint.setColor(Color.RED);//纯色 } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); OriginalLeftHeight = getMeasuredHeight(); OriginalRightHeight = getMeasuredHeight()*mPercent; minHeight = getMeasuredHeight() *mLimitPercent; maxHeight = OriginalRightHeight; //设置当前高度 currentRightHeight = OriginalRightHeight; currentLeftHeight = OriginalLeftHeight; // LinearGradient 第一个参数第二个参数为 起始位置x,y 三四参数为终点位置x,y。 // 如果x不变则为y轴渐变， y不变则为x轴渐变 // 第五个参数为颜色渐变，此处为红色渐变为绿色 // 第七个参数为渐变次数，可repeat Shader mShader = new LinearGradient(0, 0, maxHeight, maxHeight, new int[]{mStartColor, mEndColor}, null, Shader.TileMode.CLAMP); // Shader.TileMode三种模式 // REPEAT:沿着渐变方向循环重复 // CLAMP:如果在预先定义的范围外画的话，就重复边界的颜色 // MIRROR:与REPEAT一样都是循环重复，但这个会对称重复 mPaint.setShader(mShader);// 用Shader中定义定义的颜色来话 } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); mPath.reset(); mPath.moveTo(0, 0); mPath.lineTo(getMeasuredWidth(), 0); mPath.lineTo(getMeasuredWidth(), currentRightHeight); mPath.lineTo(0, currentLeftHeight); mPath.close(); canvas.drawPath(mPath, mPaint); } public void setPercent(float percent) { Log.e(&quot;fengan&quot;, &quot;percent=&quot; + percent); currentRightHeight = OriginalRightHeight * (1 - percent); currentLeftHeight = OriginalLeftHeight * (1 - percent); if (currentLeftHeight &lt; minHeight) { currentLeftHeight = minHeight; } if (currentRightHeight &lt; minHeight) { currentRightHeight = minHeight; } postInvalidate(); } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson封装]]></title>
    <url>%2F2016%2F08%2F21%2FGson%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Gson封装 Gson封装的工具类 javabean和集合相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 /** * Created by fengan on 2017/7/6/006. */ import com.google.gson.Gson; import com.google.gson.JsonArray; import com.google.gson.JsonElement; import com.google.gson.JsonParser; import com.google.gson.reflect.TypeToken; import java.util.ArrayList; import java.util.List; import java.util.Map; public class GsonUtil &#123; private static Gson gson = null; static &#123; if (gson == null) &#123; gson = new Gson(); &#125; &#125; private GsonUtil() &#123; &#125; /** * 转成json * * @param object * @return */ public static String GsonString(Object object) &#123; String gsonString = null; if (gson != null) &#123; gsonString = gson.toJson(object); &#125; return gsonString; &#125; /** * 转成bean * * @param gsonString * @param cls * @return */ public static &lt;T&gt; T GsonToBean(String gsonString, Class&lt;T&gt; cls) &#123; T t = null; if (gson != null) &#123; t = gson.fromJson(gsonString, cls); &#125; return t; &#125; /** * 转成list * 泛型在编译期类型被擦除导致报错 * * @param gsonString * @param cls * @return */ public static &lt;T&gt; List&lt;T&gt; GsonToList(String gsonString, Class&lt;T&gt; cls) &#123; List&lt;T&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;T&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成list * 解决泛型问题 * * @param json * @param cls * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;T&gt; jsonToList(String json, Class&lt;T&gt; cls) &#123; Gson gson = new Gson(); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); JsonArray array = new JsonParser().parse(json).getAsJsonArray(); for (final JsonElement elem : array) &#123; list.add(gson.fromJson(elem, cls)); &#125; return list; &#125; /** * 转成list中有map的 * * @param gsonString * @return */ public static &lt;T&gt; List&lt;Map&lt;String, T&gt;&gt; GsonToListMaps(String gsonString) &#123; List&lt;Map&lt;String, T&gt;&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;Map&lt;String, T&gt;&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成map的 * * @param gsonString * @return */ public static &lt;T&gt; Map&lt;String, T&gt; GsonToMaps(String gsonString) &#123; Map&lt;String, T&gt; map = null; if (gson != null) &#123; map = gson.fromJson(gsonString, new TypeToken&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;.getType()); &#125; return map; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view被软键盘挡住和点击外部软键盘消失]]></title>
    <url>%2F2016%2F08%2F21%2Fview%E8%A2%AB%E8%BD%AF%E9%94%AE%E7%9B%98%E6%8C%A1%E4%BD%8F%E5%92%8C%E7%82%B9%E5%87%BB%E5%A4%96%E9%83%A8%E8%BD%AF%E9%94%AE%E7%9B%98%E6%B6%88%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[软键盘遮挡和点击空白区域关闭键盘 需求 登陆button挡住输入框 软键盘弹出挡住其他控件 软键盘弹出，点击空白区域关闭软件盘 点击button，键盘将button顶上去 // 控制是否移动布局。比如只有密码输入框获取到焦点时才执行。 public boolean flag = true; /** * @param act activiry用于获取底部导航栏高度。 * @param root 最外层布局，需要调整的布局 * @param scrollToView 被键盘遮挡的scrollToView，滚动root,使scrollToView在root可视区域的底部 */ public void controlKeyboardLayout(Context act, final View root, final View scrollToView) { final int navigationBarHeight = getNavigationBarHeight(act); root.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Rect rect = new Rect(); //获取root在窗体的可视区域 root.getWindowVisibleDisplayFrame(rect); //获取root在窗体的不可视区域高度(被其他View遮挡的区域高度) int rootInvisibleHeight = root.getRootView().getHeight() - rect.bottom; //若不可视区域高度大于100，则键盘显示 if (rootInvisibleHeight &gt; navigationBarHeight &amp;&amp; flag) { int[] location = new int[2]; //获取scrollToView在窗体的坐标 scrollToView.getLocationInWindow(location); //计算root滚动高度，使scrollToView在可见区域 int srollHeight = (location[1] + scrollToView.getHeight()) - rect.bottom; if (root.getScrollY() != 0) {// 如果已经滚动，要根据上次滚动，重新计算位置。 srollHeight += root.getScrollY(); } root.scrollTo(0, srollHeight); } else { //键盘隐藏 root.scrollTo(0, 0); } } }); } 解决控制点击可选择的区域让软键盘消失或者不消失 /** * 获取底部导航栏高度 * * @param act * @return */ private int getNavigationBarHeight(Context act) { Resources resources = act.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); int height = resources.getDimensionPixelSize(resourceId); Log.v(&quot;dbw&quot;, &quot;Navi height:&quot; + height); return height; } //软键盘消失的管理 //region软键盘的处理 /** * 清除editText的焦点 * * @param v 焦点所在View * @param ids 输入框 */ public void clearViewFocus(View v, int... ids) { if (null != v &amp;&amp; null != ids &amp;&amp; ids.length &gt; 0) { for (int id : ids) { if (v.getId() == id) { v.clearFocus(); break; } } } } /** * 隐藏键盘 * * @param v 焦点所在View * @param ids 输入框 * @return true代表焦点在edit上 */ public boolean isFocusEditText(View v, int... ids) { if (v instanceof EditText) { EditText tmp_et = (EditText) v; for (int id : ids) { if (tmp_et.getId() == id) { return true; } } } return false; } //是否触摸在指定view上面,对某个控件过滤 public boolean isTouchView(View[] views, MotionEvent ev) { if (views == null || views.length == 0) return false; int[] location = new int[2]; for (View view : views) { view.getLocationOnScreen(location); int x = location[0]; int y = location[1]; if (ev.getX() &gt; x &amp;&amp; ev.getX() &lt; (x + view.getWidth()) &amp;&amp; ev.getY() &gt; y &amp;&amp; ev.getY() &lt; (y + view.getHeight())) { return true; } } return false; } //region 右滑返回上级 @Override public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { if (isTouchView(filterViewByIds(), ev)) return super.dispatchTouchEvent(ev); if (hideSoftByEditViewIds() == null || hideSoftByEditViewIds().length == 0) return super.dispatchTouchEvent(ev); View v = getCurrentFocus(); if (isFocusEditText(v, hideSoftByEditViewIds())) { //隐藏键盘 hideInputForce(this); clearViewFocus(v, hideSoftByEditViewIds()); } } return super.dispatchTouchEvent(ev); } /** * 传入EditText的Id * 没有传入的EditText不做处理 * * @return id 数组 */ public int[] hideSoftByEditViewIds() { return null; } /** * 传入要过滤的View * 过滤之后点击将不会有隐藏软键盘的操作 * * @return id 数组 */ public View[] filterViewByIds() { return null; } /** * des:隐藏软键盘,这种方式参数为activity * * @param activity */ public static void hideInputForce(Activity activity) { if (activity == null || activity.getCurrentFocus() == null) return; ((InputMethodManager) activity.getSystemService(INPUT_METHOD_SERVICE)) .hideSoftInputFromWindow(activity.getCurrentFocus() .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } 以下Demo全部代码1234567891011121314public class MainActivity extends AppCompatActivity &#123;private EditText mEt1;private EditText mEt2;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = (Button) findViewById(R.id.btn); mEt1 = (EditText) findViewById(R.id.et1); mEt2 = (EditText) findViewById(R.id.et2); LinearLayout LL = (LinearLayout) findViewById(R.id.LL); controlKeyboardLayout(this,LL,btn);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// 控制是否移动布局。比如只有密码输入框获取到焦点时才执行。public boolean flag = true;/** * @param act activiry用于获取底部导航栏高度。 * @param root 最外层布局，需要调整的布局 * @param scrollToView 被键盘遮挡的scrollToView，滚动root,使scrollToView在root可视区域的底部 */public void controlKeyboardLayout(Context act, final View root, final View scrollToView) &#123; final int navigationBarHeight = getNavigationBarHeight(act); root.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect = new Rect(); //获取root在窗体的可视区域 root.getWindowVisibleDisplayFrame(rect); //获取root在窗体的不可视区域高度(被其他View遮挡的区域高度) int rootInvisibleHeight = root.getRootView().getHeight() - rect.bottom; //若不可视区域高度大于100，则键盘显示 if (rootInvisibleHeight &gt; navigationBarHeight &amp;&amp; flag) &#123; int[] location = new int[2]; //获取scrollToView在窗体的坐标 scrollToView.getLocationInWindow(location); //计算root滚动高度，使scrollToView在可见区域 int srollHeight = (location[1] + scrollToView.getHeight()) - rect.bottom; if (root.getScrollY() != 0) &#123;// 如果已经滚动，要根据上次滚动，重新计算位置。 srollHeight += root.getScrollY(); &#125; root.scrollTo(0, srollHeight); &#125; else &#123; //键盘隐藏 root.scrollTo(0, 0); &#125; &#125; &#125;);&#125;/** * 获取底部导航栏高度 * * @param act * @return */private int getNavigationBarHeight(Context act) &#123; Resources resources = act.getResources(); int resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android"); int height = resources.getDimensionPixelSize(resourceId); Log.v("dbw", "Navi height:" + height); return height;&#125;//软键盘消失的管理//region软键盘的处理/** * 清除editText的焦点 * * @param v 焦点所在View * @param ids 输入框 */public void clearViewFocus(View v, int... ids) &#123; if (null != v &amp;&amp; null != ids &amp;&amp; ids.length &gt; 0) &#123; for (int id : ids) &#123; if (v.getId() == id) &#123; v.clearFocus(); break; &#125; &#125; &#125;&#125;/** * 隐藏键盘 * * @param v 焦点所在View * @param ids 输入框 * @return true代表焦点在edit上 */public boolean isFocusEditText(View v, int... ids) &#123; if (v instanceof EditText) &#123; EditText tmp_et = (EditText) v; for (int id : ids) &#123; if (tmp_et.getId() == id) &#123; return true; &#125; &#125; &#125; return false;&#125;//是否触摸在指定view上面,对某个控件过滤public boolean isTouchView(View[] views, MotionEvent ev) &#123; if (views == null || views.length == 0) return false; int[] location = new int[2]; for (View view : views) &#123; view.getLocationOnScreen(location); int x = location[0]; int y = location[1]; if (ev.getX() &gt; x &amp;&amp; ev.getX() &lt; (x + view.getWidth()) &amp;&amp; ev.getY() &gt; y &amp;&amp; ev.getY() &lt; (y + view.getHeight())) &#123; return true; &#125; &#125; return false;&#125;//region 右滑返回上级@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; if (isTouchView(filterViewByIds(), ev)) return super.dispatchTouchEvent(ev); if (hideSoftByEditViewIds() == null || hideSoftByEditViewIds().length == 0) return super.dispatchTouchEvent(ev); View v = getCurrentFocus(); if (isFocusEditText(v, hideSoftByEditViewIds())) &#123; //隐藏键盘 hideInputForce(this); clearViewFocus(v, hideSoftByEditViewIds()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 传入EditText的Id * 没有传入的EditText不做处理 * * @return id 数组 */public int[] hideSoftByEditViewIds() &#123; int [] ids = &#123;R.id.et1,R.id.et2&#125;; return ids;&#125;/** * 传入要过滤的View * 过滤之后点击将不会有隐藏软键盘的操作 * * @return id 数组 */public View[] filterViewByIds() &#123; View [] views = &#123;mEt1,mEt2&#125;;//点击这两个控件,软键盘不会消失 return views;&#125;/** * des:隐藏软键盘,这种方式参数为activity * * @param activity */public static void hideInputForce(Activity activity) &#123; if (activity == null || activity.getCurrentFocus() == null) return; ((InputMethodManager) activity.getSystemService(INPUT_METHOD_SERVICE)) .hideSoftInputFromWindow(activity.getCurrentFocus() .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);&#125;&#125; 以下是布局文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:id="@+id/activity_main"android:layout_width="match_parent"android:layout_height="match_parent"android:orientation="vertical"tools:context="fengan.softinputdemo.MainActivity"&gt;&lt;LinearLayout android:id="@+id/LL" android:layout_marginTop="100dp" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="wrap_content"&gt;&lt;EditText android:id="@+id/et1" android:layout_marginTop="60dp" android:background="#ff0" android:layout_width="match_parent" android:layout_height="60dp"/&gt;&lt;EditText android:id="@+id/et2" android:layout_marginTop="20dp" android:background="#ff0" android:layout_width="match_parent" android:layout_height="60dp"/&gt;&lt;Button android:text="软键盘挡住button" android:id="@+id/btn" android:layout_marginTop="30dp" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; 可以将隐藏显示的代码封装到BaseActivity]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存图片到本地]]></title>
    <url>%2F2016%2F08%2F21%2F%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[一个很常见的需求,图片保存到本地,矫正图片角度，通知图库更新 步骤 使用Gilde获取图片的Drawable Drawable转成Bitmap bigtmap压缩并通过流写入 通知系统图库更新 代码块 保存图片,流写入,压缩 public static void saveImageToGallery(Context context, Bitmap bmp) { File appDir = new File(Environment.getExternalStorageDirectory(), &quot;fengandev&quot;); if (!appDir.exists()) { appDir.mkdir(); } String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; File file = new File(appDir, fileName); try { FileOutputStream fos = new FileOutputStream(file); bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } // 其次把文件插入到系统图库 try { MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null); } catch (FileNotFoundException e) { e.printStackTrace(); } // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(file.getPath())))); ToastUtil.showShort(&quot;保存到&quot; + file.getPath()); }` 通过glide回调,获取图片Drawable mTvSave.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showLoadding(); GlideUtils.loadImage(Utils.getContext(), imaUrl), mIvImg,new GlideUtils.ImageLoadListener&lt;String, GlideDrawable&gt;() { @Override public void onLoadingComplete(String uri, ImageView view, GlideDrawable resource) { FileUtils.saveImageToGallery(Utils.getContext(), BitmapUtils.drawableToBitmap(resource)); } @Override public void onLoadingError(String source, Exception e) { showState(&quot;保存失败&quot;,0); } }); } }); 分享一个Glide封装 Glide封装类 public abstract class GlideUtils { /** * 简单图片加载回调 * * @param &lt;T&gt; 图片url 或资源id 或 文件 * @param &lt;K&gt; 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ public interface ImageLoadListener&lt;T, K&gt; { /** * 图片加载成功回调 * * @param uri 图片url 或资源id 或 文件 * @param view 目标载体，不传则为空 * @param resource 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ void onLoadingComplete(T uri, ImageView view, K resource); /** * 图片加载异常返回 * * @param source 图片地址、File、资源id * @param e 异常信息 */ void onLoadingError(T source, Exception e); } /** * 详细加载图片加载回调 * * @param &lt;T&gt; 图片url 或资源id 或 文件 * @param &lt;K&gt; 返回的资源 */ public interface ImageLoadDetailListener&lt;T, K&gt; { /** * 图片加载成功回调 * * @param uri 图片url 或资源id 或 文件 * @param view 目标载体，不传则为空 * @param resource 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ void onLoadingComplete(T uri, ImageView view, K resource); /** * 图片加载异常返回 * * @param source 图片地址、File、资源id * @param errorDrawable 加载错误占位图 * @param e 异常信息 */ void onLoadingError(T source, Drawable errorDrawable, Exception e); /** * 加载开始 * * @param source 图片来源 * @param placeHolder 开始加载占位图 */ void onLoadingStart(T source, Drawable placeHolder); } /** * 根据上下文和 url获取 Glide的DrawableTypeRequest * * @param context 上下文 * @param url 图片连接 * @param &lt;T&gt; Context类型 * @param &lt;K&gt; url类型 * @return 返回DrawableTypeRequst&lt;K&gt; 类型 */ private static &lt;T, K&gt; DrawableTypeRequest&lt;K&gt; getDrawableTypeRequest(T context, K url) { DrawableTypeRequest&lt;K&gt; type = null; try { if (context instanceof android.support.v4.app.Fragment) { type = Glide.with((android.support.v4.app.Fragment) context).load(url); } else if (context instanceof android.app.Fragment) { type = Glide.with((android.app.Fragment) context).load(url); } else if (context instanceof Activity) { //包括FragmentActivity type = Glide.with((Activity) context).load(url); } else if (context instanceof Context) { type = Glide.with((Context) context).load(url); } } catch (Exception e) { e.printStackTrace(); } return type; } /** * 图片加载监听类 * * @param &lt;T&gt; 图片链接 的类型 * @param &lt;K&gt; 图片资源返回类型 * @param &lt;Z&gt; 返回的图片url */ private static class GlideListener&lt;T, K, Z&gt; implements RequestListener&lt;T, K&gt; { ImageLoadListener&lt;Z, K&gt; imageLoadListener = null; Z url; ImageView imageView = null; GlideListener(ImageLoadListener&lt;Z, K&gt; imageLoadListener, Z url, ImageView view) { this.imageLoadListener = imageLoadListener; this.url = url; this.imageView = view; } GlideListener(ImageLoadListener&lt;Z, K&gt; imageLoadListener, Z url) { this.imageLoadListener = imageLoadListener; this.url = url; } GlideListener(Z url) { this.url = url; } @Override public boolean onResourceReady(K resource, T model, Target&lt;K&gt; target, boolean isFromMemoryCache, boolean isFirstResource) { if (null != imageLoadListener) { if (imageView != null) { imageLoadListener.onLoadingComplete(url, imageView, resource); } else { imageLoadListener.onLoadingComplete(url, null, resource); } } return false; } @Override public boolean onException(Exception e, T model, Target&lt;K&gt; target, boolean isFirstResource) { //LogUtil.e(&quot;Glide图片加载失败:&quot;+e + &quot; 地址为:&quot;+url); if (imageLoadListener != null) { imageLoadListener.onLoadingError(url, e); } return false; } } /** * 获取存储器上的图片,回调返回GlideDrawable * * @param context 上下文年 * @param file 文件File * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;File&gt; loadImage(T context, @NonNull File file, @NonNull ImageLoadListener&lt;File, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;File&gt; type = getDrawableTypeRequest(context, file); if (type != null) { return type.listener(new GlideListener&lt;File, GlideDrawable, File&gt;(imageLoadListener, file)); } else { return null; } } /** * 获取资源中的图片，回调返回GlideDrawable * * @param context 上下文 * @param resourceId 资源id * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;Integer&gt; loadImage(T context, @DrawableRes int resourceId, @NonNull ImageLoadListener&lt;Integer, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;Integer&gt; type = getDrawableTypeRequest(context, resourceId); if (type != null) { return type.listener(new GlideListener&lt;Integer, GlideDrawable, Integer&gt;(imageLoadListener, resourceId)); } else { return null; } } /** * 获取网络图片，回调返回 GlideDrawable * * @param context 上下文 * @param url 图片url * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;String&gt; loadImage(T context, @NonNull final String url, @NonNull ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url)); } else { return null; } } /** * 加载存储器上的图片到目标载体 * * @param file 文件File * @param imageView 要显示到的图片ImageView */ public static Target&lt;GlideDrawable&gt; loadImage(@NonNull final File file, @NonNull ImageView imageView, ImageLoadListener&lt;File, GlideDrawable&gt; imageLoadListener) { return getDrawableTypeRequest(imageView.getContext(), file) .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用磁盘缓存 .skipMemoryCache(true)//跳过内存缓存 .dontAnimate() .listener(new GlideListener&lt;File, GlideDrawable, File&gt;(imageLoadListener, file, imageView)) .into(imageView); } /** * 加载资源中的图片到目标载体 * * @param resourceId 资源id * @param imageView 图片View */ public static Target&lt;GlideDrawable&gt; loadImage(@DrawableRes int resourceId, @NonNull ImageView imageView, ImageLoadListener&lt;Integer, GlideDrawable&gt; imageLoadListener) { return getDrawableTypeRequest(imageView.getContext(), resourceId) .listener(new GlideListener&lt;Integer, GlideDrawable, Integer&gt;(imageLoadListener, resourceId, imageView)) .into(imageView); } /** * 加载成圆形头像到普通ImageView，有动画效果 * * @param url 图片url * @param imageView 要显示到的ImageView * @param imageLoadListener 加载回调监听器 * @param parms 设置占位符和加载失败图片(可变参数默认两张,第一张为占位符,第二张是默认图片) * @return 返回Target&lt;GlideDrawable&gt; */ public static Target&lt;GlideDrawable&gt; loadCircleImage(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener, int... parms) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(), url); if (parms != null &amp;&amp; parms.length &gt; 0) { type.placeholder(parms[0]); //占位符 if (parms.length &gt; 1) { type.error(parms[1]); //图片加载失败显示图片 } } type.transform(new CircleTransform(imageView.getContext())); return type.listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } /** * 加载网络图片到指定Imageview，支持CircleImageView * * @param url 图片url * @param imageView 要显示的Imageview * @param imageLoadListener 图片加载回调 * @param parms 第一个是error的图片 */ public static &lt;T&gt; Target&lt;GlideDrawable&gt; loadImage(T context, @NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener, int... parms) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { type.asBitmap(); if (parms != null &amp;&amp; parms.length &gt; 0) { type.placeholder(parms[0]); //占位符 if (parms.length &gt; 1) { type.error(parms[1]); //图片加载失败显示图片 } } //单张CircleImageView不允许动画，不然会不显示, if (imageView instanceof nfzr.zr.nf.nfzr.com.nongfaziran.nfzr.view.CircleImageView) { type.dontAnimate(); } return type .listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } else { return null; } } /** * 加载一帧视频，添加圆角 * * @param url 图片地址 * @param imageView 要加载到的ImageView */ public static Target&lt;GlideDrawable&gt; loadImageFormVideo(@NonNull String url, @NonNull ImageView imageView) { return getDrawableTypeRequest(imageView.getContext(), url) .override(SizeUtil.dp2px(150), SizeUtil.dp2px(150)) //.placeholder(android.R.drawable.picture_frame) //占位图 .dontAnimate() .into(imageView); } public static &lt;T&gt; Target&lt;GlideDrawable&gt; loadImageDetail(final T context, @NonNull final String url, @NonNull final ImageView imageView, final Drawable drawable, final ImageLoadDetailListener&lt;String, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.into(new SimpleTarget&lt;GlideDrawable&gt;() { @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) { if (imageView != null &amp;&amp; resource != null) { imageView.setImageDrawable(resource); } if (imageLoadListener != null) { imageLoadListener.onLoadingComplete(url, imageView, resource); } } @Override public void onStart() { super.onStart(); if (drawable != null &amp;&amp; imageView != null) { imageView.setImageDrawable(drawable); } } @Override public void onLoadStarted(Drawable placeholder) { super.onLoadStarted(placeholder); if (imageLoadListener != null) { imageLoadListener.onLoadingStart(url, placeholder); } } @Override public void onLoadFailed(Exception e, Drawable errorDrawable) { super.onLoadFailed(e, errorDrawable); if (imageLoadListener != null) { imageLoadListener.onLoadingError(url, errorDrawable, e); } } }); } else { return null; } } /** * 加载bitmap，回调返回 Bitmap * * @param context 上下文 * @param url 图片url * @param imageLoadListener 图片加载监听器 * @param &lt;T&gt; 上下文类型 */ public static &lt;T&gt; BitmapRequestBuilder&lt;String, Bitmap&gt; loadImageBitmap(T context, @NonNull String url,@NonNull ImageLoadListener&lt;String, Bitmap&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.asBitmap() .listener(new GlideListener&lt;String, Bitmap, String&gt;(imageLoadListener, url)); }else{ return null; } } /** * 加载GifDrawable，回调返回 GifDrawable * * @param context 上下文 * @param url 图片url * @param imageLoadListener 图片加载监听器 */ public static &lt;T&gt; GifRequestBuilder&lt;String&gt; loadImageGif(T context, @NonNull String url,@NonNull ImageLoadListener&lt;String, GifDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.asGif() .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, GifDrawable, String&gt;(imageLoadListener, url)); }else{ return null; } } /** * 加载Gif的一张图片到ImageView * * @param url 图片url * @param imageLoadListener 图片加载监听器 * @param imageView * @param drawable 缩略图，可以为空 */ public static Target&lt;Bitmap&gt; loadImageGifSingle(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, Bitmap&gt; imageLoadListener, Drawable drawable) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(),url); return type.asBitmap() .placeholder(drawable) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, Bitmap, String&gt;(imageLoadListener, url)) .into(imageView); } /** * 加载gif图片到指定ImageView * * @param url 图片Url * @param imageView 图片View * @param imageLoadListener 图片加载监听器 */ public static Target&lt;GifDrawable&gt; loadImageGif(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GifDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(),url); return type.asGif() .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, GifDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } /** * 释放内存 * * @param context 上下文 */ public static void clearMemory(Context context) { Glide.get(context).clearMemory(); } /** * 取消所有正在下载或等待下载的任务。 * * @param context 上下文 */ public static void cancelAllTasks(Context context) { Glide.with(context).pauseRequests(); } /** * 恢复所有任务 */ public static void resumeAllTasks(Context context) { Glide.with(context).resumeRequests(); } /** * 清除磁盘缓存 * * @param context 上下文 */ public static void clearDiskCache(final Context context) { new Thread(new Runnable() { @Override public void run() { Glide.get(context).clearDiskCache(); } }).start(); } /** * 清除所有缓存 * * @param context 上下文 */ public static void cleanAll(Context context) { clearDiskCache(context); clearMemory(context); } public class CircleTransform extends BitmapTransformation { public CircleTransform(Context context) { super(context); } @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) { return circleCrop(pool, toTransform); } private static Bitmap circleCrop(BitmapPool pool, Bitmap source) { if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) { result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); } Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; } @Override public String getId() { return getClass().getName(); } } Drawable转bigmap public class BitmapUtils { public static Bitmap drawableToBitmap(Drawable drawable) { Bitmap bitmap = Bitmap.createBitmap( drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); //canvas.setBitmap(bitmap); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()); drawable.draw(canvas); return bitmap; } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0之应用间共享文件]]></title>
    <url>%2F2016%2F07%2F23%2FAndroid7-0%E4%B9%8B%E5%BA%94%E7%94%A8%E9%97%B4%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android7.0适配之应用间共享文件 出现问题Android N(API 25),打开相册编辑页面crash,报出FileUriExposedException异常 123456789android.os.FileUriExposedException: file:////storage/emulated/0/temp/1474956193735.jpg exposed beyond app through Intent.getData()at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)at android.net.Uri.checkFileUriExposed(Uri.java:2346)at android.content.Intent.prepareToLeaveProcess(Intent.java:8933)at android.content.Intent.prepareToLeaveProcess(Intent.java:8894)at android.app.Instrumentation.execStartActivity(Instrumentation.java:1517)at android.app.Activity.startActivityForResult(Activity.java:4223)...at android.app.Activity.startActivityForResult(Activity.java:4182) 查找原因Android N的应用,API禁止向应用外公开file://URI,如果一项包含文件URI的Intent离开应用, 应用crash并报FileUriExposedException异常 解决办法若想要在应用间共享文件,应该发送一项content://URI,并该URI临时访问权限,进行此授权的方式是通过FileProvider类 具体步骤[1] 清单文件123456789101112131415161718192021222324252627282930 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.fengan.providerdemo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--authorities="你的包名+fileprovider" --&gt; &lt;provider android:authorities="com.fengan.providerdemo.fileprovider" android:name="android.support.v4.content.FileProvider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths"/&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; [2] res下xml文件夹注意xml文件名和清单文件中@xml/filepaths相同xml文件内容 123456 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;!-- external-path:sd ；path:你的应用保存文件的根目录；name随便定义--&gt; //&lt;external-path path="fengan_imgs/" name="files_path" /&gt; &lt;external-path path="" name="files_path" /&gt;&lt;/paths&gt; 注意:path=””,有特殊意义,它代表更目录,也就是说可以向应用共享根目录及其子目录下任何一个文件,如果将path写为path=”fengan_imgs/“,那么只能在fengan_imgs/目录下才可以分享![3]核心代码将File转换为uri 12345678910111213private static Uri getUriForFile(Context context, File file) &#123; if (context == null || file == null) &#123; throw new NullPointerException(); &#125; Uri uri; if (Build.VERSION.SDK_INT &gt;= 24) &#123; //和android:authorities="com.fengan.providerdemo.fileprovider"对应 uri = FileProvider.getUriForFile(context.getApplicationContext(), "com.fengan.providerdemo.fileprovider", file); &#125; else &#123; uri = Uri.fromFile(file); &#125; return uri; &#125; Uri的scheme类型为file,改成了又FileProvider创建一个content类型的Uri打开相机,打印该Uri为content://com.fengan.providerdemo/files_path/temp/1474960080319.jpg`。//其中camera_photos就是file_paths.xml中paths的name。 1234567891011121314151617/** * 打开相机 * 兼容7.0 * * @param activity Activity * @param file File * @param requestCode result requestCode */ public static void startActionCapture(Activity activity, File file, int requestCode) &#123; if (activity == null) &#123; return; &#125; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); //添加这一句表示对目标应用临时授权该Uri所代表的文件 intent.putExtra(MediaStore.EXTRA_OUTPUT, getUriForFile(activity, file));//拍取照片保存到指定Uri activity.startActivityForResult(intent, requestCode); &#125; 总结 针对涉及到从Android设备上获取照片(拍照,或从相册,文件中选择)打开相机,裁剪图片,压缩图片,可以使用一个轻量级开源库,TakePhoto! https://github.com/crazycodeboy/TakePhoto/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app启动流程简析]]></title>
    <url>%2F2016%2F03%2F16%2Fapp%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 Android系统中，应用程序是由Activity组成的，因此，应用程序的启动过程实际上就说应用程序中默认Activity的启动过程，本文主要整理冷启动的情况。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview中点击网页图片跳转查看图片]]></title>
    <url>%2F2016%2F03%2F08%2Fwebview%E4%B8%AD%E7%82%B9%E5%87%BB%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E8%B7%B3%E8%BD%AC%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言 app中很多图文页面，类似新闻详情页，都是一个H5网页，当我们点击网页中的图片，希望跳转到一个多图游览的页面，并且支持手势缩放和保存的一些功能。今天主要整理一下点击网页中图片，跳转到指定图片的查看页面即可，手势缩放可以使用photoview。 原理效果 原理 首先点击h5页面，跳转本地页面，是js调用原生代码 Js通过WebView调用Android代码有三种方式 通过WebView的addJavascriptInterface（）进行对象映射 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息 通过addJavascriptInterface定义js接口的方式比较方便，所以本文采用的是这种方式，详细见下列代码 定义js接口 找到网页中img标签的代码块，设置点击 相关权限和混淆 代码定义js接口1234567891011121314151617181920212223242526272829** * Created by fengan on 2016/3/8. * email:fengan1102@gmail.com * 点击webview页面图片，跳转查看大图页面的js接口 * 检查混淆文件，确保未被混淆 */public class JavaScriptInterface &#123; private Activity mContext; private ArrayList&lt;String&gt; mImgList = new ArrayList&lt;&gt;(); public JavaScriptInterface(Activity context) &#123; this.mContext = context; &#125;//方法名要和执行的js代码中一致 @JavascriptInterface public void addImageUrl(String img) &#123; mImgList.add(img); &#125; @JavascriptInterface public void openImage(String img) &#123; if (ClickUtils.noDoubleClick()) &#123; int index = mImgList.indexOf(img); PhotoListAty.startAty(index == -1 ? 0 : index, mImgList, mContext); &#125; &#125;&#125; 自定义WebClient1234567891011121314151617181920212223242526272829303132333435363738394041public class MyWebViewClient extends WebViewClient &#123; @Override public void onPageFinished(WebView view, String url) &#123; view.getSettings().setJavaScriptEnabled(true); super.onPageFinished(view, url); addImageClickListener(view);//待网页加载完全后设置图片点击的监听方法 &#125; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; view.getSettings().setJavaScriptEnabled(true); super.onPageStarted(view, url, favicon); &#125; private void addImageClickListener(WebView webView) &#123; webView.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\"); " + "for(var i=0;i&lt;objs.length;i++) " + "&#123;" + "window.imagelistener.addImageUrl(objs[i].src); " + " objs[i].onclick=function() " + " &#123; " + " window.imagelistener.openImage(this.src); " + " &#125; " + "&#125;" + "&#125;)()"); &#125; 1234//imagelistener用于暴露js的对象，需要对应 mWebview.getSettings().setJavaScriptEnabled(true); mWebview.addJavascriptInterface(new JavaScriptInterface(this), "imagelistener"); mWebview.setWebViewClient(new MyWebViewClient()); 注意事项注意在混淆文件中添加 项目中暴露的js接口类：MJavascriptInterface不能混淆，其调用的方法的声明也不能混淆，所以还要添加如下混淆设置代码（代码因包名而变化） 123456-keepclassmembers class com.example.administrator.webviewpagescannerapp.other.MJavascriptInterface&#123; public *; &#125; -keepattributes *Annotation* -keepattributes *JavascriptInterface*]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生65535的原因和解决办法]]></title>
    <url>%2F2016%2F03%2F06%2F%E4%BA%A7%E7%94%9F65535%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Android关于65535的问题 熟悉Android开发的都知道，在生成Dex过程中，方法数超过65535就会报错，本文只简述一下如何解决，更重要的是为什么会这样。简单来说，在Dalvik指令集中，调用方法的invoke-kind指令中，method reference index只给了16bits，最多能调用65535个方法，所以在生成dex文件的过程中，当方法数超过65535就会报错。其实除了method，filed和class的index也是16bits，所以也会存在65535的问题，只不过method的数量一般是最多的，所以最常见的也是方法数溢出的问题。 导入multidex包，配置gradle文件multiDexEnabled true implementation &#39;com.android.support:multidex:1.0.2&#39; Application中初始化 继承MultiDexApplication 重写Application 的attachBaseContext方法，这个方法是在onCreate之前执行的 12345678public class MyApplication extends Application&#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125; &#125; 这样会生成classes.dex classes2.dex classes3.dex …多个dex文件 为啥会有65536的限制一个 dex 文件的方法引用数不能大于 64k，64k 的准确值是（64 * 1024 = 65536）。 invoke-kind （调用各类方法）指令中，方法引用索引数是 16 位的，也就是最多调用 2^16 = 65536 个方法，这就是 DexFormat 中 MAX_MEMBER_IDX 为 0xFFFF 的原因。 详细原因查看]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾集合体系]]></title>
    <url>%2F2015%2F12%2F26%2F%E5%9B%9E%E9%A1%BE%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[集合体系整理 前言 面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象进行操作，就需要对对象进行存储 数组虽然可以存储对象，但是长度上固定的 集合的长度是可变的 数组中可以存储基本数据类型 集合中只能存储对象 集合体系图 Iterator接口 Iterator接口，这是一个用于遍历集合中元素的接口 主要包含hashNext(),next(),remove()三种方法 它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious() Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常无序集合实现的都是这个接口，比如HashSet，HashMap 元素有序的集合，实现的一般都是LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个元素，比如ArrayList。 Collection接口 Collection是集合类根接口，衍生出两个子类接口List和Set Collection定义了集合框架的共性功能 List接口List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 ArrayList：线程不安全，查询速度快，元素有序，可重复 Vector：线程安全，但速度慢，已被ArrayList替代 LinkedList：链表结构，增删速度快 LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反 Set接口Set里存放的对象是无序（存入和取出的顺序不一定一致），不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 HashSet：： 底层数据结构是哈希表。是线程不安全的。不同步 通过元素的两个方法，hashCode和equals来保证唯一性 如果元素的HashCode值相同，才会判断equals是否为true。 如果元素的hashcode值不同，不会调用equals。 无序 TreeSet： 有序 线程不安全，可以对Set集合中的元素进行排序 通过compareTo或者compare方法来保证元素的唯一性，元素以二叉树的形式存放。 Map接口 Map提供了一种映射关系，元素是以键值对（key-value）的形式存储的，能根据key快速查找value； Map中的键值对以Entry类型的对象实例形式存在； key值不能重复，value值可以重复； HashMap底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同步的。将hashtable替代，jdk1.2.效率高。 HashMap原理： HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 数组中的每一项又是一个Entry，其中包含了key和value，也就是键值对，另外还包含了一个next的Entry指针 因为持有下一个Entry指针，所以构成链表 往HashMap中put元素的时候，先根据key的hashCode重新计算hash值 根据hash值得到这个元素在数组中的位置（即下标） 如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。 如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上 从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 一句话原理总结：简单来说，HashMap在底层将key-value当作一个整体处理，这个整体就是一个Entry对象。HashMap底层采用一个Entry[]数组来保存所有的key-value，每个Entry包含了key-value，还包含了next的Entry指针，因此构成一个链表。当要存储一个Entry对象时，会根据hash算法决定在数组中的存储位置，再根据equals方法，决定其在该数组位置上的链表的存储位置；在需要取出一个Entry时，也会根据hash算法找到其在这个数组的存储位置，再根据equel方法，从该位置找到对应的Entry对象。 hashmap两种遍历方式第一种： 1234567Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); &#125; 第二种： 123456 Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; Object key = iter.next(); Object val = map.get(key); &#125; 浅析ConcurrentHashMap public V get(Object key)不涉及到锁，也就是说获得对象时没有使用锁； put、remove方法要使用锁，但并不一定有锁争用，原因在于ConcurrentHashMap将缓存的变量分到多个Segment，每个Segment上有一个锁，只要多个线程访问的不是一个Segment就没有锁争用，就没有堵塞，各线程用各自的锁，ConcurrentHashMap缺省情况下生成16个Segment，也就是允许16个线程并发的更新而尽量没有锁争用； Hashtable对get,put,remove都使用了同步操作，也就是说如果有线程正在遍历集合，其他的线程就暂时不能使用该集合了，这样无疑就很容易对性能和吞吐量造成影响。而ConcurrentHashMap则不同，它只对put,remove操作使用了同步操作，get操作并不影响 Hashtable在使用iterator遍历的时候，如果其他线程，包括本线程对Hashtable进行了put，remove等更新操作的话，就会抛出ConcurrentModificationException异常，但如果使用ConcurrentHashMap的话，就不用考虑这方面的问题了 浅析HashMap，HashTable，ConcurrentHashMap HashMap如上所诉，不同步，线程不安全，不使用用与多线程高并发情况下 Hashtable，被遗弃的类，线程安全是因为在所有方法上都加了synchronized来实现线程安全，导致多线程访问效率低 Synchronized Map（通过Collections.synchronizedMap()来包装一个hashmap）和hashtable区别不大，唯一区别就是没有被遗弃 ConcurrentHashMap，默认允许16个线程读写这个map，不像Hashtable和Synchronized Map一样，没有锁整个整个map，而是划分了多个段（Segment），只会锁需要操作的那一段数据 点击查看详细博客 点击查看相关博客 TreeMap底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。 集合输出（遍历） Iterator： 迭代输出，使用最多的输出方式 ListIterator：是Iterator的子接口，专门用于输出List中的内容。 foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。 for循环 集合的工具类Collections:集合框架的工具类。里面定义的都是静态方法。 Collections和Collection有什么区别？ Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。 它有两个常用的子接口， ——List：对元素都有定义索引。有序的。可以重复元素。 ——Set：不可以重复元素。无序。 Collections是集合框架中的一个工具类。该类中的方法都是静态的。 提供的方法中有可以对list集合进行排序，二分查找等方法。 通常常用的集合都是线程不安全的。因为要提高效率。 如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。 总结List：add/remove/get/set。 1，ArrayList：其实就是数组，容量一大，频繁增删就是噩梦，适合随机查找； 2，LinkedList：增加了push/[pop|remove|pull]，其实都是removeFirst； 3，Vector：历史遗留产物，同步版的ArrayList，代码和ArrayList太像； 4，Stack：继承自Vector。Java里其实没有纯粹的Stack，可以自己实现，用组合的方式，封装一下LinkedList即可； 5，Queue：本来是单独的一类，不过在SUN的JDK里就是用LinkedList来提供这个功能的，主要方法是offer/pull/peek，因此归到这里呢。 Set：add/remove。可以用迭代器或者转换成list。 1，HashSet：内部采用HashMap实现的； 2，LinkedHashSet：采用LinkedHashMap实现； 3，TreeSet：TreeMap。 Map：put/get/remove。 1，HashMap/HashTable：散列表，和ArrayList一样采用数组实现，超过初始容量会对性能有损耗； 2，LinkedHashMap：继承自HashMap，但通过重写嵌套类HashMap.Entry实现了链表结构，同样有容量的问题； 3，Properties：是继承的HashTable。 顺便说一下Arrays.asList，这个方法的实现依赖一个嵌套类，这个嵌套类也叫ArrayList！ 手写集合ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 手写ArrayList */ public class MyArrayList&#123; private Object[] value = null; private int size = 0; MyArrayList() &#123; value = new Object[10]; &#125; public boolean add(Object obj)&#123; if(size == value.length) expansion(); value[size++]=obj; return true; &#125; public Object get(int index)&#123; return value[index]; &#125; public void remove(Object obj)&#123; Object[] obj2 = new Object[size]; int index = 0; int id = 0; for (int i = 0; i &lt;= size; i++) &#123; if(!(value[i].toString().equals(obj.toString())))&#123; obj2[index] = value[i]; index ++; &#125;else&#123; id ++ ; if(id == 1) size --; else&#123; obj2[index] = value[i]; index ++; &#125; &#125; &#125; value = obj2; &#125; @SuppressWarnings("null") public void set(int index,Object obj)&#123; Object[] newObj = new Object[size];; for (int i = 0; i &lt; size; i++) &#123; if(i == index) newObj[i] = obj; else newObj[i] = value[i]; &#125; value = newObj; &#125; public int size()&#123; return size; &#125; private boolean expansion() &#123; Object[] temp = new Object[value.length + 5]; temp = value.clone(); /** * 注意：clone只对一维数组起作用，而不能用于二维数组， 因为java没有二维数组的概念，而只有数组的数组，二维 * 数组存储的是几个一维数组的引用，而使用clone也只是 拷贝了这几个引用，说白了还是原来那几个一维数组对象。 * 如果想用于二维数组，那么就遍历其中的一维数组，挨个 拷贝一维数组到目标二维数组中的一维数组下。 */ value = temp; return true; &#125; public void clear()&#123; size = 0; value = null; &#125; public static void main(String[] args) &#123; MyArrayList ma = new MyArrayList(); ma.add("hello"); ma.add("world"); ma.add("java"); System.out.println(ma.get(1)); System.out.println(ma.size()); ma.set(1, "new"); System.out.println(ma.get(1)); System.out.println(ma.size()); &#125; &#125; LinkedList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class MyLinkedList&lt;AnyType&gt; &#123; private static class Node&lt;AnyType&gt;&#123; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; public Node(AnyType d, Node&lt;AnyType&gt; p, Node&lt;AnyType&gt; n)&#123; data = d; prev = p; next = n; &#125; &#125; private int theSize; private int modCount; private Node&lt;AnyType&gt; beginMarker; private Node&lt;AnyType&gt; endMarker; public MyLinkedList()&#123; clear(); &#125; public void clear()&#123; beginMarker = new Node&lt;AnyType&gt;(null, null, null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; &#125; public int size()&#123; return theSize; &#125; public boolean add(AnyType x)&#123; add(size(), x); return true; &#125; public void add(int idx, AnyType x)&#123; addBefore(getNode(idx), x); &#125; public AnyType get(int idx)&#123; return getNode(idx).data; &#125; private void addBefore(Node&lt;AnyType&gt; p, AnyType x)&#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x, p.prev, p); newNode.prev.next = newNode; p.prev = newNode; theSize++; modCount++; &#125; private Node&lt;AnyType&gt; getNode(int idx)&#123; Node&lt;AnyType&gt; p; if(idx &lt; 0 || idx &gt; size())&#123; System.out.println("IndexOutOfBoundsException"); &#125; if(idx &lt;= size()/2)&#123; System.out.println(idx); p = beginMarker.next; for(int i = 0; i &lt; idx; i++)&#123; p = p.next; &#125; &#125;else&#123; p = endMarker; for(int i = size(); i &gt; idx; i--)&#123; p = p.prev; &#125; &#125; return p; &#125; public boolean find(AnyType x)&#123; Node&lt;AnyType&gt; p = beginMarker.next; for(int i = 0; i &lt; size(); i++)&#123; if(p.data == x)&#123; return true; &#125; p = p.next; &#125; return false; &#125; public String toString()&#123; String s = ""; Node&lt;AnyType&gt; p = beginMarker.next; for(int i = 0; i &lt; size(); i++)&#123; s += p.data +","; p = p.next; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread]]></title>
    <url>%2F2015%2F12%2F22%2FHandlerThread%2F</url>
    <content type="text"><![CDATA[HandlerThread HandlerThread知识点整理 官方介绍 Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是HandlerThread能够新建拥有Looper的线程(除了主线程,我们新建线程是需要手动调用Looper.prepare来初始化looper和messagequeue的),而这个looper能够来新建其他的Handler(新建的这个handler是属于子线程的,并且looper和messagequeue都是初始化好了的) 如以下代码： 1234567891011121314151617181920212223mHandlerThread = new HandlerThread("check-message-coming");//the name of the new thread mHandlerThread.start(); mThreadHandler = new Handler(mHandlerThread.getLooper())//拥有子线程looper的handler &#123; @Override public void handleMessage(Message msg) &#123; update();//模拟数据更新 if (isUpdateInfo) mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; &#125;; @Override protected void onDestroy() &#123; super.onDestroy(); //释放资源 myHandlerThread.quit() ; &#125;//其他线程可以拿mThreadHandler发消息了，来完成向该HandlerThread线程通讯 mThreadHandler构建的时候,传的是HandlerThread的looper对象,也就是说这个mThreadHandler是属于子线程的管理的,他的handlerMessage的回调中是可以做耗时操作的(切记,是不能做更新UI的操作的,如需要更新,需要用主线程的handler发消息来更新,或者使用runOnUiThread或者eventBus等其他方式来刷新ui) 退出循环 Looper是通过调用loop方法驱动着消息循环的进行: 从MessageQueue中阻塞式地取出一个消息，然后让Handler处理该消息，周而复始，loop方法是个死循环方法。 那如何终止消息循环呢？我们可以调用Looper的quit方法或quitSafely方法，二者稍有不同。 1234567891011121314151617181920212223242526272829303132333435/** * Quits the looper. * &lt;p&gt; * Causes the &#123;@link #loop&#125; method to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class="note"&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @see #quitSafely */ public void quit() &#123; mQueue.quit(false); &#125; /** * Quits the looper safely. * &lt;p&gt; * Causes the &#123;@link #loop&#125; method to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * However pending delayed messages with due times in the future will not be * delivered before the loop terminates. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt; */ public void quitSafely() &#123; mQueue.quit(true); &#125; quit（）和quitSafety的区别 当我们调用Looper的quit方法时，实际上执行了MessageQueue中的removeAllMessagesLocked方法，该方法的作用是把MessageQueue消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。 当我们调用Looper的quitSafely方法时，实际上执行了MessageQueue中的removeAllFutureMessagesLocked方法，通过名字就可以看出，该方法只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。 无论是调用了quit方法还是quitSafely方法只会，Looper就不再接收新的消息。即在调用了Looper的quit或quitSafely方法之后，消息循环就终结了，这时候再通过Handler调用sendMessage或post等方法发送消息时均返回false，表示消息没有成功放入消息队列MessageQueue中，因为消息队列已经退出了。 需要注意的是Looper的quit方法从API Level 1就存在了，但是Looper的quitSafely方法从API Level 18才添加进来。 总结 1. HandlerThread继承自Thread,因此调用start方法,也是执行run方法,run()方法的逻辑都是在子线程中运行的。 2. 查看HandlerThread源码可以看到,run()中主要做了Looper.prepare()和looper.loop()创建looper和messagequeue对象并开启消息队列的循环 3. 需要注意的是,对于网络io操作,HandlerThread并不适合,因为它只有一个线程,得排队一个一个等着。 4. 页面消耗的时候,调用 myHandlerThread.quit() ;looper就不在接受新的消息,消息循环结束,这个时候再通过handler调用sendMessage或者post等方法发送消息时均返回false,表示没有成功的放入消息队列。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[edittext输入限制]]></title>
    <url>%2F2015%2F12%2F13%2Fedittext%E8%BE%93%E5%85%A5%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[EditText智能限制小数点前后分别保留几位 需求 可以分别限制小数点前面几位，和小数点后几位 首位输入0时，第二位只能输入小数点 首位输入小数点，默认显示0. 嘻嘻! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * * @param frontPoint 小数点前几位数 * @param behindPoint 小数点后几位数 * @param editTexts */public static void setEditTextLimit(final int frontPoint, final int behindPoint, final EditText... editTexts) &#123; if (editTexts != null &amp;&amp; editTexts.length &gt; 0) &#123; for (final EditText editText : editTexts) &#123; editText.addTextChangedListener(new TextWatcher() &#123; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() == frontPoint + 1 &amp;&amp; !s.toString().contains(".")) &#123; editText.setText(s.toString().substring(0, frontPoint)); editText.setSelection(frontPoint); &#125; if (editText.getText().toString().indexOf(".") &gt;= 0) &#123; if (editText.getText().toString().indexOf(".", editText.getText().toString().indexOf(".") + 1) &gt; 0) &#123; editText.setText(editText.getText().toString().substring(0, editText.getText().toString().length() - 1)); editText.setSelection(editText.getText().toString().length()); &#125; &#125; if (s.toString().contains(".")) &#123; if (s.length() - 1 - s.toString().indexOf(".") &gt; behindPoint) &#123; s = s.toString().subSequence(0, s.toString().indexOf(".") + behindPoint+1); editText.setText(s); editText.setSelection(s.length()); &#125; &#125; //直接输入一个点,显示0. if (s.toString().trim().substring(0).equals(".")) &#123; s = "0" + s; editText.setText(s); editText.setSelection(2); &#125; //当输入一个0,后面只能输入小数点 if (s.toString().startsWith("0") &amp;&amp; s.toString().trim().length() &gt; 1) &#123; if (!s.toString().substring(1, 2).equals(".")) &#123; editText.setText(s.subSequence(0, 1)); editText.setSelection(1); return; &#125; &#125; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;&#125; xml别忘了 1android:inputType="numberDecimal"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传,角度不正确]]></title>
    <url>%2F2015%2F08%2F08%2F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E8%A7%92%E5%BA%A6%E4%B8%8D%E6%AD%A3%E7%A1%AE%2F</url>
    <content type="text"><![CDATA[部分机型（三星）的上传后,图片是默认旋转了90° 解决问题 直接进入正题 当我们上传图片需要做的处理 压缩 判断角度是否正确 如果不角度不对,纠正角度 其他(加水印什么的看具体需求) 解决以下代码块​ /** * 压缩图片，处理某些手机拍照角度旋转的问题 * @param context * @param filePath * @param file * @param q * @return * @throws FileNotFoundException */ public static File compressImage(Context context, String filePath, File file, int q) throws FileNotFoundException { Bitmap bm = getSmallBitmap(filePath); int degree = readPictureDegree(filePath); LogUtil.e(&quot;fengan&quot;, &quot;degree==&quot; + degree); if (degree != 0) {//旋转照片角度 bm = rotateBitmap(bm, degree); } FileOutputStream out = new FileOutputStream(file); bm.compress(Bitmap.CompressFormat.JPEG, q, out); return file; }` /** * 获取图片角度 * @param path * @return */ public static int readPictureDegree(String path) { int degree = 0; try { ExifInterface exifInterface = new ExifInterface(path); int orientation = exifInterface.getAttributeInt( ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) { case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; } } catch (IOException e) { e.printStackTrace(); } return degree; } /** * 旋转照片 * @param bitmap * @param degress * @return */ public static Bitmap rotateBitmap(Bitmap bitmap, int degress) { if (bitmap != null) { Matrix m = new Matrix(); m.postRotate(degress); bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m, true); return bitmap; } return bitmap; } /** * 根据路径获得突破并压缩返回bitmap用于显示 * * @return */ public static Bitmap getSmallBitmap(String filePath) { final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, 480, 800); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝你今天心情愉快]]></title>
    <url>%2F2015%2F08%2F08%2F%E7%A5%9D%E4%BD%A0%E4%BB%8A%E5%A4%A9%E5%BF%83%E6%83%85%E6%84%89%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
