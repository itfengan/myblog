<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析Dalvik和ART的区别]]></title>
    <url>%2F2018%2F03%2F05%2F%E6%B5%85%E6%9E%90Dalvik%E5%92%8CART%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Dalvik是Google公司自己设计用于Android平台的虚拟机，Dalvik经过优化，更加适合Android平台（具体优点见下面和JVM比较）。 2014年6月谷歌I/O大会上，Android L(5.0)改动幅度比较大，删除了Dalvik，而是用ART代替。 之前对本块的知识理解比较零散，再此本文总结下Dalvik和ART的原理，和二者的区别，以及Jvm和Dalvik的区别，以及Android的Apk编译打包的流程 Dalvik的相关知识 Google公司自己设计用于Android平台的java虚拟机 支持.dex（即Dalvik Executable）格式的java应用程序运行 基于寄存器，寄存器CPU的一部分（适合内存和处理器有限的系统） 允许有限的内存同时运行多个Dalvik虚拟机的实例 每个Dalvik应用作为一个独立的Linux进程执行，防止一个程序崩溃导致所有程序崩溃 Jvm的相关知识 基于栈（内存的一部分） javac把程序源码编译成JAVA字节码后，JVM通过逐条解释字节码翻译成机器指令 Dalvik和Jvm的区别与联系图表区别 本质 字节码文件 效率 Dalvik 基于寄存器 一个.Dex文件 高 Jvm 基于栈 多个.class文件 低 首要区别 DVM基于寄存器，Jvm基于栈，基于寄存器的编译花费时间更短（在.dex字节码中，变量会赋值给65535个可用寄存器中的任何一个，Dalvik指令直接操作这些寄存器，而不是访问堆栈中的元素。） dex字节码更适合于内存和处理器速度有限的系统 基于寄存器的Dalvik实现虽然牺牲了一些平台无关性，但是它在代码的执行效率上要更胜一筹。 每一个Android 的App是独立跑在一个VM中的。因此一个App crash只会影响到自身的VM，不会影响到其他。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个 Dalvik应用作为一个独立的Linux进程执行。 字节码区别 JVM字节码由.class组成，每个java文件对应一个.class DVM字节码只包含一个.dex文件，这个文件包含了程序中所有的类 Dalvik可执行文件体积小。Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码。 简单来讲，dex格式文件就是将多个class文件中公有的部分统一存放，去除冗余信息。 ART的相关知识（Android Runtime）Android Runtime（缩写为 ART），是一种在Android操作系统上的运行环境，由Google公司研发，并在2013年作为Android 4.4系统中的一项测试功能正式对外发布，在Android 5.0及后续Android版本中作为正式的运行时库取代了以往的Dalvik虚拟机。ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机。它与Dalvik的主要不同在于：Dalvik采用的是JIT技术，而ART采用Ahead-of-time（AOT）技术。 ART同时也改善了性能、垃圾回收(Garbage Collection)、应用程序除错以及性能分析。 JIT最早在Android 2.2系统中引进到Dalvik虚拟机中，在应用程序启动时，JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作。 与Dalvik虚拟机不同的是，ART引入了AOT这种预编译技术，在应用程序安装的过程中，ART就已经将所有的字节码重新编译成了机器码。应用程序运行过程中无需进行实时的编译工作，只需要进行直接调用。因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升。 为了保证向下兼容，ART使用了相同的Dalvik字节码文件（dex），即在应用程序目录下保留了dex文件供旧程序调用然而.odex文件则替换成了可执行与可链接格式（ELF）可执行文件。一旦一个程序被ART的dex2oat命令编译，那么这个程序将会指通过ELF可执行文件来运行。因此，相对于Dalvik虚拟机模式，ART模式下Android应用程序的安装需要消耗更多的时间，同时也会占用更大的储存空间（指内部储存，用于储存编译后的代码）,但节省了很多Dalvik虚拟机用于实时编译的时间。 Google公司在Android 4.4中带来的ART模式仅仅是ART的一个预览版，系统默认仍然使用的是Dalvik虚拟机，4.4上面提供的预览版ART相对于Android 5.0以后的ART运行时库有较大的不同，尤其体现在兼容性上。 总结一下上诉内容： Android 4.4系统后出现（预览版），系统默认仍然使用的是Dalvik虚拟机，5.0以后是正式版取代了Dalvik虚拟机 ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机 为了保证向下兼容，ART使用了相同的Dalvik字节码文件（dex）（而在安装过程中，会通过dex2oat工具生成OAT文件，具体见下面分析） Android运行时ART加载OAT文件过程分析查看其他博客分析 ART核心是OAT文件 是APK在安装的过程中，会通过dex2oat工具生成一个OAT文件 APK安装过程中生成的OAT文件的输入只有一个DEX文件，也就是来自于打包在要安装的APK文件里面的classes.dex文件（实际上，一个OAT文件是可以由若干个DEX生成的） OAT文件是一种Android私有ELF 它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容 Dalvik和ART的区别与联系 Dalvik和ART使用的的都是.dex字节码，事实上我们把apk解压后确实只有classes.dex文件，但是在ART虚拟机在安装过程中通过dex2oat工具将一个或者诺干个dex生成一个OAT文件 ART（Ahead-of-time AOT预编译技术）：应用程序在安装过程中，ART将所有的字节码重新编译成了机器码，所以应用程序运行中无需进行实时编译工作，只需要进行直接调用，因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升，但是安装需要更多的内存空间（存储编译后的代码）和时间，节省了很多Dalvik虚拟机用于实时编译的时间 Dalvik（Just-in-time JIT即时编译技术）：（jvm也是JIT即时编译），在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行。虽然安装过程比较快，但是拖慢了应用每次启动的速度 编译技术 （时机）字节码编译机器码 占用空间 安装时间 运行效率（） Dalvik JIT（即时编译） 首次安装时 小 快 慢 ART AOT（预编译技术） 应用每次启动时 大（10-20%） 满 快 几张截图总结查看原文]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal的理解]]></title>
    <url>%2F2018%2F03%2F02%2FThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是ThreadLocalJDK1.2提供 根据JDK文档中的解释： ThreadLocal的作用是提供线程内的局部变量，这种变量在多线程环境下访问时能够保证各个线程里变量的独立性。 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立改变该变量的副本，而不会影响其他线程所对应的副本。 ThreadLocal的使用： 可以看到我们用ThreadLocal存放了一个String字符串，在不同的线程set数值后，只在当前线程管用，所以说，如同上述所说的 一个ThreadLocal可以被多个线程共享 每个线程对同一个ThreadLocal的set get操作只针对当前线程管用 ThreadLocal的原理以及源码介绍大概了解了ThreadLocal如何使用，那么请问，ThreadLocal如何保证不同线程的独立性的呢？ ThreadLocal几个内部方法protected T initialValue()（如果不想初始值返回null，需要重写initialValue方法）123protected T initialValue() &#123; return null;&#125; public T get()（该方法返回当前线程变量副本。如果这是线程第一次调用该方法，则创建并初始化此副本。）/** 1234567891011121314151617 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; public void set(T value)/** 12345678910111213141516 * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 由get和set源码可以看出，数据的存取都是先获取ThreadLocalMap对象，从ThreadLocalMap存取 ThreadLocalMap是一个map，它的key，就是threadLocal本身，值就是存放的变量副本 每个线程对应一个本地变量的map，每个可以存放多个线程本地变量（即不同的ThreadLocal） public void remove()（jdk1.5后出现）/** 123456789101112131415* Removes the current thread's value for this thread-local* variable. If this thread-local variable is subsequently* &#123;@linkplain #get read&#125; by the current thread, its value will be* reinitialized by invoking its &#123;@link #initialValue&#125; method,* unless its value is &#123;@linkplain #set set&#125; by the current thread* in the interim. This may result in multiple invocations of the* &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.** @since 1.5*/public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 通过remove源码可以看到， 先通过ThreadLocal的getMap（Thread.currentThread()）方法拿到当前线程的ThreadLocalMap 然后再在当前线程的ThreadLocalMap中get，set，remove 关于remove需要知道的几点： 为什么移除某个ThreadLocal的值： 目的是减少内存缓存，remove之后如果再次访问此线程局部变量的值，将返回initiValue初始值 线程结束后，该线程对应的所有局部变量将自动被垃圾回收，但是显示调用remove清楚线程局部变量不是必须操作，但是可以加快内存回收的速度 ThreadLocal和同步机制synchonzied的区别 ThreadLocal：以空间换时间 synchonzied：以时间换空间 synchonzied同步机制： 为多线程对相同资源的并发访问控制，保证了多线程之间的数据共享，同步会带来巨大的性能开销，所以同步操作应该是细粒度的（对象中的不同元素使用不同的锁，而不是整个对象一个锁），以时间换空间的意思是：使用同步真正的风险是复杂性和可能破坏资源安全,而不是性能。 ThreadLocal线程局部变量机制： 空间换取时间，不同线程访问同一ThreadLocal，数据的存取是当前线程的数据副本，也就是说不同线程在某一时间访问到的并不是同一对象，所以效率比较高，但是占用内存比较大，当线程结束之后，remove会加快内存的回收速度。 Synchronized着重于线程间的数据共享，而ThreadLocal则着重于线程间的数据隔离。 ThreadLocal的弊端（内存泄露）内存泄露原因ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部的强引用，那么在系统GC的时候，这个ThreadLocal就会被回收掉 ThreadLocal被回收掉之后，那么当前Thread的ThreadLocalMap中间就会出现key为null的Entry key为null的话就意味着，没有办法访问这些key对应的值，就会存在以下的这样一个强引用链 value —Entry—TreadLocalMap–Thread 内存泄露解决ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。 以下操作会导致内存泄露 使用static的ThreadLocal，延长了ThreadLocal的生命周期，导致某个线程Thread结束后，但是Thread内部的ThreadLocalMap中存在这个静态的ThreadLocal，导致ThreadLocalMap没法被回收，导致该Thread没法被回收 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。因为如上所说 get(),set(),remove()会清理线程ThreadLocalMap里所有key为null的value Android中ThreadLocal的体现Handler消息机制熟悉Handler机制的都知道 在ActivityThread的main方法中Looper.prepareMainLooper();或者在自己创建的线程中Looper.pepare()的时候 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 创建了一个Looper对象并使用sThreadLocal的set方法进行保存 并且这个ThreadLocal在Looper类中是静态的，如下 那就是说，这个静态的ThreadLocal，可以供任何线程访问，但是任意线程中取出来的looper，都只是线程局部变量，都是在副本 所以说，每个线程对应一个looper， 对于ThreadLocal的总结，暂时整理到这里，后续补充 ♨]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈启动流程]]></title>
    <url>%2F2017%2F12%2F29%2F%E8%B0%88%E8%B0%88%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative start]]></title>
    <url>%2F2017%2F12%2F25%2FReactNative%20start%2F</url>
    <content type="text"><![CDATA[ReactNative start 1，为什么学习ReactNative好处 因为现在许多主流的应用都有React Native的影子，它对比原生开发更为灵活，对比H5体验更为高效，而且跨平台的支持特性。 相对ionic这类PhoneGap，它效率更高，和原生之间的交互更方便。 多个版本迭代后的今天，它已经拥有了丰富第三方插件支持。 React Native解决不了的，可以通过各位熟悉的原生来解决。 更方便的热更新。 坏处 尽管是跨平台，但是不同平台Api的特性与显示并不一定一致。 相对增大了app的体积。 调试’相对‘麻烦。 Android上的兼容性问题。 总的来说React Native适合作为项目中的补充，而不是作为核心去开发APP。 2，搭建开发环境 Webstrom（号称web开发神器，目前对前端的了解有限，因为和android stuido师出同门，所以不商量直接选用他，当然stom也试了试，但是快捷键不如Webstrom熟悉） HomeBrew（Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件 Node（基于 Chrome V8 引擎的 JavaScript 运行环境） Androd Studio（安卓老本家没啥说的） ReactNative的命令行工具（react-native-cli，React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务 详细搭建步骤查看ReactNative中文网 一步一步安装完毕后，没错，你已经起飞了； 3，创建一个项目 终端cd到你想初始化项目的文件夹 1react-native init FirstRNApp 然后会发现创建了一个FirstRNApp文件夹，这就是创建的第一个项目 几个关键的文件 android文件夹，就是一个可以用android studio打开的android项目。 ios文件夹，是一个可以用xcode打开的ios项目。 index.android.js，这是android的React Native入口文件。 index.ios.js，这是ios的React Native入口文件。 package.json，类似android studio的build.gradle，你依赖的库都写在里面。 node_module文件夹，你依赖的库下载下来都存放在里面，属于git的忽略文件，你要找的依赖库源码也在里面，包括React和React Native。 jscode文件夹，是自己创建的文件夹，用来存放自己写的js文件。 需要注意的点package.json 类似于android studio中的build.gradle添加远程依赖，不同的是，package.json大多数时候不需要我们手动添加，我们只需要在根目录通过命令行，npm install xxxxxx --save 就可以依赖一个库了。 install之后，库的依赖信息，自动被写到package.json里面，对应的库也会被下载到node_module文件夹中，类似android studio依赖后把aar同步到本地。 node_module node_module是一个忽略文件，提交的时候不需要提交到git上，类似android studio远程依赖下来的aar，也不会提交到git上。其他人在使用React Native项目时，只需要npm install，工程就会根据package.json，去同步下载各个依赖库到node_module。 注：有时候还需要运行react-native link 或 react-native link xxx，这是因为有些第三方库是通过原生代码加React Native实现的，通过这个命令，可以自动把相关的配置代码，自动添加到android和ios工程中。 运行这个项目作为安卓端有两种方式，ios也同样有两种 cd到项目根目录 1react-native run-android【react-native run-ios】 或者用android stuido直接打开项目中的android文件夹（上面有说过，这是一个可以独立打开的安卓项目） 遇到的小坑1，无法从资产的index.android.bundle中加载脚本。确保你的包被正确打包或者你正在运行一个packager服务器 搜索了一波，这个错误很常见，解决的办法也很常见，如下 打开自己的项目文件夹,在Android/app/src/main目录下创建一个空的assets文件夹 cd到项目根目录，执行 1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res 事实证明并没有解决我的问题 解决我的问题的是下面这行 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res 我们可以回头看上面创建完项目的截图，老版的是分别有index.android.js和index.ios.js 而我创建的却没有这两个文件，只有一个index.js,修改完之后，我们创建的assets目录下会生成bundle的两个文件 运行成功（android端） 相关资料 [恋猫月亮博客]https://www.jianshu.com/p/97692b1c451d) 中文网 报错 本文仅作个人学习总结，如有出入不够严谨的地方，请联系更改。 ReactNative才刚刚起步学习，麻烦和坑后续还会经常碰到。但是，既然选择了学习，就要坚持下来！]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈加密算法]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%B0%88%E8%B0%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[谈谈加密算法 前言 在应用开发的过程中，客户端和移动端要频繁的进行数据传输，涉及到重要隐私信息的时候，就需要进行数据加密，，即使传输的过程中被截取，也不会信息泄漏。对于加密算法，不少开发者也早有耳闻，例如：Base64，MD5，RSA，AES，DES加密等等，今天就总结一下加密算法 对称加密和非对称加密对称加密：对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。 对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。 非对称加密：非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。 目前最常用的非对称加密算法是RSA算法，是Rivest, Shamir, 和Adleman于1978年发明 对称加密和非对称加密虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密使用的密钥用非对称加密，参考网上，看下面的一个例子： 铁头需要在银行的网站上做一笔交易，他的游览器生成了一个随机数作为对称密钥 铁头的游览器向银行请求非对称加密的公钥 银行将公钥发送给铁头 铁头用这个公钥将自己的对称密钥进行加密 铁头将加密后的对称密钥发送给银行 银行用非对称加密的私有密钥对这个对称密钥进行解密获取到铁头的对称密钥 铁头与银行可以使用对称密钥来对沟通的内容进行加密与解密了。 对称和非对称加密总结 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。 非对称加密例子 RSA（参考这里） 对称加密例子 AES（参考这里） 项目中除了登陆，支付等接口采用rsa非对称加密，之外的采用aes对称加密 高级加密标准（英语：Advanced Encryption Standard，缩写：AES） 这个标准用来替代原先的DES DES（参考这里） DES加密算法出自IBM 近些年使用越来越少 DES使用56位密钥，以现代计算能力，24小时内即可被破解。 AES和DES对比 AES安全性、效率、灵活性要高于DES 对称加密优先采用AES 其他加密 MD5 特点：单向加密算法，是不可逆的一种的加密方式 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 加大MD5安全性 进行多次MD5加密 MD5加盐 用string明文的hashcode作为盐，然后进行MD5加密 随机生成一串字符串作为盐，然后进行MD5加密 Base64 平时开发中遇见的各种数据加密方式，最终都会对加密后的二进制数据进行Base64编码，起到一种二次加密的效果 其实呢Base64从严格意义上来说的话不是一种加密算法，而是一种编码算法 更多 所以，在客户端和服务端数据传送加密，最多使用的是非对称RSA和对称AES，参考这里]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字的作用]]></title>
    <url>%2F2017%2F03%2F15%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 transient的作用及使用方法，官方解释： 1Variables may be marked transient to indicate that they are not part of the persistent state of an object. 遇到问题 我们都知道一个对象只要实现了Serializable接口，这个对象就可以被序列化，那么在实际开发过程中，可能会遇到这样的问题，这个类的有些属性需要序列号，而其他属性不需要序列化，比如说：一个用户有一些敏感信息，比如密码或者银行卡号之类，为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 解决问题 再次之前，有一个姿势点： 父类序列化 一个情景：一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，序列化该子类对象，然后反序列化后，输出父类定义的某变量的数值，该变量数值与序列化前不同 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 特性使用案例 我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化 上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。 参考： java学习—序列化与Transient关键字 Transient关键字使用场景]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 阴影布局(继承FrameLayout)]]></title>
    <url>%2F2017%2F03%2F15%2FAndroid-%E9%98%B4%E5%BD%B1%E5%B8%83%E5%B1%80-%E7%BB%A7%E6%89%BFFrameLayout%2F</url>
    <content type="text"><![CDATA[阴影布局(继承FrameLayout)前言：很多情况下，美腻的UI美眉喜欢搞一些花里胡哨阴影什么的,作为一名有追求的程序员迎合美眉的需求，搞一些小阴影并不是什么大问题，比如写一个自定义shape，用5.0的ｚ轴新特性和CardView都可以满足的，但是有些效果不太符合预计设计的效果，像自定义shape作为背景，看起来阴影会有些假，用５．０新特性第一个是版本问题还一个是有时候不起作用，网上也有解决不起作用的方法，我试了，都不太起作用，用cardview的话，如果cardview包裹的太多太复杂的控件，效果也不是太明显，所以有一个自定义FrameLayout来自己画阴影，以后再碰见阴影就又多了一种手段，满足应付设计师 https://github.com/itfengan/xShadowLayout 效果图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267package fengan.shadowdemo;/** * Created by fengan on 2017/10/10/010. */import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BlurMaskFilter;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.Rect;import android.support.annotation.FloatRange;import android.util.AttributeSet;import android.widget.FrameLayout;/** * Created by fengan on 10.10.2017. */public class ShadowLayout extends FrameLayout &#123; // Default shadow values private final static float DEFAULT_SHADOW_RADIUS = 30.0F; private final static float DEFAULT_SHADOW_DISTANCE = 15.0F; private final static float DEFAULT_SHADOW_ANGLE = 45.0F; private final static int DEFAULT_SHADOW_COLOR = Color.DKGRAY; // Shadow bounds values private final static int MAX_ALPHA = 255; private final static float MAX_ANGLE = 360.0F; private final static float MIN_RADIUS = 0.1F; private final static float MIN_ANGLE = 0.0F; // Shadow paint private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG) &#123; &#123; setDither(true); setFilterBitmap(true); &#125; &#125;; // Shadow bitmap and canvas private Bitmap mBitmap; private final Canvas mCanvas = new Canvas(); // View bounds private final Rect mBounds = new Rect(); // Check whether need to redraw shadow private boolean mInvalidateShadow = true; // Detect if shadow is visible private boolean mIsShadowed; // Shadow variables private int mShadowColor; private int mShadowAlpha; private float mShadowRadius; private float mShadowDistance; private float mShadowAngle; private float mShadowDx; private float mShadowDy; public ShadowLayout(final Context context) &#123; this(context, null); &#125; public ShadowLayout(final Context context, final AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ShadowLayout(final Context context, final AttributeSet attrs, final int defStyleAttr) &#123; super(context, attrs, defStyleAttr); setWillNotDraw(false); setLayerType(LAYER_TYPE_HARDWARE, mPaint); // Retrieve attributes from xml final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ShadowLayout); try &#123; setIsShadowed(typedArray.getBoolean(R.styleable.ShadowLayout_fengan_shadowed, true)); setShadowRadius( typedArray.getDimension( R.styleable.ShadowLayout_fengan_shadow_radius, DEFAULT_SHADOW_RADIUS ) ); setShadowDistance( typedArray.getDimension( R.styleable.ShadowLayout_fengan_shadow_distance, DEFAULT_SHADOW_DISTANCE ) ); setShadowAngle( typedArray.getInteger( R.styleable.ShadowLayout_fengan_shadow_angle, (int) DEFAULT_SHADOW_ANGLE ) ); setShadowColor( typedArray.getColor( R.styleable.ShadowLayout_fengan_shadow_color, DEFAULT_SHADOW_COLOR ) ); &#125; finally &#123; typedArray.recycle(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); // Clear shadow bitmap if (mBitmap != null) &#123; mBitmap.recycle(); mBitmap = null; &#125; &#125; public boolean isShadowed() &#123; return mIsShadowed; &#125; public void setIsShadowed(final boolean isShadowed) &#123; mIsShadowed = isShadowed; postInvalidate(); &#125; public float getShadowDistance() &#123; return mShadowDistance; &#125; public void setShadowDistance(final float shadowDistance) &#123; mShadowDistance = shadowDistance; resetShadow(); &#125; public float getShadowAngle() &#123; return mShadowAngle; &#125; @SuppressLint("SupportAnnotationUsage") @FloatRange public void setShadowAngle(@FloatRange(from = MIN_ANGLE, to = MAX_ANGLE) final float shadowAngle) &#123; mShadowAngle = Math.max(MIN_ANGLE, Math.min(shadowAngle, MAX_ANGLE)); resetShadow(); &#125; public float getShadowRadius() &#123; return mShadowRadius; &#125; public void setShadowRadius(final float shadowRadius) &#123; mShadowRadius = Math.max(MIN_RADIUS, shadowRadius); if (isInEditMode()) return; // Set blur filter to paint mPaint.setMaskFilter(new BlurMaskFilter(mShadowRadius, BlurMaskFilter.Blur.NORMAL)); resetShadow(); &#125; public int getShadowColor() &#123; return mShadowColor; &#125; public void setShadowColor(final int shadowColor) &#123; mShadowColor = shadowColor; mShadowAlpha = Color.alpha(shadowColor); resetShadow(); &#125; public float getShadowDx() &#123; return mShadowDx; &#125; public float getShadowDy() &#123; return mShadowDy; &#125; // Reset shadow layer private void resetShadow() &#123; // Detect shadow axis offset mShadowDx = (float) ((mShadowDistance) * Math.cos(mShadowAngle / 180.0F * Math.PI)); mShadowDy = (float) ((mShadowDistance) * Math.sin(mShadowAngle / 180.0F * Math.PI)); // Set padding for shadow bitmap final int padding = (int) (mShadowDistance + mShadowRadius); setPadding(padding, padding, padding, padding); requestLayout(); &#125; private int adjustShadowAlpha(final boolean adjust) &#123; return Color.argb( adjust ? MAX_ALPHA : mShadowAlpha, Color.red(mShadowColor), Color.green(mShadowColor), Color.blue(mShadowColor) ); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // Set ShadowLayout bounds mBounds.set( 0, 0, MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.getSize(heightMeasureSpec) ); &#125; @Override public void requestLayout() &#123; // Redraw shadow mInvalidateShadow = true; super.requestLayout(); &#125; @Override protected void dispatchDraw(final Canvas canvas) &#123; // If is not shadowed, skip if (mIsShadowed) &#123; // If need to redraw shadow if (mInvalidateShadow) &#123; // If bounds is zero if (mBounds.width() != 0 &amp;&amp; mBounds.height() != 0) &#123; // Reset bitmap to bounds mBitmap = Bitmap.createBitmap( mBounds.width(), mBounds.height(), Bitmap.Config.ARGB_8888 ); // Canvas reset mCanvas.setBitmap(mBitmap); // We just redraw mInvalidateShadow = false; // Main feature of this lib. We create the local copy of all content, so now // we can draw bitmap as a bottom layer of natural canvas. // We draw shadow like blur effect on bitmap, cause of setShadowLayer() method of // paint does`t draw shadow, it draw another copy of bitmap super.dispatchDraw(mCanvas); // Get the alpha bounds of bitmap final Bitmap extractedAlpha = mBitmap.extractAlpha(); // Clear past content content to draw shadow mCanvas.drawColor(0, PorterDuff.Mode.CLEAR); // Draw extracted alpha bounds of our local canvas mPaint.setColor(adjustShadowAlpha(false)); mCanvas.drawBitmap(extractedAlpha, mShadowDx, mShadowDy, mPaint); // Recycle and clear extracted alpha extractedAlpha.recycle(); &#125; else &#123; // Create placeholder bitmap when size is zero and wait until new size coming up mBitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.RGB_565); &#125; &#125; // Reset alpha to draw child with full alpha mPaint.setColor(adjustShadowAlpha(true)); // Draw shadow bitmap if (mCanvas != null &amp;&amp; mBitmap != null &amp;&amp; !mBitmap.isRecycled()) canvas.drawBitmap(mBitmap, 0.0F, 0.0F, mPaint); &#125; // Draw child`s super.dispatchDraw(canvas); &#125;&#125; 布局文件 1234567891011121314151617181920212223242526272829303132 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="fengan.shadowdemo.MainActivity"&gt; &lt;fengan.shadowdemo.ShadowLayout android:layout_width="wrap_content" android:layout_height="wrap_content" app:fengan_shadowed="true" app:fengan_shadow_angle="45" android:layout_centerInParent="true" app:fengan_shadow_radius="6dp" app:fengan_shadow_distance="10dp" app:fengan_shadow_color="#883F51B5"&gt; &lt;TextView android:layout_width="250dp" android:layout_height="250dp" android:background="@drawable/bg" android:gravity="center" android:text="Hello World!" android:textColor="#ffffff" android:textSize="19sp"/&gt; &lt;/fengan.shadowdemo.ShadowLayout&gt;&lt;/RelativeLayout&gt; 自定义属性ａｔｔｒｓ．ｘｍｌ123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="ShadowLayout"&gt; &lt;attr name="fengan_shadowed" format="boolean"/&gt; &lt;attr name="fengan_shadow_distance" format="dimension"/&gt; &lt;attr name="fengan_shadow_angle" format="integer"/&gt; &lt;attr name="fengan_shadow_radius" format="dimension"/&gt; &lt;attr name="fengan_shadow_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 有灵性的哥哥们，已经猜到这些属性对应的意思啦．．．在此整理方便大家日后使用．．．]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sources for ‘Android API xx Platform’ not found]]></title>
    <url>%2F2017%2F03%2F13%2FSources-for-%E2%80%98Android-API-xx-Platform%E2%80%99-not-found%2F</url>
    <content type="text"><![CDATA[前言 在Android Studio翻源码多时候，明明下载了对应的SDK，却点进去都是.class看不到源码，本文记录一下解决办法 首先确保下载了对应的SDK 找到以下路径，并打开文件 ~/Library/Preferences/AndroidStudioXXX/options/jdk.table.xml 修改前 修改后 重启AS]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview使用总结]]></title>
    <url>%2F2017%2F03%2F12%2FWebview%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[WebView使用总结前言： 最近，修改了项目中网页中点击图片跳转查看大图页面的需求，激发了我归纳总结WebView的想法，今天再次整理一下。 包含：使用过程，关键类，js交互，注意事项，以及几个常见的需求解决思路等。 献上一张框架图 基本简介内核在4.4以前的版本是WebKit的内核，4.4以后才换成chromium的内核 可使用第三方WebView组件Crosswalk和TBS服务，具体区别后面再整理 作用 显示和渲染web页面 直接加载Html文件（网络或者本地asserts） 与js互调 状态 webView.onResume() ； 激活WebView为活跃状态，能正常执行网页的响应 webView.onPause()； 当页面被失去焦点被切换到后台不可见状态，需要执行onPause，通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。 webView.pauseTimers() Webview后台耗电的问题 当应用程序(存在webview)被切换到后台时，需要暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。 可以调用此方法 webView.resumeTimers() 恢复pauseTimers状态 注意： 由于pauseTimers和resumeTimers是全局生效的, 并不只影响单个WebView, resumeTimers注意不要遗漏, 否则遗漏的WebView会出现异常. 最好在重写的WebView rootLayout.removeView(webView); webView.destroy(); 销毁Webview，在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview 但是注意：webview调用destory时,webview仍绑定在Activity上 这是由于自定义webview构建时传入了该Activity的context对象 因此需要先从父容器中移除webview,然后再销毁webview: 前进回退网页 Webview.canGoBack() 是否可以后退 Webview.goBack() 后退网页 Webview.canGoForward() 是否可以前进 Webview.goForward() 前进网页 Webview.goBackOrForward(intsteps) 以当前的index为起始点前进或者后退到历史记录中指定的steps 如果steps为负数则为后退，正数则为前进 常见用法： 问题 在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身 目标 点击返回后，是网页回退而不是推出浏览器 解决方案 在当前Activity中处理并消费掉该 Back 事件 1234567public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123; mWebView.goBack(); return true; &#125; return super.onKeyDown(keyCode, event);&#125; 常用类WebSettings12345678910111213141516171819202122232425262728293031//声明WebSettings子类WebSettings webSettings = webView.getSettings();//如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持插件webSettings.setPluginsEnabled(true); //设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小//缩放操作webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件//其他细节操作webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存 webSettings.setAllowFileAccess(true); //设置可以访问文件 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式//优先使用缓存: webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //缓存模式如下： //LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 //LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。 //LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. //LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。 常见缓存用法 123456789101112if (NetStatusUtil.isConnected(getApplicationContext())) &#123; webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//根据cache-control决定是否从网络上取数据。&#125; else &#123; webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//没网，则从本地获取，即离线加载&#125;webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能webSettings.setDatabaseEnabled(true); //开启 database storage API 功能webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;webSettings.setAppCachePath(cacheDirPath); //设置 Application Caches 缓存目录 每个 Application 只调用一次 WebSettings.setAppCachePath()，WebSettings.setAppCacheMaxSize() WebViewClient主要辅助WebView处理各种通知、请求事件12345678910111213141516171819202122232425262728293031323334353637383940new WebViewClient()&#123;// 使得打开网页时不调用系统浏览器， 而是在本WebView中显示 @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; return super.shouldOverrideUrlLoading(view, request); &#125;// 开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。 @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); &#125;// 在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。 @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); &#125;// 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 @Override public void onLoadResource(WebView view, String url) &#123; super.onLoadResource(view, url); &#125;// 该方法传回了错误码，根据错误类型可以进行不同的错误分类处理 @Override public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123; super.onReceivedError(view, request, error); &#125;// webView默认是不处理https请求的，页面显示空白，需要进行如下设置： @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;// super.onReceivedSslError(view, handler, error); handler.proceed(); //表示等待证书响应 // handler.cancel(); //表示挂起连接，为默认方式 // handler.handleMessage(null); //可做其他处理 &#125; &#125;; WebChromClient辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。 获得网页的加载进度并显示 12345678910webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; if (newProgress &lt; 100) &#123; String progress = newProgress + "%"; progress.setText(progress); &#125; else &#123; &#125; &#125;); onReceivedTitle（） 123456webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onReceivedTitle(WebView view, String title) &#123; titleview.setText(title)； &#125; JS交互原文 Android调Js 使用建议 两种方法混合使用，即Android 4.4以下使用方法1，Android 4.4以上方法2 12345678910111213// Android版本变量final int version = Build.VERSION.SDK_INT;// 因为该方法在 Android 4.4 版本才可使用，所以使用时需进行版本判断if (version &lt; 18) &#123; mWebView.loadUrl("javascript:callJS()");&#125; else &#123; mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;);&#125; 通过loadUrl方式调用jsHtml代码 12345678910111213141516171819// 文本名：javascript&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Carson_Ho&lt;/title&gt;// JS代码 &lt;script&gt;// Android需要调用的方法 function callJS()&#123; alert("Android调用了JS的callJS方法"); &#125;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; Android代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 设置与Js交互的权限 webSettings.setJavaScriptEnabled(true); // 设置允许JS弹窗 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); // 先载入JS代码 // 格式规定为:file:///android_asset/文件名.html mWebView.loadUrl("file:///android_asset/javascript.html"); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 必须另开线程进行JS方法调用(否则无法调用) mWebView.post(new Runnable() &#123; @Override public void run() &#123; // 注意调用的JS方法名要对应上 // 调用javascript的callJS()方法 mWebView.loadUrl("javascript:callJS()"); &#125; &#125;); &#125; &#125;); // 由于设置了弹窗检验调用结果,所以需要支持js对话框 // webview只是载体，内容的渲染需要使用webviewChromClient类去实现 // 通过设置WebChromeClient对象处理JavaScript的对话框 //设置响应js 的Alert()函数 mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public boolean onJsAlert(WebView view, String url, String message, final JsResult result) &#123; AlertDialog.Builder b = new AlertDialog.Builder(MainActivity.this); b.setTitle("Alert"); b.setMessage(message); b.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; result.confirm(); &#125; &#125;); b.setCancelable(false); b.create().show(); return true; &#125; &#125;); &#125; 特别注意：JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。 onPageFinished()属于WebViewClient类的方法，主要在页面加载结束时调用 所以一般等onPageFnished回调之后，我们才显示H5的页面，加载未完全的时候，则显示loading页面 通过evaluateJavascript调用js优点 该方法比第一种方法效率更高、使用更简洁。 因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。 Android 4.4 后才可使用 12345678// 只需要将第一种方法的loadUrl()换成下面该方法即可 mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;);&#125; Js调Android 缓存问题原文 参考链接Carson_Ho]]></content>
      <categories>
        <category>webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析volatile关键字]]></title>
    <url>%2F2017%2F03%2F07%2F%E6%B5%85%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[前言 在看java并发的书的时候，看到了关于java的单例模式使用了volatile关键字，但是对volatile关键字的真正含义一直很模糊，本文就尝试浅析总结一下volatile的作用和具体用法。 单例模式中的volatile关键字查看原文 123456789101112131415public class TestInstance &#123; private volatile static TestInstance instance; public static TestInstance getInstance() &#123; //1 if (instance == null) &#123; //2 synchronized (TestInstance.class) &#123;//3 if (instance == null) &#123; //4 instance = new TestInstance();//5 &#125; &#125; &#125; return instance;//6 &#125;&#125; 在并发情况下，如果没有volatile关键字，在第5行会出现问题 instance = new TestInstance();//5 可以分解以下三部 1，申请内存 2，通过构造方法初始化对象 3，将对象指向申请的内存 但当A线程进行第五部初始化的时候，可能是因为构造函数里面的操作太多，所以A线程还没有初始化完毕，但已经被赋值了，也就是以上的顺序由1-2-3变成了1-3-2。此时B线程进来判断TestInstance不为null，错以为已经实例化完毕返回了一个未初始化的对象（因为构造函数未完全，初始设置值未完全的对象），就出问题了。如果声明称volatile，2和3步骤不会被排序 volatile的作用与特点通过上诉单例模式中volatile的使用，那么volatile关键字具体的作用到底是什么呢？ 首先看一张图 由上图，需要知道的几点 java内存模型规定了所有的变量都存储在主内存中 Java内存模型分为主内存，和工作内存 主内存是所有的线程所共享的，工作内存是每个线程自己有一个，不是共享的。 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝 线程对变量的所有操作（读取、赋值），都必须在工作内存中进行，而不能直接读写主内存中的变量 不同线程之间也无法直接访问对方工作内存中的变量 基于上诉的主内存和工作内存的描述，那么 volatile的作用： volatile赋予了变量可见——禁止编译器对成员变量进行优化，它修饰的成员变量在每次被线程访问时，都强迫从内存中重读该成员变量的值；而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存，这样在任何时刻两个不同线程总是看到某一成员变量的同一个值，这就是保证了可见性。 ​ 从网上看见了一篇博客可以很好的说明，我将相关部分截了个图如下： 多线程的三个特性相关文章 原子性（Atomicity） 1原子性是指一个原子操作在cpu中不可以暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。原子操作保证了原子性问题。 需要注意的是：i++不是原子操作： x++（包含三个原子操作）a.将变量x 值取出放在寄存器中 b.将将寄存器中的值+1 c.将寄存器中的值赋值给x 1synchronized块之间的操作也具备原子性 可见性(Visibility) 1可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。 有序性(Ordering) 1Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。（比如上述单例模式中对象初始化的顺序对另外一个线程来讲可能会错序） volatile和synchronized的区别和联系相关文章 用法上： synchronized往往作用于方法或代码块 volatile往往修饰变量。 实现机制： synchronized是利用锁实现互斥访问，多线程访问会阻塞 Volatile没有利用锁，而是利用内存共享，强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，多线程访问不回阻塞 区别： syncchronized不仅保证了可见性，还保证了原子性，因为只有获得锁对象的线程才能进入同步代码块，从而保证同步代码块的所有语句全部都能执行。多个线程争抢syncchronized锁对象的时候，会出现阻塞 volatile只保证了可见性，不能保证原子性，不可保证同步，多个线程同时访问不会发生阻塞 volatile关键字的正确使用（一句话概括volatile） 一个线程修改某个变量后，其他线程需要知道这个变量修改后的最新的值，此时就需要使用volatile，保证多线程访问的是主内存的值，而不是访问各自线程的工作内存的副本值（其实仍然访问的是副本值，只不过副本值有修改后立即刷新到主内存中）也就是说保证了线程的可见性，但是不能像syncchronized保证原子性，volatile没有利用锁的机制，多线程访问时不会发生阻塞，也就是说volatile修饰的变量可以保证在一个线程中修改的时候，其他线程可以继续访问，一旦该变量修改完毕，其他线程再获取的一定是修改后的最新的值 synchronized同步的死锁是怎么产生的多线程死锁案例： 什么是死锁： 多个线程同时被阻塞,它们中的一个或者全部都在等待某个资源被释放.由于线程被无限期地阻塞,因此程序不能正常运行 多线程相关知识]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全的CopyOnWriteArrayList]]></title>
    <url>%2F2017%2F02%2F16%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84CopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[前言 最近翻阅EventBus源码，在subscribe方法中，看到了CopyOnWriteArrayList这个类，一时竟不知其原理是什么，本文简要记录一下CopyOnWriteArrayList的相关介绍 先看一段EventBus的subscribe（）的代码 这段代码是EventBus中subscribe方法，里面涉及到了subscriptionsByEventType的遍历过程中按照优先级排序 关于EventBus的具体源码我将在后面会整理，这里我们只关注CopyOnWriteArrayList即可 可以看到，在遍历的过程中，调用了subscriptions.add(i,newSubscription)来按照优先级进行排序，我相信任何一个懂java的都知道如果使用普通Arraylist，都会报错（并发修改异常），那么我们下面来证实一下 不使用CopyOnWriteArrayList先写一段代码证明CopyOnWriteArrayList确实是线程安全的。 ReadThread.java 12345678910111213141516import java.util.List;public class ReadThread implements Runnable &#123; private List&lt;Integer&gt; list; public ReadThread(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (Integer ele : list) &#123; System.out.println("ReadThread:"+ele); &#125; &#125;&#125; WriteThread.java 1234567891011121314import java.util.List;public class WriteThread implements Runnable &#123; private List&lt;Integer&gt; list; public WriteThread(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; this.list.add(9); &#125;&#125; TestCopyOnWriteArrayList.java 123456789101112131415161718192021222324252627282930313233import java.util.Arrays;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class TestCopyOnWriteArrayList &#123; private void test() &#123; //1、初始化CopyOnWriteArrayList List&lt;Integer&gt; tempList = Arrays.asList(new Integer [] &#123;1,2&#125;); CopyOnWriteArrayList&lt;Integer&gt; copyList = new CopyOnWriteArrayList&lt;&gt;(tempList); //2、模拟多线程对list进行读和写 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); executorService.execute(new ReadThread(copyList)); executorService.execute(new WriteThread(copyList)); System.out.println("copyList size:"+copyList.size()); &#125; public static void main(String[] args) &#123; new TestCopyOnWriteArrayList().test(); &#125;&#125; 运行上面的代码，没有报出 java.util.ConcurrentModificationException 说明了CopyOnWriteArrayList并发多线程的环境下，仍然能很好的工作。 CopyOnWriteArrayList如何做到线程安全CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。 当有新元素加入的时候，如下图，创建新数组，并往新数组中加入一个新元素,这个时候，array这个引用仍然是指向原数组的。 当元素在新数组添加成功后，将array这个引用指向新数组。 CopyOnWriteArrayList的源码12345678910111213141516171819public boolean add(E e) &#123; //1、先加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //2、拷贝数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //3、将元素加入到新数组中 newElements[len] = e; //4、将array引用指向到新数组 setArray(newElements); return true; &#125; finally &#123; //5、解锁 lock.unlock(); &#125;&#125; 由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况：1、如果写操作未完成，那么直接读取原数组的数据；2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。 可见，CopyOnWriteArrayList的读操作是可以不用加锁的。 CopyOnWriteArrayList使用场景通过上面的分析，CopyOnWriteArrayList 有几个缺点：1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc 2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求； CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。 思想如上面的分析CopyOnWriteArrayList表达的一些思想：1、读写分离，读和写分开2、最终一致性3、使用另外开辟空间的思路，来解决并发冲突 参考文章： 1]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofit和动态代理]]></title>
    <url>%2F2017%2F02%2F07%2Fretrofit%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[简述动态代理在Retrofit的应用 动态代理 代理类在运行前不存在，运行时由程序动态生成的代理方式称为动态代理 关于RetrofitSquare公司的OkHttp简直是完美的一个网络请求库，而在其上又封装了一层的Retrofit库，使其调用Restful Api更方便 简述Retrofit调用流程因为本篇只是简述动态代理在Retrofit的使用，所以不过多总结Retrofit的详细使用，在上家公司的项目都网络层，用的retrofit，现在这家公司的项目因为刚开始是我独立开发，所以网络层框架我也是用的Retrofit，功能强大，详细使用，以后再总结 熟悉Retrofit使用的都对下面几个步骤比较熟悉了： 定义一个ApiService接口，通过注解可以标记请求方法，请求参数，以及添加的头信息 然后创建Retrofit对象，通过建造者模式设置BaseUrl等一些参数，通过Retrofit对象create一个你定义的接口对象 拿到接口对象调用具体的方法完成请求 具体的代码大概如下： 1234public interface ApiService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .build();ApiService service = retrofit.create(ApiService.class); 1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("fengan"); ApiService是如何产生的因为接口是不可以直接new出来的，那么ApiService是如何产生的呢？ ApiService service = retrofit.create(ApiService.class);方法内部到底做了什么？ 没错，就是动态代理 为了更好的理解动态代理，下面过一下简易版的Retrofit， a v1234567public interface Callback&lt;T&gt; &#123; void onSuccess(Object t); void onFailed(Exception e);&#125; 123456789 /** * 约定最后一个参数是callback */public interface GithubService &#123; @GET("users/&#123;user&#125;/repos") void list&lt;Repos&gt;(@Path("user") String user,Callback&lt;List&lt;Repo&gt;&gt; callback);&#125; 用到了两个注解，一个是方法注解，一个是参数注解 123456789@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface GET &#123; String value() default "";&#125; 123456789@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.PARAMETER)public @interface Path &#123; String value();&#125; Repo实体类是使用GsonFormat根据json自动生成的。现实使用中，我们在构建Retrofit过程传入GsonFactory Retrofit这个类应该是一个builder模式，里面可以设置baseUrl，姑且忽略其他所有参数。还有一个create方法 1234567891011121314151617181920212223public class Retrofit &#123; private String baseUrl; private Retrofit(Builder builder) &#123; this.baseUrl = builder.baseUrl; &#125; public &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; return null &#125; static class Builder &#123; private String baseUrl; Builder baseUrl(String host) &#123; this.baseUrl = host; return this; &#125; Retrofit build() &#123; return new Retrofit(this); &#125; &#125;&#125; 最关键的就是create这个方法了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; /** * 缓存中去 */ Object o = serviceMap.get(clazz); /** * 取不到则取构造代理对象 */ if (o == null) &#123; o = (T) Proxy.newProxyInstance(Retrofit.class.getClassLoader(), new Class[]&#123;clazz&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; final Callback&lt;?&gt; callback = (Callback&lt;?&gt;) args[args.length - 1]; final GET get = method.getAnnotation(GET.class); if (get != null) &#123; /** * 获得GET注解的值 */ String getValue = get.value(); System.out.println(getValue); /** * 获得所有参数上的注解 */ Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations(); if (methodParameterAnnotationArrays != null) &#123; int count = methodParameterAnnotationArrays.length; for (int i = 0; i &lt; count; i++) &#123; /** * 获得单个参数上的注解 */ Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i]; if (methodParameterAnnotations != null) &#123; for (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123; /** * 如果是Path注解 */ if (methodParameterAnnotation instanceof Path) &#123; /** * 取得path注解上的值 */ Path path = (Path) methodParameterAnnotation; String pathValue = path.value(); System.out.println(pathValue); /** * 这是对应的参数的值 */ System.out.println(args[i]); Request.Builder builder = new Request.Builder(); /** * 使用path注解替换get注解中的值为参数值 */ String result = getValue.replaceAll("\\&#123;" + pathValue + "\\&#125;", (String) args[i]); System.out.println(result); /** * 开始构造请求 */ Request request = builder.get() .url(baseUrl + "/" + result) .build(); okHttpClient.newCall(request).enqueue(new okhttp3.Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; /** * 失败则回调失败的方法 */ callback.onFailed(e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; /** * 请求成功 */ String body = response.body().string(); /** * 使用fastjson进行zhuan转换 */ Type type = callback.getClass().getGenericInterfaces()[0]; Object o1 = JSON.parse(body); /** * 回调成功 */ callback.onSuccess(o1); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; &#125; &#125; return null; &#125; &#125;); /** * 扔到缓存中 */ serviceMap.put(clazz, o); &#125; return (T) o; &#125; 然后我们就可以根据Retrofit那样进行调用了 123456789101112131415Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .build();GithubService githubService = retrofit.create(GithubService.class);githubService.listRepos("lizhangqu", new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onSuccess(Object t) &#123; System.out.println(t); &#125; @Override public void onFailed(Exception e) &#123; &#125;&#125;); retrofit动态代理原理原理就是先拿到最后一个参数，也就是回调，再拿到方法上的注解，获得具体的值，然后拿到除了回调之外的其他参数，获得参数上的注解，然后根据注解取得对应的值，还有原来的参数值，将方法上的注解的值中进行替换。使用OkHttp构造请求，请求完成后根据将结果解析为回调中的类型。整个过程如下 拦截到方法、参数，再根据我们在方法上的注解，去拼接为一个正常的Okhttp请求，然后执行。 java中的动态代理在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法： 12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义： 12345678public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 使用如下： 定义被代理对象 123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println("I want to rent my house"); &#125; @Override public void hello(String str) &#123; System.out.println("hello: " + str); &#125;&#125; 定义动态代理类，任何动态代理类都必须实现InvotionHandler这个接口，重写invoke方法 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println("before rent house"); System.out.println("Method:" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println("after rent house"); return null; &#125;&#125; 使用 123456789101112131415161718192021222324public class Client&#123; public static void main(String[] args) &#123; // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello("world"); &#125;&#125;]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发小结]]></title>
    <url>%2F2017%2F01%2F20%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android开发中，事件分发是非常重要的，了解熟悉整个事件分发过程有助于更好的分析各种点击滑动失效问题,也是一个安卓开发必会的一部分，但是时间长了，对整个流程多少会有些模糊，所以在此记录一下 网上看到一张图，可以很详细的描述整个事件分发的过程 原文的链接 问题一： 当ViewGroup重写的onInterceptTouchEvent，并且始终返回了true，那么子view就永远无法接受到了事件 但是在实际开发中可能会有这种需求，在按下（ACTION_DOWN）的时候，需要子view进行时间反馈，但在滑动（ACTION_MOVE）或者抬起（ACTION_UP）的时候需要父布局进行拦截操作，这个时候可以使用requestDisallInterceptRouchEvent(boolean disallowIntercept)，该方法在子view中调用，getParent().requestDisallInterceptRouchEvent(true)请求父布局禁用拦截事件功能 相关资料 具体例子，在我做的项目中，在viewpager中的每一页fragment中都折线图，viewpager是可以左右切换的，每一页的fragment中的折线图也是可以手势缩放的，所以这就和viewpager滑动有冲突，利用requestDisallInterceptRouchEvent，我们可以自定义折线图控件继承项目中使用的（项目中使用的mpandroid），重写onTouchEvent，当水平滑动的时候，getParent().requestDisallInterceptRouchEvent(true)，请求父布局不拦截事件，交给子view处理。 相关源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.nongfaziran.workiot.view;import android.annotation.SuppressLint;import android.content.Context;import android.graphics.PointF;import android.util.AttributeSet;import android.view.MotionEvent;import com.github.mikephil.charting.charts.LineChart;/** * Created by fengan on 2018/2/3. * email:fengan1102@gmail.com * 解决折线图在viewpager滑动冲突 */public class LineChartInViewPager extends LineChart &#123; PointF downPoint = new PointF(); public LineChartInViewPager(Context context) &#123; super(context); &#125; public LineChartInViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public LineChartInViewPager(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @SuppressLint("ClickableViewAccessibility") @Override public boolean onTouchEvent(MotionEvent evt) &#123; switch (evt.getAction()) &#123; case MotionEvent.ACTION_DOWN: downPoint.x = evt.getX(); downPoint.y = evt.getY(); break; case MotionEvent.ACTION_MOVE: if (getScaleX() &gt; 1 &amp;&amp; Math.abs(evt.getX() - downPoint.x) &gt; 5) &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; &#125; return super.onTouchEvent(evt); &#125;&#125; 未完待续]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈线程池]]></title>
    <url>%2F2016%2F12%2F25%2F%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[前置知识线程基本概念，线程基本概念和Android启动线程的三种方式(点击查看) new Thread（）的弊端 总是new Thread（）开启线程，线程执行完会被回收，导致频繁的GC 多线程缺乏统一管理，各线程之间互相竞争 无法实现停止线程（如果一个item滑出页面，则要停止该item上图片的加载，但是如果使用这种方式来创建线程，则无法实现线程停止执行） 使用线程池的好处 提高线程的复用性，避免频繁创建线程进而导致频繁的GC 控制线程并发数，合理利用资源 线程可控性，比如可以定时执行和取消执行某个线程的任务 线程池的实现 Android中的线程池其实源于Java，Android开发中线程池的使用和Java中线程池的使用基本一致 Java中和线程有关的东东叫做Executor，Executor本身是一个接口 这个接口有一个非常有用的实现类叫做ThreadPoolExecutor Android中常用的线程池都是通过对ThreadPoolExecutor进行不同配置来实现的 类的继承结构 Windows：Ctrl+H Mac：Control+H 关于ThreadPoolExecutorThreadPoolExecutor有四个重载的构造方法，我们这里来说说参数最多的那一个重载的构造方法，这样大家就知道其他方法参数的含义了 构造函数源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 这里是7个参数(我们在开发中用的更多的是5个参数的构造方法)，OK，那我们来看看这里七个参数的含义： corePoolSize：核心线程的数量 maximumPoolSize：最大线程数量 keepAliveTime：非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长 unit：第三个参数的单位，有纳秒、微秒、毫秒、秒、分、时、天等 workQueue：线程池中的任务队列，该队列存储已经被提交，但是尚未执行的任务，存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。 threadFactory 为线程池提供创建新线程的功能，这个我们一般使用默认即可 handler 拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。 关于workQueue workQueue是一个BlockingQueue类型 BlockingQueue是一个特殊的队列 从BlockingQueue中取数据时， 如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态 当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒 如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态(直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒 BlockingQueue的种类 ArrayBlockingQueue:这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。 LinkedBlockingQueue:这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE PriorityBlockingQueue:这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。 SynchronousQueue:这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。 ThreadPoolExecuto线程池执行任务时：execute一个线程之后： 如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行 如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行 如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务 如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务 如何配置这些参数（参考AsycTask） 核心线程数为手机CPU数量+1（cpu数量获取方式Runtime.getRuntime().availableProcessors()） 最大线程数为手机CPU数量×2+1 线程队列的大小为128 系统帮我们配置好的线程池四种对比 FixedThreadPool 核心线程数量固定的线程池 1ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); 源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程数和最大线程数一样 FixedThreadPool中没有非核心线程，所有的线程都是核心线程 线程的超时时间为0 核心线程即使在没有任务可执行的时候也不会被销毁（这样可让FixedThreadPool更快速的响应请求） LinkedBlockingQueue却没有参数，这说明线程队列的大小为Integer.MAX_VALUE（2的31次方减1) 所有的核心线程都在执行任务的时候，新的任务只能进入线程队列中进行等待，直到有线程被空闲出来 SingleThreadExecutor singleThreadExecutor和FixedThreadPool很像，不同的就是SingleThreadExecutor的核心线程数只有1 ​ 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 最大好处就是可以避免我们去处理线程同步问题 只有一个核心线程，确保所有任务都在同一线程中按顺序完成。因此不需要处理线程同步的问题。 FixedThreadPool的参数传个1效果一样 CachedThreadPool 最大的优势是它可以根据程序的运行情况自动来调整线程池中的线程数量 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool中是没有核心线程的，但是它的最大线程数却为Integer.MAX_VALUE 它是有线程超时机制的，超时时间为60秒 最大线程数为无限大 添加一个新任务进来的时候，如果线程池中有空闲的线程，则由该空闲的线程执行新任务 没有空闲线程，则创建新线程来执行任务 CachedThreadPool中没有新任务的时候，它里边所有的线程都会因为超时而被终止 任务队列SynchronousQueue相当于一个空集合，导致任何任务都会被立即执行 可以在有大量任务请求的时候使用CachedThreadPool ScheduleThreadPool 具有定时定期执行任务功能的线程池 12345public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 核心线程数量是固定的 非核心线程是无穷大,当非核心线程闲置时，则会被立即回收。 支持延迟执行任务；定时执行任务；延迟定时执行任务 线程池的其他功能 shutDown（）：关闭线程池，不影响已经提交的任务 shutDownNow（）：关闭线程池，并尝试终止正在执行的线程 allowCoreThreadTimeOut(boolean value)：允许核心线程闲置超时被回收 submit：一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值 线程池简单封装ThreadPoolManager.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by fengan on 2017/12/25. * email:fengan1102@gmail.com */public class ThreadPoolManager &#123; private static ThreadPoolManager Instance; private final ThreadPoolExecutor threadPoolExecutor; private ThreadPoolManager() &#123;//核心线程数量//最大线程数量//非核心线程的超时时长//时间单位//缓冲队列，用于存放等待任务，Linked的先进先出//创建线程的工厂//用来对超出maximumPoolSize的任务的处理策略 threadPoolExecutor = new ThreadPoolExecutor(corePoolSize,//核心线程数量 maximumPoolSize,//最大线程数量 keepAliveTime,//非核心线程的超时时长 unit,//时间单位 new LinkedBlockingQueue&lt;Runnable&gt;(),//缓冲队列，用于存放等待任务，Linked的先进先出 Executors.defaultThreadFactory(), //创建线程的工厂 new ThreadPoolExecutor.AbortPolicy() //用来对超出maximumPoolSize的任务的处理策略 ); threadPoolExecutor.allowCoreThreadTimeOut(true);//设置核心线程超时时间可用 &#125; public static ThreadPoolManager getInstance() &#123; if (Instance == null) &#123; synchronized (ThreadPoolManager.class) &#123; if (Instance == null) &#123; Instance = new ThreadPoolManager(); &#125; &#125; &#125; return Instance; &#125; //当前设备可用处理器核心数*2 + 1,能够让cpu的效率得到最大程度执行（有研究论证的） private final int corePoolSize = Runtime.getRuntime().availableProcessors() * 2 + 1; //最大线程数等于核心线程数 private final int maximumPoolSize = corePoolSize; //超时时间，1小时 private final long keepAliveTime = 1; private final TimeUnit unit = TimeUnit.HOURS; /** * 执行任务 */ public void execute(Runnable runnable) &#123; if (runnable == null) return; threadPoolExecutor.execute(runnable); &#125; /** * 从线程池中移除任务 */ public void remove(Runnable runnable) &#123; if (runnable == null) return; threadPoolExecutor.remove(runnable); &#125;&#125; 再次比较四种常见的线程池详细比较不管哪种线程池，都是靠ThreadPoolExecutor的七个参数的构造来实现的 核心线程 最大线程 特点 FixThreadPool 有 无（非核心线程） 不会被回收 只有固定数量的核心线程，线程都活动时，新任务等待 SingleThreadPool 1 无（非核心线程） 不会被回收 所有任务都在统一线程执行，不需要处理线程同步问题 CachedThreadPool 无 Integer.MAX_VALUE 超时时间60秒 任何任务立即执行 ScheduledThreadPool 有 Integer.MAX_VALUE 非核心线程闲置，立即回收 可以延迟和定时执行 相关资料： 123]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask的弊端]]></title>
    <url>%2F2016%2F12%2F20%2FAsyncTask%E7%BC%BA%E9%99%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AsyncTask的弊端 前言 Android开发中，AsyncTask可以替代Handler和Thread来处理后台操作和通知Ui刷新，适用于处理异步数据，并将更新Ui的场景，AsyncTask适用于后台操作只有几秒的短时操作。但是AsyncTask本身存在很多糟糕的问题，如果使用中不注意，将会影响程序的健壮性。 AsyncTask和Handler对比注意：按照Android官方文档支出,AsyncTask被推荐为处理短时间(10秒以内)的操作,即本地的轻量IO操作.不适合使用网络这样时间不定的操作. 共同点都是为了解决耗时操作的问题，主要区别在于一个流程完善，拿来就用（AsyncTask），一个偏向自主定制，扩展性高（Handler+Thread）。 AsyncTask比Handler轻量级，对吗？ 通过看源码，发现AsyncTask实际上就是一个线程池，而网上的说法是AsyncTask比handler要轻量级，显然上不准确的，只能这样说，AsyncTask在代码上比handler要轻量级别，而实际上要比handler更耗资源，因为AsyncTask底层是一个线程池！而Handler仅仅就是发送了一个消息队列，连线程都没有开。 但是，如果异步任务的数据特别庞大，AsyncTask这种线程池结构的优势就体现出来了。 AsyncTask实现的原理,和适用的优缺点 AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程. 使用的优点: l 简单,快捷 l 过程可控 使用的缺点: l 在使用多个异步操作的同时，共同进行Ui变更时,就变得复杂起来. l 最大并发数不超过5 Handler异步实现的原理和适用的优缺点 在Handler 异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程）àthread(子线程)运行并生成Message-àLooper获取Message并传递给HandleràHandler逐个获取Looper中的Message，并进行UI变更。 使用的优点： l 结构清晰，功能定义明确 l 对于多个后台任务时，简单，清晰 使用的缺点： l 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性） AsyncTask的使用： 必选方法： 1， doinbackground(params…) 后台执行，比较耗时的操作都可以放在这里。 注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作 ，通常需要较长的时间。在执行过程中可以调用 Public progress(progress…)来更新任务的进度。 2， onpostexecute(result)相当于handler处理UI的方式，在这里可以使用在 doinbackground得到的结果处理操作UI。此方法在主线程执行，任务执行的结果作为此方法的参数返回。 可选方法： 1， onprogressupdate(progress…) 可以使用进度条增加用户体验度。此方法在主线程执行，用户显示任务执行的进度。 2， onpreExecute() 这里是最新用户调用excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。 3， onCancelled() 用户调用取消时，要做的操作 AsyncTask三个状态： pending,running,finished 使用AsyncTask类，遵守的准则： 1， Task的实例必须在UI thread中创建； 2， Execute方法必须在UI thread中调用 3， 不要手动的调用onPfreexecute()，onPostExecute(result) Doinbackground(params…),onProgressupdate(progress…)这几个方法； 4， 该task只能被执行一次，否则多次调用时将会出现异常; AsyncTask缺陷总结： 生命周期 很多开发者会认为在一个Activity中创建的AsyncTask会随着Activity销毁而销毁，事实并非如此，AsyncTask会随着doInBackground（）方法执行完毕才销毁，然后，cancel（）被调用，那么onCancel会执行；否则执行postExecute方法会执行。如果在AsyncTask没有执行完毕，就销毁了Activity，AsyncTask可能会崩溃，因为它想要处理的view已经不存在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确地取消。 另外，即使我们正确地调用了cancle() 也未必能真正地取消任务。因为如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，那么这个操作会继续下去。 内存泄漏 如果AsyncTask未声明成静态，则会持有外部类Activity的引用，当Activity销毁之后，AsyncTask还在执行，它将在内存中依旧保持这个引用，会造成内存泄漏 结果丢失 当屏幕旋转Activity销毁重新创建（未配置android:configChanges=”orientation|screenSize”的情况）之前运行的AsyncTask会持有之前Activity的引用，这时调用onPostExecute()再去更新界面将不再生效。 并行还是串行 当想要串行执行时，直接执行execute()方法，如果需要并行执行，则要执行executeOnExecutor(Executor)。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2016%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义原型设计模式的是一种创建型的设计模式，如果创建过程笔记复杂耗时的话，可以考虑使用原型设计模式；通过克隆已有的对象来获取一个新的对象，你可以直接使用它，也可以修改克隆对象的部分属性再使用，使得我们的程序更加高效 使用场景 如果一个类的初始化需要很多资源，这个资源包括数据或者硬件资源等，通过原型拷贝已有的对象来避免这些消耗 通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 如何实现首先我们得实现Cloneable接口，复写clone方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.it.fengan.designpattern.pattern;/** * Created by fengan on 2017/12/22. * email:fengan1102@gmail.com */public class Worker implements Cloneable &#123; private String name; private String des; private double money; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDes() &#123; return des; &#125; public void setDes(String des) &#123; this.des = des; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Worker&#123;" + "name='" + name + '\'' + ", des='" + des + '\'' + ", money=" + money + '&#125;'; &#125; @Override public Worker clone() &#123; Worker worker = null; try &#123; worker = (Worker) super.clone(); worker.money = this.money; worker.name = this.name; worker.des = this.des; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return worker; &#125;&#125; 注意 clone这个方法不是Cloneable接口中的（Cloneable是一个空接口） clone是Object中的方法 Cloneable是一个标识接口，它表明这个类的对象是可以拷贝的 如果没有实现Cloneable接口却调用了clone()函数将抛出异常。 浅拷贝和深拷贝浅拷贝 12345678910@Override protected User clone() &#123; User user = null; try&#123; user = (User)super.clone(); &#125; catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return user; &#125; 那么在实现clone方法的时候，需要注意个问题，像上面那样，直接调用 1user = (User)super.clone(); 这样只是简单的拷贝了对象，实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段。 深拷贝 123456789101112@Override public WordDocument clone() &#123; try &#123; WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText; doc.mImages = (ArrayList&lt;String&gt;) this.mImages.clone(); return doc; &#125; catch (CloneNotSupportedException e) &#123; &#125; return null; &#125; Android中的应用Intenet源码 123456789101112131415161718192021222324252627282930313233343536373839* * &lt;p&gt;These are the possible flags that can be used in the Intent via * &#123;@link #setFlags&#125; and &#123;@link #addFlags&#125;. See &#123;@link #setFlags&#125; for a list * of all possible flags. */public class Intent implements Parcelable, Cloneable &#123; ... @Override public Object clone() &#123; return new Intent(this); &#125; public Intent(Intent o) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;String&gt;(o.mCategories); &#125; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; ...&#125; 可以见到，我们的Intent是深度拷贝，而且是直接new一个的深度拷贝。可见其设计初衷不是因为其不是为了解决构建复杂对象的资源消耗问题。 总结 原型模式本质上就是对象拷贝，与 C++ 中的拷贝构造函数有些类似，它们之间容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要的途径就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通常可以通过返回一个对象拷贝的形式实现只读的限制。 优点：原型模式是在内存中二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好滴体现其优点。 缺点：这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发中应该注意这个潜在问题]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2016%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之观察者模式什么是观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都能得到通知并可以自动作出处理 … 比如说：报纸的订阅，一旦订阅，当有新的报纸发布，所有的订阅者都会收到消息 基本概念组成 观察者：Observer，也叫订阅者，即Subscriber（Rxjava） 被观察者：Observable java中的体现java中提供了Observable和Observe接口供我们快速实现这种模式 代码实现 假如有下面这样的一个实体类 12345678910111213141516171819202122public class Weather &#123; private String description; public Weather(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; @Override public String toString() &#123; return "Weather&#123;" + "description='" + description + '\'' + '&#125;'; &#125;&#125; 定义观察者接口（因为观察者可能有很多类型，所以我们定义成一个接口，如果想要订阅这个事件，实现这个接口即可，另外一般订阅之后，在实现接口中的方法的参数中会拿到发布的数据，数据的类型不固定所以这个观察者接口需要定义范型） 123public interface Observer&lt;T&gt; &#123; void onUpdate(Observable&lt;T&gt; observable,T data);&#125; 定义被观察者对象（可以设计成单例模式，类似EventBus，内部维持一个集合，用来保存观察者对象；register方法和unregister方法用来将观察者对象从集合中添加和移除出来，post方法用来发布，循环遍历集合，依次调用观察者的相关回调方法，并将发布的参数传入） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.it.fengan.designpattern.pattern;import java.util.ArrayList;import java.util.List;/** * Created by fengan on 2017/12/12. * email:fengan1102@gmail.com */public class Observable&lt;T&gt; &#123; private static Observable observable; private Observable() &#123; &#125; public static Observable getInstance() &#123; if (observable == null) &#123; synchronized (Observable.class) &#123; if (observable == null) &#123; observable = new Observable(); &#125; &#125; &#125; return observable; &#125; private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); public void register(Observer&lt;T&gt; observer) &#123; if (observer == null) &#123; throw new RuntimeException("observer error"); &#125; synchronized (Observable.class) &#123; if (!observers.contains(observer)) &#123; observers.add(observer); &#125; &#125; &#125; public void unregister(Observer&lt;T&gt; observer) &#123; observers.remove(observer); &#125; public void post(T data) &#123; for (Observer observer : observers) &#123; observer.onUpdate(this, data); &#125; &#125;&#125; 注册和反注册过程 1234567891011121314151617181920212223@Test public void testObserver() &#123; Observer&lt;Weather&gt; objectObserver1 = new Observer&lt;Weather&gt;()&#123; @Override public void onUpdate(Observable&lt;Weather&gt; observable, Weather data) &#123; Log.e("testObserver", "objectObserver1:data=" + data.toString()); &#125; &#125;; Observer&lt;Weather&gt; objectObserver2 = new Observer&lt;Weather&gt;()&#123; @Override public void onUpdate(Observable&lt;Weather&gt; observable, Weather data) &#123; Log.e("testObserver", "objectObserver2:data=" + data.toString()); &#125; &#125;; Observable observable = Observable.getInstance(); observable.register(objectObserver1); observable.register(objectObserver2); Weather weather = new Weather("晴天"); observable.post(weather); observable.unregister(objectObserver2); observable.post(weather); &#125; logcat输出 12312-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver1:data=Weather&#123;description='晴天'&#125;12-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver2:data=Weather&#123;description='晴天'&#125;12-19 15:18:44.780 2004-2036/? E/testObserver: objectObserver1:data=Weather&#123;description='晴天'&#125; Android中的应用 一对一的观察者（一般称之为回调，只有一个观察者） 1234567Button btn=new Button(this);btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.e("TAG","click"); &#125;&#125;); 只要是set系列的设置监听器的方法最多都只能算回调，但是有一些监听器式add进去的，这种就是观察者模式了（比如RecyclerView中的addOnScrollListener方法） RecycleView.java 123456789101112131415161718192021222324252627282930313233343536373839private List&lt;OnScrollListener&gt; mScrollListeners;/** * Add a listener that will be notified of any changes in scroll state or position. * * &lt;p&gt;Components that add a listener should take care to remove it when finished. * Other components that take ownership of a view may call &#123;@link #clearOnScrollListeners()&#125; * to remove all attached listeners.&lt;/p&gt; * * @param listener listener to set or null to clear */public void addOnScrollListener(OnScrollListener listener) &#123; if (mScrollListeners == null) &#123; mScrollListeners = new ArrayList&lt;&gt;(); &#125; mScrollListeners.add(listener);&#125;/** * Remove a listener that was notified of any changes in scroll state or position. * * @param listener listener to set or null to clear */public void removeOnScrollListener(OnScrollListener listener) &#123; if (mScrollListeners != null) &#123; mScrollListeners.remove(listener); &#125;&#125;/** * Remove all secondary listener that were notified of any changes in scroll state or position. */public void clearOnScrollListeners() &#123; if (mScrollListeners != null) &#123; mScrollListeners.clear(); &#125;&#125; Android的广播机制，其本质也是观察者模式，这里为了简单方便，直接拿本地广播的代码说明，即LocalBroadcastManager 1234LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter);localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver);localBroadcastManager.sendBroadcast(Intent intent) 开源库（EventBus） 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件 1234EventBus.getDefault().register(Object subscriber);EventBus.getDefault().unregister(Object subscriber);EventBus.getDefault().post(Object event); 重量级的库，它就是RxJava 创建一个被观察者 123456789Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext("Hello, world!"); sub.onCompleted(); &#125; &#125; ); 创建一个观察者，也就是订阅者 12345678910Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;; 观察者进行事件的订阅 1myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2016%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念描述策略模式属于对象的行为模式，其用意是针对一组算法，将每一个算法封装到具有公共接口的独立的类中，从而在不影响客户端的情况下可以切换相应的算法。 未使用策略模式案例12345678910111213141516171819202122232425262728293031323334public class TravelStrategy &#123; enum Strategy&#123; WALK,PLANE,SUBWAY &#125; private Strategy strategy; public TravelStrategy(Strategy strategy)&#123; this.strategy=strategy; &#125; public void travel()&#123; if(strategy==Strategy.WALK)&#123; print("walk"); &#125;else if(strategy==Strategy.PLANE)&#123; print("plane"); &#125;else if(strategy==Strategy.SUBWAY)&#123; print("subway"); &#125; &#125; public void print(String str)&#123; System.out.println("出行旅游的方式为："+str); &#125; public static void main(String[] args) &#123; TravelStrategy walk=new TravelStrategy(Strategy.WALK); walk.travel(); TravelStrategy plane=new TravelStrategy(Strategy.PLANE); plane.travel(); TravelStrategy subway=new TravelStrategy(Strategy.SUBWAY); subway.travel(); &#125;&#125; 通过switch或者if语句，来判断选择哪一种策略算法，一旦策略增加或者减少修改，就不得不增加新的语句，这就违背了面向对象的原则之一，对修改封闭。 使用策略模式案例定义策略接口（抽象策略） 123public interface Strategy &#123; void travel();&#125; 将不同的算法封装到实现该策略接口的具体的类中（具体策略） 12345678public class WalkStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("walk"); &#125;&#125; 12345678public class PlaneStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("plane"); &#125;&#125; 12345678public class SubwayStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("subway"); &#125;&#125; 策略环境（持有抽象策略引用的环境类） 1234567891011121314151617public class TravelContext &#123; Strategy strategy; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void travel() &#123; if (strategy != null) &#123; strategy.travel(); &#125; &#125;&#125; 具体使用 1234567891011public class Main &#123; public static void main(String[] args) &#123; TravelContext travelContext=new TravelContext(); travelContext.setStrategy(new PlaneStrategy()); travelContext.travel(); travelContext.setStrategy(new WalkStrategy()); travelContext.travel(); travelContext.setStrategy(new SubwayStrategy()); travelContext.travel(); &#125;&#125; 若想增加新的策略（添加新的策略实现类即可） 12345678public class BikeStrategy implements Strategy&#123; @Override public void travel() &#123; System.out.println("bike"); &#125;&#125; 123TravelContext travelContext=new TravelContext(); travelContext.setStrategy(new BikeStrategy()); travelContext.travel(); 总结 面向对象的对修改封闭，对扩展开放。 Android源码中的使用 属性动画的插值器 策略接口 12345public interface TypeEvaluator&lt;T&gt; &#123; public T evaluate(float fraction, T startValue, T endValue);&#125; 多个策略实现例如 1234567public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 1234567public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; &#123; public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125;&#125; 其他略… 其他使用场景举例例如：一个电商类平台等购物车系统，除了把货品的单价乘以数量之外，可能会有一些优惠活动。比如说，对高级会员提供5折优惠，对中级会员提供7折优惠，对初级会员提供9折优惠 那么这就涉及到了三种算法 首先定义折扣抽样策略接口 12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 初级会员折扣策略 12345678910public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的9折折扣"); return booksPrice*0.9; &#125;&#125; 123456789public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于高级会员的折扣为5折"); return booksPrice * 0.5; &#125;&#125; 12345678910public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为7折"); return booksPrice * 0.7; &#125;&#125; 策略环境类 1234567891011121314151617181920public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; 客户端的使用 12345678910111213public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote); &#125;&#125; 可以看出 策略模式的重心不是提供算法，而是对多种算法的封装 各个算法相对独立平等 算法可以相互切换，但在同一时刻只能使用一种策略 面向对象的：对修改封闭，对拓展开放 避免使用switch和if多重条件语句，方便维护 缺点：客户端事先知道有多少种策略，并且每个策略的区别]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之建造者模式什么是Build模式将一个复杂对象的构建与它的表示分离，使得构建过程可以以分部进行的链式调用来完成 … 若不用Build模式定义一个Person类1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; private String name; private int age; private double height; private double weight; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getHeight() &#123; return height; &#125; public void setHeight(double height) &#123; this.height = height; &#125; public double getWeight() &#123; return weight; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125;&#125; 可能会定义一个构造方法。123456public Person(String name, int age, double height, double weight) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight;&#125; 对应不同的需求，可能会定义好几种构造方法1234567891011121314public Person(String name) &#123; this.name = name;&#125;public Person(String name, int age) &#123; this.name = name; this.age = age;&#125;public Person(String name, int age, double height) &#123; this.name = name; this.age = age; this.height = height;&#125; 使用的时候就变成这样了12345Person p1=new Person();Person p2=new Person("张三");Person p3=new Person("李四",18);Person p4=new Person("王五",21,180);Person p5=new Person("赵六",17,170,65.4); 这样的坏处： 构造函数有多个参数，不好确定每个参数具体意思，可读性不强 若参数较多的时候，麻烦 若使用Builder模式具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Person &#123; private String name; private int age; private double height; private double weight; privatePerson(Builder builder) &#123; this.name=builder.name; this.age=builder.age; this.height=builder.height; this.weight=builder.weight; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getHeight() &#123; return height; &#125; public void setHeight(double height) &#123; this.height = height; &#125; public double getWeight() &#123; return weight; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125; static class Builder&#123; private String name; private int age; private double height; private double weight; public Builder name(String name)&#123; this.name=name; return this; &#125; public Builder age(int age)&#123; this.age=age; return this; &#125; public Builder height(double height)&#123; this.height=height; return this; &#125; public Builder weight(double weight)&#123; this.weight=weight; return this; &#125; public Person build()&#123; return new Person(this); &#125; &#125;&#125; 大概流程 定义静态Builder类 Builder类中声明和外部类一样的变量 定义多个set方法，返回结果为Builder本身（this） Builder类中增加build（）方法，返回外部类Person对象 外部类Person中声明一个参数为Builder的构造函数 使用1234567Person.Builder builder=new Person.Builder();Person person=builder .name("张三") .age(18) .height(178.5) .weight(67.4) .build(); Android中哪些地方使用到Builder模式对话框的创建，AlertDialog123456789101112131415161718AlertDialog.Builder builder=new AlertDialog.Builder(this);AlertDialog dialog=builder.setTitle("标题") .setIcon(android.R.drawable.ic_dialog_alert) .setView(R.layout.myview) .setPositiveButton(R.string.positive, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .setNegativeButton(R.string.negative, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .create();dialog.show();]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android设计模式-单例模式 什么是单例模式 使用时，单例模式的对象只有一个实例存在，不允许自由的构造对象 单例模式使用场景 确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例 … … 如何使用单例 私有构造函数，禁止外部使用构造函数创建对象 通过一个静态方法或者枚举来提供返回单例实例 确保单例类的对象在反序列化的时候不会重新构建对象 确保在多线程下，也只有一个实例 单例模式分类 1,饿汉式1234567891011public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; private Singleton getInstance() &#123; return instance; &#125; &#125; 2,懒汉式12345678910111213public class Singleton &#123; private static Singleton instance ; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饿汉式和懒汉式的区别 饿汉式：在声明静态对象的时候就初始化 懒汉式：声明一个静态变量，并且在用户第一次调用getInstance的时候进行初始化 ​ 优点：单例在使用的时候才会初始化，一定程度上节约了资源 ​ 缺点：第一次加载的时候会初始化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成了不必要的同步开销，一般不介意这么用。 3,Double check lock（DCL）123456789101112131415public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; DCL : 介绍DCL 在getInstance 方法中 对instance 进行两次判空：相信很多人对此都有些疑惑。为什么要判断两次，第一个判空是为了避免不必要的同步，第二层判断是为了在null 情况下创建实例。instance=new Singleton(); 语句看起来是有代码，单实际是一个原子操作，最终会被编译成多条汇编指令，大致做了三件事： 1.给Singleton 分配内存 2.调用Singleton 的构造函数，初始化成员字段 3.将instance 对象指向分配的内存空间（此时instance 就不是null 了）但是jdk 1.5 以后java 编译器允许乱序执行 。所以执行顺序可能是1-3-2 或者 1-2-3.如果是前者先执行3 的话 切换到其他线程，instance 此时 已经是非空了，此线程就会直接取走instance ，直接使用，这样就回出错。DCL 失效。解决方法 SUN 官方已经给我们了。将instance 定义成 privatevolatilestatic Singleton instance =null: 即可DCL 的优点，资源利用率高，第一次执行getInstance 时才会被实例化，效率高。缺点：第一次加载反应慢，也由于java 内存 模型的原因偶尔会失败，在高并发环境下，有一定缺陷，虽然发生概率很小。(很常用) 4.静态内部类单例模式12345678910111213public class Singleton &#123; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 加载singleton 类时不会初始化instance 只有在调用getInstance 方法时，才会导致instance 被初始化,这个方法不仅能够确保线程安全，也能够保证 单例对象的唯一性,同时也延迟了单例的实例化，是推荐使用的单例模式实现方式。 5，防止反序列化过程中创建多个对象加入下列方法 123protected Singleton readResolve() throws ObjectStreamException &#123; return SingletonHolder.instance;&#125; 而当实现了readResolve方法后，jvm就会有readResolve返回指定对象，也就保证了单例性。实验证明，如果没有声明readResolve方法，存入对象的hashcode和取出对象的hashcode不一致。 推荐下列方式（如果需要序列化的话）： 1234567891011121314151617public class Singleton implements Serializable &#123; private Singleton() &#123; &#125; private synchronized Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static volatile final Singleton instance = new Singleton(); &#125; protected Singleton readResolve() throws ObjectStreamException &#123; return SingletonHolder.instance; &#125;&#125; 6,volatile关键字的使用当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 volatile 性能： volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 7,Android源码或者框架使用 ImageLoader EventBus InputMethodManager AccessibilityManager ActivityManager(自定义关闭所有Activity的工具类)]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随滑动改变的的动态矩形背景]]></title>
    <url>%2F2016%2F10%2F11%2F%E9%9A%8F%E6%BB%91%E5%8A%A8%E6%94%B9%E5%8F%98%E7%9A%84%E7%9A%84%E5%8A%A8%E6%80%81%E7%9F%A9%E5%BD%A2%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[随滑动改变的动态矩形背景 前言 可能看到这个标题有点懵逼,本屌的表达能力有限,最近工作比较清闲,朋友公司正在做到这个效果,所以就帮基友写了一个小Demo,总体来说就是以下效果. github移步:https://github.com/itfengan/DynamicRectangleView 朋友公司需要达到的效果 Demo中的效果 使用过程 layout &lt;com.fengan.dynamicrectangledemo.DynamicRectangleView android:id=&quot;@+id/drv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot; app:fengan_limit_percent=&quot;0.2&quot; app:fengan_percent=&quot;0.5&quot; &gt;&lt;/com.fengan.dynamicrectangledemo.DynamicRectangleView&gt; code @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SeekBar seekBar = (SeekBar) findViewById(R.id.sb); final DynamicRectangleView dynamicRectangleView = (DynamicRectangleView) findViewById(R.id.drv); seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) { dynamicRectangleView.setPercent((float)i/100); } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); findViewById(R.id.btn_scrollview).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startActivity(new Intent(MainActivity.this,ScrollViewActivity.class)); } }); } attrs.xml(有灵性的哥哥们应该猜得到分别对应的什么意思咯) &lt;resources&gt; &lt;declare-styleable name=&quot;DynamicRectangleView&quot;&gt; &lt;attr name=&quot;fengan_percent&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;fengan_limit_percent&quot; format=&quot;float&quot;/&gt; &lt;attr name=&quot;fengan_start_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;fengan_end_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; fengan_percent:右侧短边占左侧的百分比 fengan_limit_percent:当滑动到最小的百分比 fengan_start_color:渐变色的初始颜色(ps:朋友公司效果图是渐变色,当然也可以不需要) fengan_end_color:渐变色的终止颜色 DynamicRectangleView.java package com.fengan.dynamicrectangledemo; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.LinearGradient; import android.graphics.Paint; import android.graphics.Path; import android.graphics.Shader; import android.util.AttributeSet; import android.util.Log; import android.view.View; /** * Created by fengan on 2017/10/11/011. */ public class DynamicRectangleView extends View { // Default values private final static int DEFAULT_START_COLOR = Color.parseColor(&quot;#88D94600&quot;); private final static int DEFAULT_END_COLOR = Color.parseColor(&quot;#D94600&quot;); private final static float DEFAULT_PERCENT = (float) 0.5;//右边高度占左边高度的百分比 private final static float DEFAULT_LIMIT_PERCENT = (float) 0.2;//最小高度占左边高度的百分比 private Paint mPaint; private float OriginalRightHeight; private float OriginalLeftHeight; private float currentRightHeight; private float currentLeftHeight; private float minHeight; private float maxHeight; private int mStartColor; private int mEndColor; private float mPercent; private float mLimitPercent; private Path mPath; public DynamicRectangleView(Context context) { this(context, null); } public DynamicRectangleView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public DynamicRectangleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); // Retrieve attributes from xml final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DynamicRectangleView); try { mPercent = typedArray.getFloat(R.styleable.DynamicRectangleView_fengan_percent, DEFAULT_PERCENT); mLimitPercent = typedArray.getFloat(R.styleable.DynamicRectangleView_fengan_percent, DEFAULT_LIMIT_PERCENT); mStartColor = typedArray.getColor(R.styleable.DynamicRectangleView_fengan_start_color, DEFAULT_START_COLOR); mEndColor = typedArray.getColor(R.styleable.DynamicRectangleView_fengan_end_color, DEFAULT_END_COLOR); } finally { typedArray.recycle(); } initView(context); } private void initView(Context context) { mPaint = new Paint(); mPath = new Path(); mPaint.setAntiAlias(true); // mPaint.setColor(Color.RED);//纯色 } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); OriginalLeftHeight = getMeasuredHeight(); OriginalRightHeight = getMeasuredHeight()*mPercent; minHeight = getMeasuredHeight() *mLimitPercent; maxHeight = OriginalRightHeight; //设置当前高度 currentRightHeight = OriginalRightHeight; currentLeftHeight = OriginalLeftHeight; // LinearGradient 第一个参数第二个参数为 起始位置x,y 三四参数为终点位置x,y。 // 如果x不变则为y轴渐变， y不变则为x轴渐变 // 第五个参数为颜色渐变，此处为红色渐变为绿色 // 第七个参数为渐变次数，可repeat Shader mShader = new LinearGradient(0, 0, maxHeight, maxHeight, new int[]{mStartColor, mEndColor}, null, Shader.TileMode.CLAMP); // Shader.TileMode三种模式 // REPEAT:沿着渐变方向循环重复 // CLAMP:如果在预先定义的范围外画的话，就重复边界的颜色 // MIRROR:与REPEAT一样都是循环重复，但这个会对称重复 mPaint.setShader(mShader);// 用Shader中定义定义的颜色来话 } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); mPath.reset(); mPath.moveTo(0, 0); mPath.lineTo(getMeasuredWidth(), 0); mPath.lineTo(getMeasuredWidth(), currentRightHeight); mPath.lineTo(0, currentLeftHeight); mPath.close(); canvas.drawPath(mPath, mPaint); } public void setPercent(float percent) { Log.e(&quot;fengan&quot;, &quot;percent=&quot; + percent); currentRightHeight = OriginalRightHeight * (1 - percent); currentLeftHeight = OriginalLeftHeight * (1 - percent); if (currentLeftHeight &lt; minHeight) { currentLeftHeight = minHeight; } if (currentRightHeight &lt; minHeight) { currentRightHeight = minHeight; } postInvalidate(); } }]]></content>
      <categories>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0之广播变动]]></title>
    <url>%2F2016%2F08%2F23%2FAndroid7-0%E4%B9%8B%E5%B9%BF%E6%92%AD%E5%8F%98%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Android7.0的后台优化Android中有一些系统的隐式广播,我们可以利用这些广播注册BroadCastReceiver来监听,比如手机网络变动(Wifi的时候自动下载更新包,发送错误日志),当这些广播到来的时候(网络从Wifi到移动数据来回切换的时候),后台会频繁的启动已经监听这些的应用,并且现在很多应用都会注册这些广播(如网络变化),那么就会带来大量的电量消耗,所以Android7.0中删除了三项隐式广播,又花了内存和电量的消耗 具体体现 Android7.0以上应用不会接受和发送以下三种广播 CONNECTIVITY_ACTION广播:网络状态改变 ACTION_NEW_PICTURE广播:一个新的相机,拍照和图片的添加 ACTION_NEW_VIDEO广播:一个新的视频摄像记录下来 解决办法可以使用JobScheduler API(Android5.0提供),任务调度,可以使你再未来的某个时间点满足某个特定条件执行一个任务(当设备连接到Wifi,连通电源适配器的时候),具体用法以后再次整理.]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson封装]]></title>
    <url>%2F2016%2F08%2F21%2FGson%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Gson封装 Gson封装的工具类 javabean和集合相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 /** * Created by fengan on 2017/7/6/006. */ import com.google.gson.Gson; import com.google.gson.JsonArray; import com.google.gson.JsonElement; import com.google.gson.JsonParser; import com.google.gson.reflect.TypeToken; import java.util.ArrayList; import java.util.List; import java.util.Map; public class GsonUtil &#123; private static Gson gson = null; static &#123; if (gson == null) &#123; gson = new Gson(); &#125; &#125; private GsonUtil() &#123; &#125; /** * 转成json * * @param object * @return */ public static String GsonString(Object object) &#123; String gsonString = null; if (gson != null) &#123; gsonString = gson.toJson(object); &#125; return gsonString; &#125; /** * 转成bean * * @param gsonString * @param cls * @return */ public static &lt;T&gt; T GsonToBean(String gsonString, Class&lt;T&gt; cls) &#123; T t = null; if (gson != null) &#123; t = gson.fromJson(gsonString, cls); &#125; return t; &#125; /** * 转成list * 泛型在编译期类型被擦除导致报错 * * @param gsonString * @param cls * @return */ public static &lt;T&gt; List&lt;T&gt; GsonToList(String gsonString, Class&lt;T&gt; cls) &#123; List&lt;T&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;T&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成list * 解决泛型问题 * * @param json * @param cls * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;T&gt; jsonToList(String json, Class&lt;T&gt; cls) &#123; Gson gson = new Gson(); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); JsonArray array = new JsonParser().parse(json).getAsJsonArray(); for (final JsonElement elem : array) &#123; list.add(gson.fromJson(elem, cls)); &#125; return list; &#125; /** * 转成list中有map的 * * @param gsonString * @return */ public static &lt;T&gt; List&lt;Map&lt;String, T&gt;&gt; GsonToListMaps(String gsonString) &#123; List&lt;Map&lt;String, T&gt;&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;Map&lt;String, T&gt;&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成map的 * * @param gsonString * @return */ public static &lt;T&gt; Map&lt;String, T&gt; GsonToMaps(String gsonString) &#123; Map&lt;String, T&gt; map = null; if (gson != null) &#123; map = gson.fromJson(gsonString, new TypeToken&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;.getType()); &#125; return map; &#125;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view被软键盘挡住和点击外部软键盘消失]]></title>
    <url>%2F2016%2F08%2F21%2Fview%E8%A2%AB%E8%BD%AF%E9%94%AE%E7%9B%98%E6%8C%A1%E4%BD%8F%E5%92%8C%E7%82%B9%E5%87%BB%E5%A4%96%E9%83%A8%E8%BD%AF%E9%94%AE%E7%9B%98%E6%B6%88%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[软键盘遮挡和点击空白区域关闭键盘 登陆button挡住输入框 软键盘弹出挡住其他控件 软键盘弹出，点击空白区域关闭软件盘 设置：点击button，键盘将button顶上去 // 控制是否移动布局。比如只有密码输入框获取到焦点时才执行。 public boolean flag = true; /** * @param act activiry用于获取底部导航栏高度。 * @param root 最外层布局，需要调整的布局 * @param scrollToView 被键盘遮挡的scrollToView，滚动root,使scrollToView在root可视区域的底部 */ public void controlKeyboardLayout(Context act, final View root, final View scrollToView) { final int navigationBarHeight = getNavigationBarHeight(act); root.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Rect rect = new Rect(); //获取root在窗体的可视区域 root.getWindowVisibleDisplayFrame(rect); //获取root在窗体的不可视区域高度(被其他View遮挡的区域高度) int rootInvisibleHeight = root.getRootView().getHeight() - rect.bottom; //若不可视区域高度大于100，则键盘显示 if (rootInvisibleHeight &gt; navigationBarHeight &amp;&amp; flag) { int[] location = new int[2]; //获取scrollToView在窗体的坐标 scrollToView.getLocationInWindow(location); //计算root滚动高度，使scrollToView在可见区域 int srollHeight = (location[1] + scrollToView.getHeight()) - rect.bottom; if (root.getScrollY() != 0) {// 如果已经滚动，要根据上次滚动，重新计算位置。 srollHeight += root.getScrollY(); } root.scrollTo(0, srollHeight); } else { //键盘隐藏 root.scrollTo(0, 0); } } }); } 解决控制点击可选择的区域让软键盘消失或者不消失 /** * 获取底部导航栏高度 * * @param act * @return */ private int getNavigationBarHeight(Context act) { Resources resources = act.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); int height = resources.getDimensionPixelSize(resourceId); Log.v(&quot;dbw&quot;, &quot;Navi height:&quot; + height); return height; } //软键盘消失的管理 //region软键盘的处理 /** * 清除editText的焦点 * * @param v 焦点所在View * @param ids 输入框 */ public void clearViewFocus(View v, int... ids) { if (null != v &amp;&amp; null != ids &amp;&amp; ids.length &gt; 0) { for (int id : ids) { if (v.getId() == id) { v.clearFocus(); break; } } } } /** * 隐藏键盘 * * @param v 焦点所在View * @param ids 输入框 * @return true代表焦点在edit上 */ public boolean isFocusEditText(View v, int... ids) { if (v instanceof EditText) { EditText tmp_et = (EditText) v; for (int id : ids) { if (tmp_et.getId() == id) { return true; } } } return false; } //是否触摸在指定view上面,对某个控件过滤 public boolean isTouchView(View[] views, MotionEvent ev) { if (views == null || views.length == 0) return false; int[] location = new int[2]; for (View view : views) { view.getLocationOnScreen(location); int x = location[0]; int y = location[1]; if (ev.getX() &gt; x &amp;&amp; ev.getX() &lt; (x + view.getWidth()) &amp;&amp; ev.getY() &gt; y &amp;&amp; ev.getY() &lt; (y + view.getHeight())) { return true; } } return false; } //region 右滑返回上级 @Override public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { if (isTouchView(filterViewByIds(), ev)) return super.dispatchTouchEvent(ev); if (hideSoftByEditViewIds() == null || hideSoftByEditViewIds().length == 0) return super.dispatchTouchEvent(ev); View v = getCurrentFocus(); if (isFocusEditText(v, hideSoftByEditViewIds())) { //隐藏键盘 hideInputForce(this); clearViewFocus(v, hideSoftByEditViewIds()); } } return super.dispatchTouchEvent(ev); } /** * 传入EditText的Id * 没有传入的EditText不做处理 * * @return id 数组 */ public int[] hideSoftByEditViewIds() { return null; } /** * 传入要过滤的View * 过滤之后点击将不会有隐藏软键盘的操作 * * @return id 数组 */ public View[] filterViewByIds() { return null; } /** * des:隐藏软键盘,这种方式参数为activity * * @param activity */ public static void hideInputForce(Activity activity) { if (activity == null || activity.getCurrentFocus() == null) return; ((InputMethodManager) activity.getSystemService(INPUT_METHOD_SERVICE)) .hideSoftInputFromWindow(activity.getCurrentFocus() .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } 以下Demo全部代码1234567891011121314public class MainActivity extends AppCompatActivity &#123;private EditText mEt1;private EditText mEt2;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = (Button) findViewById(R.id.btn); mEt1 = (EditText) findViewById(R.id.et1); mEt2 = (EditText) findViewById(R.id.et2); LinearLayout LL = (LinearLayout) findViewById(R.id.LL); controlKeyboardLayout(this,LL,btn);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// 控制是否移动布局。比如只有密码输入框获取到焦点时才执行。public boolean flag = true;/** * @param act activiry用于获取底部导航栏高度。 * @param root 最外层布局，需要调整的布局 * @param scrollToView 被键盘遮挡的scrollToView，滚动root,使scrollToView在root可视区域的底部 */public void controlKeyboardLayout(Context act, final View root, final View scrollToView) &#123; final int navigationBarHeight = getNavigationBarHeight(act); root.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect = new Rect(); //获取root在窗体的可视区域 root.getWindowVisibleDisplayFrame(rect); //获取root在窗体的不可视区域高度(被其他View遮挡的区域高度) int rootInvisibleHeight = root.getRootView().getHeight() - rect.bottom; //若不可视区域高度大于100，则键盘显示 if (rootInvisibleHeight &gt; navigationBarHeight &amp;&amp; flag) &#123; int[] location = new int[2]; //获取scrollToView在窗体的坐标 scrollToView.getLocationInWindow(location); //计算root滚动高度，使scrollToView在可见区域 int srollHeight = (location[1] + scrollToView.getHeight()) - rect.bottom; if (root.getScrollY() != 0) &#123;// 如果已经滚动，要根据上次滚动，重新计算位置。 srollHeight += root.getScrollY(); &#125; root.scrollTo(0, srollHeight); &#125; else &#123; //键盘隐藏 root.scrollTo(0, 0); &#125; &#125; &#125;);&#125;/** * 获取底部导航栏高度 * * @param act * @return */private int getNavigationBarHeight(Context act) &#123; Resources resources = act.getResources(); int resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android"); int height = resources.getDimensionPixelSize(resourceId); Log.v("dbw", "Navi height:" + height); return height;&#125;//软键盘消失的管理//region软键盘的处理/** * 清除editText的焦点 * * @param v 焦点所在View * @param ids 输入框 */public void clearViewFocus(View v, int... ids) &#123; if (null != v &amp;&amp; null != ids &amp;&amp; ids.length &gt; 0) &#123; for (int id : ids) &#123; if (v.getId() == id) &#123; v.clearFocus(); break; &#125; &#125; &#125;&#125;/** * 隐藏键盘 * * @param v 焦点所在View * @param ids 输入框 * @return true代表焦点在edit上 */public boolean isFocusEditText(View v, int... ids) &#123; if (v instanceof EditText) &#123; EditText tmp_et = (EditText) v; for (int id : ids) &#123; if (tmp_et.getId() == id) &#123; return true; &#125; &#125; &#125; return false;&#125;//是否触摸在指定view上面,对某个控件过滤public boolean isTouchView(View[] views, MotionEvent ev) &#123; if (views == null || views.length == 0) return false; int[] location = new int[2]; for (View view : views) &#123; view.getLocationOnScreen(location); int x = location[0]; int y = location[1]; if (ev.getX() &gt; x &amp;&amp; ev.getX() &lt; (x + view.getWidth()) &amp;&amp; ev.getY() &gt; y &amp;&amp; ev.getY() &lt; (y + view.getHeight())) &#123; return true; &#125; &#125; return false;&#125;//region 右滑返回上级@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; if (isTouchView(filterViewByIds(), ev)) return super.dispatchTouchEvent(ev); if (hideSoftByEditViewIds() == null || hideSoftByEditViewIds().length == 0) return super.dispatchTouchEvent(ev); View v = getCurrentFocus(); if (isFocusEditText(v, hideSoftByEditViewIds())) &#123; //隐藏键盘 hideInputForce(this); clearViewFocus(v, hideSoftByEditViewIds()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 传入EditText的Id * 没有传入的EditText不做处理 * * @return id 数组 */public int[] hideSoftByEditViewIds() &#123; int [] ids = &#123;R.id.et1,R.id.et2&#125;; return ids;&#125;/** * 传入要过滤的View * 过滤之后点击将不会有隐藏软键盘的操作 * * @return id 数组 */public View[] filterViewByIds() &#123; View [] views = &#123;mEt1,mEt2&#125;;//点击这两个控件,软键盘不会消失 return views;&#125;/** * des:隐藏软键盘,这种方式参数为activity * * @param activity */public static void hideInputForce(Activity activity) &#123; if (activity == null || activity.getCurrentFocus() == null) return; ((InputMethodManager) activity.getSystemService(INPUT_METHOD_SERVICE)) .hideSoftInputFromWindow(activity.getCurrentFocus() .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);&#125;&#125; 以下是布局文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:id="@+id/activity_main"android:layout_width="match_parent"android:layout_height="match_parent"android:orientation="vertical"tools:context="fengan.softinputdemo.MainActivity"&gt;&lt;LinearLayout android:id="@+id/LL" android:layout_marginTop="100dp" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="wrap_content"&gt;&lt;EditText android:id="@+id/et1" android:layout_marginTop="60dp" android:background="#ff0" android:layout_width="match_parent" android:layout_height="60dp"/&gt;&lt;EditText android:id="@+id/et2" android:layout_marginTop="20dp" android:background="#ff0" android:layout_width="match_parent" android:layout_height="60dp"/&gt;&lt;Button android:text="软键盘挡住button" android:id="@+id/btn" android:layout_marginTop="30dp" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; 可以将隐藏显示的代码封装到BaseActivity]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存图片到本地]]></title>
    <url>%2F2016%2F08%2F21%2F%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[Android保存图片到本地 需求 一个很常见的需求,查看大图的同时,点击可以将图片保存到本地 我的步骤 使用Gilde获取图片的Drawable Drawable转成Bitmap bigtmap压缩并通过流写入 通知系统图库更新 代码块 保存图片,流写入,压缩 public static void saveImageToGallery(Context context, Bitmap bmp) { // 首先保存图片 File appDir = new File(Environment.getExternalStorageDirectory(), &quot;nongfaziran&quot;); if (!appDir.exists()) { appDir.mkdir(); } String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; File file = new File(appDir, fileName); try { FileOutputStream fos = new FileOutputStream(file); bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } // 其次把文件插入到系统图库 try { MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null); } catch (FileNotFoundException e) { e.printStackTrace(); } // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(file.getPath())))); ToastUtil.showShort(&quot;保存到&quot; + file.getPath()); }` 通过glide回调,获取图片Drawable mTvSave.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showLoadding(); GlideUtils.loadImage(Utils.getContext(), urls.get(mViewPager.getCurrentItem()), mIvImg,new GlideUtils.ImageLoadListener&lt;String, GlideDrawable&gt;() { @Override public void onLoadingComplete(String uri, ImageView view, GlideDrawable resource) { hideLoadding(); FileUtils.saveImageToGallery(Utils.getContext(), BitmapUtils.drawableToBitmap(resource)); showState(&quot;保存成功&quot;,1); } @Override public void onLoadingError(String source, Exception e) { hideLoadding(); showState(&quot;保存失败&quot;,0); ToastUtil.showShort(&quot;请检查SD卡并检查网络&quot;); } }); } }); 分享一个Glide封装 /** * Glide封装类 * Created by fengan on 2017/5/6. * Last Update on 2017.6.22 。 添加注解提醒、返回类型、优化代码 */ public abstract class GlideUtils { /** * 简单图片加载回调 * * @param &lt;T&gt; 图片url 或资源id 或 文件 * @param &lt;K&gt; 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ public interface ImageLoadListener&lt;T, K&gt; { /** * 图片加载成功回调 * * @param uri 图片url 或资源id 或 文件 * @param view 目标载体，不传则为空 * @param resource 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ void onLoadingComplete(T uri, ImageView view, K resource); /** * 图片加载异常返回 * * @param source 图片地址、File、资源id * @param e 异常信息 */ void onLoadingError(T source, Exception e); } /** * 详细加载图片加载回调 * * @param &lt;T&gt; 图片url 或资源id 或 文件 * @param &lt;K&gt; 返回的资源 */ public interface ImageLoadDetailListener&lt;T, K&gt; { /** * 图片加载成功回调 * * @param uri 图片url 或资源id 或 文件 * @param view 目标载体，不传则为空 * @param resource 返回的资源,GlideDrawable或者Bitmap或者GifDrawable,ImageView.setImageRecourse设置 */ void onLoadingComplete(T uri, ImageView view, K resource); /** * 图片加载异常返回 * * @param source 图片地址、File、资源id * @param errorDrawable 加载错误占位图 * @param e 异常信息 */ void onLoadingError(T source, Drawable errorDrawable, Exception e); /** * 加载开始 * * @param source 图片来源 * @param placeHolder 开始加载占位图 */ void onLoadingStart(T source, Drawable placeHolder); } /** * 根据上下文和 url获取 Glide的DrawableTypeRequest * * @param context 上下文 * @param url 图片连接 * @param &lt;T&gt; Context类型 * @param &lt;K&gt; url类型 * @return 返回DrawableTypeRequst&lt;K&gt; 类型 */ private static &lt;T, K&gt; DrawableTypeRequest&lt;K&gt; getDrawableTypeRequest(T context, K url) { DrawableTypeRequest&lt;K&gt; type = null; try { if (context instanceof android.support.v4.app.Fragment) { type = Glide.with((android.support.v4.app.Fragment) context).load(url); } else if (context instanceof android.app.Fragment) { type = Glide.with((android.app.Fragment) context).load(url); } else if (context instanceof Activity) { //包括FragmentActivity type = Glide.with((Activity) context).load(url); } else if (context instanceof Context) { type = Glide.with((Context) context).load(url); } } catch (Exception e) { e.printStackTrace(); } return type; } /** * 图片加载监听类 * * @param &lt;T&gt; 图片链接 的类型 * @param &lt;K&gt; 图片资源返回类型 * @param &lt;Z&gt; 返回的图片url */ private static class GlideListener&lt;T, K, Z&gt; implements RequestListener&lt;T, K&gt; { ImageLoadListener&lt;Z, K&gt; imageLoadListener = null; Z url; ImageView imageView = null; GlideListener(ImageLoadListener&lt;Z, K&gt; imageLoadListener, Z url, ImageView view) { this.imageLoadListener = imageLoadListener; this.url = url; this.imageView = view; } GlideListener(ImageLoadListener&lt;Z, K&gt; imageLoadListener, Z url) { this.imageLoadListener = imageLoadListener; this.url = url; } GlideListener(Z url) { this.url = url; } @Override public boolean onResourceReady(K resource, T model, Target&lt;K&gt; target, boolean isFromMemoryCache, boolean isFirstResource) { if (null != imageLoadListener) { if (imageView != null) { imageLoadListener.onLoadingComplete(url, imageView, resource); } else { imageLoadListener.onLoadingComplete(url, null, resource); } } return false; } @Override public boolean onException(Exception e, T model, Target&lt;K&gt; target, boolean isFirstResource) { //LogUtil.e(&quot;Glide图片加载失败:&quot;+e + &quot; 地址为:&quot;+url); if (imageLoadListener != null) { imageLoadListener.onLoadingError(url, e); } return false; } } /** * 获取存储器上的图片,回调返回GlideDrawable * * @param context 上下文年 * @param file 文件File * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;File&gt; loadImage(T context, @NonNull File file, @NonNull ImageLoadListener&lt;File, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;File&gt; type = getDrawableTypeRequest(context, file); if (type != null) { return type.listener(new GlideListener&lt;File, GlideDrawable, File&gt;(imageLoadListener, file)); } else { return null; } } /** * 获取资源中的图片，回调返回GlideDrawable * * @param context 上下文 * @param resourceId 资源id * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;Integer&gt; loadImage(T context, @DrawableRes int resourceId, @NonNull ImageLoadListener&lt;Integer, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;Integer&gt; type = getDrawableTypeRequest(context, resourceId); if (type != null) { return type.listener(new GlideListener&lt;Integer, GlideDrawable, Integer&gt;(imageLoadListener, resourceId)); } else { return null; } } /** * 获取网络图片，回调返回 GlideDrawable * * @param context 上下文 * @param url 图片url * @param imageLoadListener 回调监听器 */ public static &lt;T&gt; DrawableRequestBuilder&lt;String&gt; loadImage(T context, @NonNull final String url, @NonNull ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url)); } else { return null; } } /** * 加载存储器上的图片到目标载体 * * @param file 文件File * @param imageView 要显示到的图片ImageView */ public static Target&lt;GlideDrawable&gt; loadImage(@NonNull final File file, @NonNull ImageView imageView, ImageLoadListener&lt;File, GlideDrawable&gt; imageLoadListener) { return getDrawableTypeRequest(imageView.getContext(), file) .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用磁盘缓存 .skipMemoryCache(true)//跳过内存缓存 .dontAnimate() .listener(new GlideListener&lt;File, GlideDrawable, File&gt;(imageLoadListener, file, imageView)) .into(imageView); } /** * 加载资源中的图片到目标载体 * * @param resourceId 资源id * @param imageView 图片View */ public static Target&lt;GlideDrawable&gt; loadImage(@DrawableRes int resourceId, @NonNull ImageView imageView, ImageLoadListener&lt;Integer, GlideDrawable&gt; imageLoadListener) { return getDrawableTypeRequest(imageView.getContext(), resourceId) .listener(new GlideListener&lt;Integer, GlideDrawable, Integer&gt;(imageLoadListener, resourceId, imageView)) .into(imageView); } /** * 加载成圆形头像到普通ImageView，有动画效果 * * @param url 图片url * @param imageView 要显示到的ImageView * @param imageLoadListener 加载回调监听器 * @param parms 设置占位符和加载失败图片(可变参数默认两张,第一张为占位符,第二张是默认图片) * @return 返回Target&lt;GlideDrawable&gt; */ public static Target&lt;GlideDrawable&gt; loadCircleImage(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener, int... parms) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(), url); if (parms != null &amp;&amp; parms.length &gt; 0) { type.placeholder(parms[0]); //占位符 if (parms.length &gt; 1) { type.error(parms[1]); //图片加载失败显示图片 } } type.transform(new CircleTransform(imageView.getContext())); return type.listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } /** * 加载网络图片到指定Imageview，支持CircleImageView * * @param url 图片url * @param imageView 要显示的Imageview * @param imageLoadListener 图片加载回调 * @param parms 第一个是error的图片 */ public static &lt;T&gt; Target&lt;GlideDrawable&gt; loadImage(T context, @NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GlideDrawable&gt; imageLoadListener, int... parms) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { type.asBitmap(); if (parms != null &amp;&amp; parms.length &gt; 0) { type.placeholder(parms[0]); //占位符 if (parms.length &gt; 1) { type.error(parms[1]); //图片加载失败显示图片 } } //单张CircleImageView不允许动画，不然会不显示, if (imageView instanceof nfzr.zr.nf.nfzr.com.nongfaziran.nfzr.view.CircleImageView) { type.dontAnimate(); } return type .listener(new GlideListener&lt;String, GlideDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } else { return null; } } /** * 加载一帧视频，添加圆角 * * @param url 图片地址 * @param imageView 要加载到的ImageView */ public static Target&lt;GlideDrawable&gt; loadImageFormVideo(@NonNull String url, @NonNull ImageView imageView) { return getDrawableTypeRequest(imageView.getContext(), url) .override(SizeUtil.dp2px(150), SizeUtil.dp2px(150)) //.placeholder(android.R.drawable.picture_frame) //占位图 .dontAnimate() .into(imageView); } public static &lt;T&gt; Target&lt;GlideDrawable&gt; loadImageDetail(final T context, @NonNull final String url, @NonNull final ImageView imageView, final Drawable drawable, final ImageLoadDetailListener&lt;String, GlideDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.into(new SimpleTarget&lt;GlideDrawable&gt;() { @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) { if (imageView != null &amp;&amp; resource != null) { imageView.setImageDrawable(resource); } if (imageLoadListener != null) { imageLoadListener.onLoadingComplete(url, imageView, resource); } } @Override public void onStart() { super.onStart(); if (drawable != null &amp;&amp; imageView != null) { imageView.setImageDrawable(drawable); } } @Override public void onLoadStarted(Drawable placeholder) { super.onLoadStarted(placeholder); if (imageLoadListener != null) { imageLoadListener.onLoadingStart(url, placeholder); } } @Override public void onLoadFailed(Exception e, Drawable errorDrawable) { super.onLoadFailed(e, errorDrawable); if (imageLoadListener != null) { imageLoadListener.onLoadingError(url, errorDrawable, e); } } }); } else { return null; } } /** * 加载bitmap，回调返回 Bitmap * * @param context 上下文 * @param url 图片url * @param imageLoadListener 图片加载监听器 * @param &lt;T&gt; 上下文类型 */ public static &lt;T&gt; BitmapRequestBuilder&lt;String, Bitmap&gt; loadImageBitmap(T context, @NonNull String url,@NonNull ImageLoadListener&lt;String, Bitmap&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.asBitmap() .listener(new GlideListener&lt;String, Bitmap, String&gt;(imageLoadListener, url)); }else{ return null; } } /** * 加载GifDrawable，回调返回 GifDrawable * * @param context 上下文 * @param url 图片url * @param imageLoadListener 图片加载监听器 */ public static &lt;T&gt; GifRequestBuilder&lt;String&gt; loadImageGif(T context, @NonNull String url,@NonNull ImageLoadListener&lt;String, GifDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(context, url); if (type != null) { return type.asGif() .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, GifDrawable, String&gt;(imageLoadListener, url)); }else{ return null; } } /** * 加载Gif的一张图片到ImageView * * @param url 图片url * @param imageLoadListener 图片加载监听器 * @param imageView * @param drawable 缩略图，可以为空 */ public static Target&lt;Bitmap&gt; loadImageGifSingle(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, Bitmap&gt; imageLoadListener, Drawable drawable) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(),url); return type.asBitmap() .placeholder(drawable) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, Bitmap, String&gt;(imageLoadListener, url)) .into(imageView); } /** * 加载gif图片到指定ImageView * * @param url 图片Url * @param imageView 图片View * @param imageLoadListener 图片加载监听器 */ public static Target&lt;GifDrawable&gt; loadImageGif(@NonNull String url, @NonNull ImageView imageView, ImageLoadListener&lt;String, GifDrawable&gt; imageLoadListener) { DrawableTypeRequest&lt;String&gt; type = getDrawableTypeRequest(imageView.getContext(),url); return type.asGif() .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new GlideListener&lt;String, GifDrawable, String&gt;(imageLoadListener, url, imageView)) .into(imageView); } /** * 释放内存 * * @param context 上下文 */ public static void clearMemory(Context context) { Glide.get(context).clearMemory(); } /** * 取消所有正在下载或等待下载的任务。 * * @param context 上下文 */ public static void cancelAllTasks(Context context) { Glide.with(context).pauseRequests(); } /** * 恢复所有任务 */ public static void resumeAllTasks(Context context) { Glide.with(context).resumeRequests(); } /** * 清除磁盘缓存 * * @param context 上下文 */ public static void clearDiskCache(final Context context) { new Thread(new Runnable() { @Override public void run() { Glide.get(context).clearDiskCache(); } }).start(); } /** * 清除所有缓存 * * @param context 上下文 */ public static void cleanAll(Context context) { clearDiskCache(context); clearMemory(context); } }` /** * Created by fengan on 2017/5/25. */ public class CircleTransform extends BitmapTransformation { public CircleTransform(Context context) { super(context); } @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) { return circleCrop(pool, toTransform); } private static Bitmap circleCrop(BitmapPool pool, Bitmap source) { if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) { result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); } Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; } @Override public String getId() { return getClass().getName(); } } Drawable转bigmap public class BitmapUtils { public static Bitmap drawableToBitmap(Drawable drawable) { Bitmap bitmap = Bitmap.createBitmap( drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); //canvas.setBitmap(bitmap); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()); drawable.draw(canvas); return bitmap; } }]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0之应用间共享文件]]></title>
    <url>%2F2016%2F07%2F23%2FAndroid7-0%E4%B9%8B%E5%BA%94%E7%94%A8%E9%97%B4%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android7.0适配之应用间共享文件出现问题Android N(API 25),打开相册编辑页面crash,报出FileUriExposedException异常 123456789 android.os.FileUriExposedException: file:////storage/emulated/0/temp/1474956193735.jpg exposed beyond app through Intent.getData()at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)at android.net.Uri.checkFileUriExposed(Uri.java:2346)at android.content.Intent.prepareToLeaveProcess(Intent.java:8933)at android.content.Intent.prepareToLeaveProcess(Intent.java:8894)at android.app.Instrumentation.execStartActivity(Instrumentation.java:1517)at android.app.Activity.startActivityForResult(Activity.java:4223)...at android.app.Activity.startActivityForResult(Activity.java:4182) 查找原因Android N的应用,API禁止向应用外公开file://URI,如果一项包含文件URI的Intent离开应用, 应用crash并报FileUriExposedException异常 解决办法若想要在应用间共享文件,应该发送一项content://URI,并该URI临时访问权限,进行此授权的方式是通过FileProvider类 具体步骤[1] 清单文件123456789101112131415161718192021222324252627282930 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.fengan.providerdemo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--authorities="你的包名+fileprovider" --&gt; &lt;provider android:authorities="com.fengan.providerdemo.fileprovider" android:name="android.support.v4.content.FileProvider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths"/&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; [2] res下xml文件夹注意xml文件名和清单文件中@xml/filepaths相同xml文件内容 123456 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;!-- external-path:sd ；path:你的应用保存文件的根目录；name随便定义--&gt; //&lt;external-path path="fengan_imgs/" name="files_path" /&gt; &lt;external-path path="" name="files_path" /&gt;&lt;/paths&gt; 注意:path=””,有特殊意义,它代表更目录,也就是说可以向应用共享根目录及其子目录下任何一个文件,如果将path写为path=”fengan_imgs/“,那么只能在fengan_imgs/目录下才可以分享![3]核心代码将File转换为uri 12345678910111213private static Uri getUriForFile(Context context, File file) &#123; if (context == null || file == null) &#123; throw new NullPointerException(); &#125; Uri uri; if (Build.VERSION.SDK_INT &gt;= 24) &#123; //和android:authorities="com.fengan.providerdemo.fileprovider"对应 uri = FileProvider.getUriForFile(context.getApplicationContext(), "com.fengan.providerdemo.fileprovider", file); &#125; else &#123; uri = Uri.fromFile(file); &#125; return uri; &#125; Uri的scheme类型为file,改成了又FileProvider创建一个content类型的Uri打开相机,打印该Uri为content://com.fengan.providerdemo/files_path/temp/1474960080319.jpg`。//其中camera_photos就是file_paths.xml中paths的name。 1234567891011121314151617/** * 打开相机 * 兼容7.0 * * @param activity Activity * @param file File * @param requestCode result requestCode */ public static void startActionCapture(Activity activity, File file, int requestCode) &#123; if (activity == null) &#123; return; &#125; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); //添加这一句表示对目标应用临时授权该Uri所代表的文件 intent.putExtra(MediaStore.EXTRA_OUTPUT, getUriForFile(activity, file));//拍取照片保存到指定Uri activity.startActivityForResult(intent, requestCode); &#125; 总结 针对涉及到从Android设备上获取照片(拍照,或从相册,文件中选择)打开相机,裁剪图片,压缩图片,可以使用一个轻量级开源库,TakePhoto!https://github.com/crazycodeboy/TakePhoto/]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview中点击网页图片跳转查看图片]]></title>
    <url>%2F2016%2F03%2F08%2Fwebview%E4%B8%AD%E7%82%B9%E5%87%BB%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E8%B7%B3%E8%BD%AC%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言 app中很多图文页面，类似新闻详情页，都是一个H5网页，当我们点击网页中的图片，希望跳转到一个多图游览的页面，并且支持手势缩放和保存的一些功能。今天主要整理一下点击网页中图片，跳转到指定图片的查看页面即可，手势缩放可以使用photoview。 原理效果 原理 首先点击h5页面，跳转本地页面，是js调用原生代码 Js通过WebView调用Android代码有三种方式 通过WebView的addJavascriptInterface（）进行对象映射 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息 通过addJavascriptInterface定义js接口的方式比较方便，所以本文采用的是这种方式，详细见下列代码 定义js接口 找到网页中img标签的代码块，设置点击 相关权限和混淆 代码定义js接口1234567891011121314151617181920212223242526272829** * Created by fengan on 2016/3/8. * email:fengan1102@gmail.com * 点击webview页面图片，跳转查看大图页面的js接口 * 检查混淆文件，确保未被混淆 */public class JavaScriptInterface &#123; private Activity mContext; private ArrayList&lt;String&gt; mImgList = new ArrayList&lt;&gt;(); public JavaScriptInterface(Activity context) &#123; this.mContext = context; &#125;//方法名要和执行的js代码中一致 @JavascriptInterface public void addImageUrl(String img) &#123; mImgList.add(img); &#125; @JavascriptInterface public void openImage(String img) &#123; if (ClickUtils.noDoubleClick()) &#123; int index = mImgList.indexOf(img); PhotoListAty.startAty(index == -1 ? 0 : index, mImgList, mContext); &#125; &#125;&#125; 自定义WebClient1234567891011121314151617181920212223242526272829303132333435363738394041public class MyWebViewClient extends WebViewClient &#123; @Override public void onPageFinished(WebView view, String url) &#123; view.getSettings().setJavaScriptEnabled(true); super.onPageFinished(view, url); addImageClickListener(view);//待网页加载完全后设置图片点击的监听方法 &#125; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; view.getSettings().setJavaScriptEnabled(true); super.onPageStarted(view, url, favicon); &#125; private void addImageClickListener(WebView webView) &#123; webView.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\"); " + "for(var i=0;i&lt;objs.length;i++) " + "&#123;" + "window.imagelistener.addImageUrl(objs[i].src); " + " objs[i].onclick=function() " + " &#123; " + " window.imagelistener.openImage(this.src); " + " &#125; " + "&#125;" + "&#125;)()"); &#125; 1234//imagelistener用于暴露js的对象，需要对应 mWebview.getSettings().setJavaScriptEnabled(true); mWebview.addJavascriptInterface(new JavaScriptInterface(this), "imagelistener"); mWebview.setWebViewClient(new MyWebViewClient()); 注意事项注意在混淆文件中添加 项目中暴露的js接口类：MJavascriptInterface不能混淆，其调用的方法的声明也不能混淆，所以还要添加如下混淆设置代码（代码因包名而变化） 123456-keepclassmembers class com.example.administrator.webviewpagescannerapp.other.MJavascriptInterface&#123; public *; &#125; -keepattributes *Annotation* -keepattributes *JavascriptInterface*]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生65535的原因和解决办法]]></title>
    <url>%2F2016%2F03%2F06%2F%E4%BA%A7%E7%94%9F65535%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[熟悉Android开发的都知道，在生成Dex过程中，方法数超过65535就会报错，本文只简述一下如何解决，更重要的是为什么会这样。简单来说，在Dalvik指令集中，调用方法的invoke-kind指令中，method reference index只给了16bits，最多能调用65535个方法，所以在生成dex文件的过程中，当方法数超过65535就会报错。其实除了method，filed和class的index也是16bits，所以也会存在65535的问题，只不过method的数量一般是最多的，所以最常见的也是方法数溢出的问题。 如何解决（不再详细叙述）导入multidex包，配置gradle文件multiDexEnabled true implementation &#39;com.android.support:multidex:1.0.2&#39; Application中初始化 继承MultiDexApplication 重写Application 的attachBaseContext方法，这个方法是在onCreate之前执行的 12345678public class MyApplication extends Application&#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125; &#125; 这样会生成classes.dex classes2.dex classes3.dex …多个dex文件 为啥会有65536的限制一个 dex 文件的方法引用数不能大于 64k，64k 的准确值是（64 * 1024 = 65536）。 invoke-kind （调用各类方法）指令中，方法引用索引数是 16 位的，也就是最多调用 2^16 = 65536 个方法，这就是 DexFormat 中 MAX_MEMBER_IDX 为 0xFFFF 的原因。 详细原因查看]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾集合体系]]></title>
    <url>%2F2015%2F12%2F26%2F%E5%9B%9E%E9%A1%BE%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[前言 面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象进行操作，就需要对对象进行存储 数组虽然可以存储对象，但是长度上固定的 集合的长度是可变的 数组中可以存储基本数据类型 集合中只能存储对象 集合体系图 Iterator接口 Iterator接口，这是一个用于遍历集合中元素的接口 主要包含hashNext(),next(),remove()三种方法 它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious() Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常无序集合实现的都是这个接口，比如HashSet，HashMap 元素有序的集合，实现的一般都是LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个元素，比如ArrayList。 Collection接口 Collection是集合类根接口，衍生出两个子类接口List和Set Collection定义了集合框架的共性功能 List接口List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 ArrayList：线程不安全，查询速度快，元素有序，可重复 Vector：线程安全，但速度慢，已被ArrayList替代 LinkedList：链表结构，增删速度快 LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反 Set接口Set里存放的对象是无序（存入和取出的顺序不一定一致），不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 HashSet：： 底层数据结构是哈希表。是线程不安全的。不同步 通过元素的两个方法，hashCode和equals来保证唯一性 如果元素的HashCode值相同，才会判断equals是否为true。 如果元素的hashcode值不同，不会调用equals。 无序 TreeSet： 有序 线程不安全，可以对Set集合中的元素进行排序 通过compareTo或者compare方法来保证元素的唯一性，元素以二叉树的形式存放。 Map接口 Map提供了一种映射关系，元素是以键值对（key-value）的形式存储的，能根据key快速查找value； Map中的键值对以Entry类型的对象实例形式存在； key值不能重复，value值可以重复； HashMap底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同步的。将hashtable替代，jdk1.2.效率高。 HashMap原理： HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 数组中的每一项又是一个Entry，其中包含了key和value，也就是键值对，另外还包含了一个next的Entry指针 因为持有下一个Entry指针，所以构成链表 往HashMap中put元素的时候，先根据key的hashCode重新计算hash值 根据hash值得到这个元素在数组中的位置（即下标） 如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。 如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上 从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 一句话原理总结：简单来说，HashMap在底层将key-value当作一个整体处理，这个整体就是一个Entry对象。HashMap底层采用一个Entry[]数组来保存所有的key-value，每个Entry包含了key-value，还包含了next的Entry指针，因此构成一个链表。当要存储一个Entry对象时，会根据hash算法决定在数组中的存储位置，再根据equals方法，决定其在该数组位置上的链表的存储位置；在需要取出一个Entry时，也会根据hash算法找到其在这个数组的存储位置，再根据equel方法，从该位置找到对应的Entry对象。 hashmap两种遍历方式第一种： 1234567Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); &#125; 第二种： 123456 Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; Object key = iter.next(); Object val = map.get(key); &#125; 浅析ConcurrentHashMap public V get(Object key)不涉及到锁，也就是说获得对象时没有使用锁； put、remove方法要使用锁，但并不一定有锁争用，原因在于ConcurrentHashMap将缓存的变量分到多个Segment，每个Segment上有一个锁，只要多个线程访问的不是一个Segment就没有锁争用，就没有堵塞，各线程用各自的锁，ConcurrentHashMap缺省情况下生成16个Segment，也就是允许16个线程并发的更新而尽量没有锁争用； Hashtable对get,put,remove都使用了同步操作，也就是说如果有线程正在遍历集合，其他的线程就暂时不能使用该集合了，这样无疑就很容易对性能和吞吐量造成影响。而ConcurrentHashMap则不同，它只对put,remove操作使用了同步操作，get操作并不影响 Hashtable在使用iterator遍历的时候，如果其他线程，包括本线程对Hashtable进行了put，remove等更新操作的话，就会抛出ConcurrentModificationException异常，但如果使用ConcurrentHashMap的话，就不用考虑这方面的问题了 浅析HashMap，HashTable，ConcurrentHashMap HashMap如上所诉，不同步，线程不安全，不使用用与多线程高并发情况下 Hashtable，被遗弃的类，线程安全是因为在所有方法上都加了synchronized来实现线程安全，导致多线程访问效率低 Synchronized Map（通过Collections.synchronizedMap()来包装一个hashmap）和hashtable区别不大，唯一区别就是没有被遗弃 ConcurrentHashMap，默认允许16个线程读写这个map，不像Hashtable和Synchronized Map一样，没有锁整个整个map，而是划分了多个段（Segment），只会锁需要操作的那一段数据 点击查看详细博客 点击查看相关博客 TreeMap底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。 集合输出（遍历） Iterator： 迭代输出，使用最多的输出方式 ListIterator：是Iterator的子接口，专门用于输出List中的内容。 foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。 for循环 集合的工具类Collections:集合框架的工具类。里面定义的都是静态方法。 Collections和Collection有什么区别？ Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。 它有两个常用的子接口， ——List：对元素都有定义索引。有序的。可以重复元素。 ——Set：不可以重复元素。无序。 Collections是集合框架中的一个工具类。该类中的方法都是静态的。 提供的方法中有可以对list集合进行排序，二分查找等方法。 通常常用的集合都是线程不安全的。因为要提高效率。 如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。 总结List：add/remove/get/set。 1，ArrayList：其实就是数组，容量一大，频繁增删就是噩梦，适合随机查找； 2，LinkedList：增加了push/[pop|remove|pull]，其实都是removeFirst； 3，Vector：历史遗留产物，同步版的ArrayList，代码和ArrayList太像； 4，Stack：继承自Vector。Java里其实没有纯粹的Stack，可以自己实现，用组合的方式，封装一下LinkedList即可； 5，Queue：本来是单独的一类，不过在SUN的JDK里就是用LinkedList来提供这个功能的，主要方法是offer/pull/peek，因此归到这里呢。 Set：add/remove。可以用迭代器或者转换成list。 1，HashSet：内部采用HashMap实现的； 2，LinkedHashSet：采用LinkedHashMap实现； 3，TreeSet：TreeMap。 Map：put/get/remove。 1，HashMap/HashTable：散列表，和ArrayList一样采用数组实现，超过初始容量会对性能有损耗； 2，LinkedHashMap：继承自HashMap，但通过重写嵌套类HashMap.Entry实现了链表结构，同样有容量的问题； 3，Properties：是继承的HashTable。 顺便说一下Arrays.asList，这个方法的实现依赖一个嵌套类，这个嵌套类也叫ArrayList！ 手写集合ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 手写ArrayList */ public class MyArrayList&#123; private Object[] value = null; private int size = 0; MyArrayList() &#123; value = new Object[10]; &#125; public boolean add(Object obj)&#123; if(size == value.length) expansion(); value[size++]=obj; return true; &#125; public Object get(int index)&#123; return value[index]; &#125; public void remove(Object obj)&#123; Object[] obj2 = new Object[size]; int index = 0; int id = 0; for (int i = 0; i &lt;= size; i++) &#123; if(!(value[i].toString().equals(obj.toString())))&#123; obj2[index] = value[i]; index ++; &#125;else&#123; id ++ ; if(id == 1) size --; else&#123; obj2[index] = value[i]; index ++; &#125; &#125; &#125; value = obj2; &#125; @SuppressWarnings("null") public void set(int index,Object obj)&#123; Object[] newObj = new Object[size];; for (int i = 0; i &lt; size; i++) &#123; if(i == index) newObj[i] = obj; else newObj[i] = value[i]; &#125; value = newObj; &#125; public int size()&#123; return size; &#125; private boolean expansion() &#123; Object[] temp = new Object[value.length + 5]; temp = value.clone(); /** * 注意：clone只对一维数组起作用，而不能用于二维数组， 因为java没有二维数组的概念，而只有数组的数组，二维 * 数组存储的是几个一维数组的引用，而使用clone也只是 拷贝了这几个引用，说白了还是原来那几个一维数组对象。 * 如果想用于二维数组，那么就遍历其中的一维数组，挨个 拷贝一维数组到目标二维数组中的一维数组下。 */ value = temp; return true; &#125; public void clear()&#123; size = 0; value = null; &#125; public static void main(String[] args) &#123; MyArrayList ma = new MyArrayList(); ma.add("hello"); ma.add("world"); ma.add("java"); System.out.println(ma.get(1)); System.out.println(ma.size()); ma.set(1, "new"); System.out.println(ma.get(1)); System.out.println(ma.size()); &#125; &#125; LinkedList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class MyLinkedList&lt;AnyType&gt; &#123; private static class Node&lt;AnyType&gt;&#123; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; public Node(AnyType d, Node&lt;AnyType&gt; p, Node&lt;AnyType&gt; n)&#123; data = d; prev = p; next = n; &#125; &#125; private int theSize; private int modCount; private Node&lt;AnyType&gt; beginMarker; private Node&lt;AnyType&gt; endMarker; public MyLinkedList()&#123; clear(); &#125; public void clear()&#123; beginMarker = new Node&lt;AnyType&gt;(null, null, null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; &#125; public int size()&#123; return theSize; &#125; public boolean add(AnyType x)&#123; add(size(), x); return true; &#125; public void add(int idx, AnyType x)&#123; addBefore(getNode(idx), x); &#125; public AnyType get(int idx)&#123; return getNode(idx).data; &#125; private void addBefore(Node&lt;AnyType&gt; p, AnyType x)&#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x, p.prev, p); newNode.prev.next = newNode; p.prev = newNode; theSize++; modCount++; &#125; private Node&lt;AnyType&gt; getNode(int idx)&#123; Node&lt;AnyType&gt; p; if(idx &lt; 0 || idx &gt; size())&#123; System.out.println("IndexOutOfBoundsException"); &#125; if(idx &lt;= size()/2)&#123; System.out.println(idx); p = beginMarker.next; for(int i = 0; i &lt; idx; i++)&#123; p = p.next; &#125; &#125;else&#123; p = endMarker; for(int i = size(); i &gt; idx; i--)&#123; p = p.prev; &#125; &#125; return p; &#125; public boolean find(AnyType x)&#123; Node&lt;AnyType&gt; p = beginMarker.next; for(int i = 0; i &lt; size(); i++)&#123; if(p.data == x)&#123; return true; &#125; p = p.next; &#125; return false; &#125; public String toString()&#123; String s = ""; Node&lt;AnyType&gt; p = beginMarker.next; for(int i = 0; i &lt; size(); i++)&#123; s += p.data +","; p = p.next; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread]]></title>
    <url>%2F2015%2F12%2F22%2FHandlerThread%2F</url>
    <content type="text"><![CDATA[HandlerThread 官方介绍 Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是HandlerThread能够新建拥有Looper的线程(除了主线程,我们新建线程是需要手动调用Looper.prepare来初始化looper和messagequeue的),而这个looper能够来新建其他的Handler(新建的这个handler是属于子线程的,并且looper和messagequeue都是初始化好了的) 如以下代码： 1234567891011121314151617181920212223mHandlerThread = new HandlerThread("check-message-coming");//the name of the new thread mHandlerThread.start(); mThreadHandler = new Handler(mHandlerThread.getLooper())//拥有子线程looper的handler &#123; @Override public void handleMessage(Message msg) &#123; update();//模拟数据更新 if (isUpdateInfo) mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; &#125;; @Override protected void onDestroy() &#123; super.onDestroy(); //释放资源 myHandlerThread.quit() ; &#125;//其他线程可以拿mThreadHandler发消息了，来完成向该HandlerThread线程通讯 mThreadHandler构建的时候,传的是HandlerThread的looper对象,也就是说这个mThreadHandler是属于子线程的管理的,他的handlerMessage的回调中是可以做耗时操作的(切记,是不能做更新UI的操作的,如需要更新,需要用主线程的handler发消息来更新,或者使用runOnUiThread或者eventBus等其他方式来刷新ui) 退出循环 Looper是通过调用loop方法驱动着消息循环的进行: 从MessageQueue中阻塞式地取出一个消息，然后让Handler处理该消息，周而复始，loop方法是个死循环方法。 那如何终止消息循环呢？我们可以调用Looper的quit方法或quitSafely方法，二者稍有不同。 1234567891011121314151617181920212223242526272829303132333435/** * Quits the looper. * &lt;p&gt; * Causes the &#123;@link #loop&#125; method to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class="note"&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @see #quitSafely */ public void quit() &#123; mQueue.quit(false); &#125; /** * Quits the looper safely. * &lt;p&gt; * Causes the &#123;@link #loop&#125; method to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * However pending delayed messages with due times in the future will not be * delivered before the loop terminates. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt; */ public void quitSafely() &#123; mQueue.quit(true); &#125; quit（）和quitSafety的区别 当我们调用Looper的quit方法时，实际上执行了MessageQueue中的removeAllMessagesLocked方法，该方法的作用是把MessageQueue消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。 当我们调用Looper的quitSafely方法时，实际上执行了MessageQueue中的removeAllFutureMessagesLocked方法，通过名字就可以看出，该方法只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。 无论是调用了quit方法还是quitSafely方法只会，Looper就不再接收新的消息。即在调用了Looper的quit或quitSafely方法之后，消息循环就终结了，这时候再通过Handler调用sendMessage或post等方法发送消息时均返回false，表示消息没有成功放入消息队列MessageQueue中，因为消息队列已经退出了。 需要注意的是Looper的quit方法从API Level 1就存在了，但是Looper的quitSafely方法从API Level 18才添加进来。 总结 1. Handler继承自Thread,因此调用start方法,也是执行run方法,run()方法的逻辑都是在子线程中运行的。 2. 查看HandlerThread源码可以看到,run()中主要做了Looper.prepare()和looper.loop()创建looper和messagequeue对象并开启消息队列的循环 3. 需要注意的是,对于网络io操作,HandlerThread并不适合,因为它只有一个线程,得排队一个一个等着。 4. 页面消耗的时候,调用 myHandlerThread.quit() ;looper就不在接受新的消息,消息循环结束,这个时候再通过handler调用sendMessage或者post等方法发送消息时均返回false,表示没有成功的放入消息队列。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[edittext输入限制]]></title>
    <url>%2F2015%2F12%2F13%2Fedittext%E8%BE%93%E5%85%A5%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[EditText智能限制小数点前后分别保留几位 可以分别限制小数点前面几位，和小数点后几位 首位输入0时，第二位只能输入小数点 首位输入小数点，默认显示0. 嘻嘻! ‘’’ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * * @param frontPoint 小数点前几位数 * @param behindPoint 小数点后几位数 * @param editTexts */public static void setEditTextLimit(final int frontPoint, final int behindPoint, final EditText... editTexts) &#123; if (editTexts != null &amp;&amp; editTexts.length &gt; 0) &#123; for (final EditText editText : editTexts) &#123; editText.addTextChangedListener(new TextWatcher() &#123; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() == frontPoint + 1 &amp;&amp; !s.toString().contains(".")) &#123; editText.setText(s.toString().substring(0, frontPoint)); editText.setSelection(frontPoint); &#125; if (editText.getText().toString().indexOf(".") &gt;= 0) &#123; if (editText.getText().toString().indexOf(".", editText.getText().toString().indexOf(".") + 1) &gt; 0) &#123; editText.setText(editText.getText().toString().substring(0, editText.getText().toString().length() - 1)); editText.setSelection(editText.getText().toString().length()); &#125; &#125; if (s.toString().contains(".")) &#123; if (s.length() - 1 - s.toString().indexOf(".") &gt; behindPoint) &#123; s = s.toString().subSequence(0, s.toString().indexOf(".") + behindPoint+1); editText.setText(s); editText.setSelection(s.length()); &#125; &#125; //直接输入一个点,显示0. if (s.toString().trim().substring(0).equals(".")) &#123; s = "0" + s; editText.setText(s); editText.setSelection(2); &#125; //当输入一个0,后面只能输入小数点 if (s.toString().startsWith("0") &amp;&amp; s.toString().trim().length() &gt; 1) &#123; if (!s.toString().substring(1, 2).equals(".")) &#123; editText.setText(s.subSequence(0, 1)); editText.setSelection(1); return; &#125; &#125; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;&#125; ‘’’ xml别忘了 1android:inputType="numberDecimal"]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传,角度不正确]]></title>
    <url>%2F2015%2F08%2F08%2F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E8%A7%92%E5%BA%A6%E4%B8%8D%E6%AD%A3%E7%A1%AE%2F</url>
    <content type="text"><![CDATA[图片上传,部分机型角度不正确问题解决前言现在app大多都有上传图片功能,比如上传图片,发表动态可能还会上传多张图片,那在我做图片上传的时候,出现了部分机型上传图片后,图片的角度是正确的,我的两个测试机小米和华为是没问题的,但是三星的上传后,图片是默认旋转了90°,那这里要讲的就是怎么解决这个问题,在此记录一下,以保证后面再出现类似需求要多考虑一些 解决问题 直接进入正题 当我们上传图片需要做的处理 压缩 判断角度是否正确 如果不角度不对,纠正角度 其他(加水印什么的看具体需求) 解决以下代码块 ` /** * 压缩图片，处理某些手机拍照角度旋转的问题 * @param context * @param filePath * @param file * @param q * @return * @throws FileNotFoundException */ public static File compressImage(Context context, String filePath, File file, int q) throws FileNotFoundException { Bitmap bm = getSmallBitmap(filePath); int degree = readPictureDegree(filePath); LogUtil.e(&quot;fengan&quot;, &quot;degree==&quot; + degree); if (degree != 0) {//旋转照片角度 bm = rotateBitmap(bm, degree); } FileOutputStream out = new FileOutputStream(file); bm.compress(Bitmap.CompressFormat.JPEG, q, out); return file; }` /** * 获取图片角度 * @param path * @return */ public static int readPictureDegree(String path) { int degree = 0; try { ExifInterface exifInterface = new ExifInterface(path); int orientation = exifInterface.getAttributeInt( ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) { case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; } } catch (IOException e) { e.printStackTrace(); } return degree; } /** * 旋转照片 * @param bitmap * @param degress * @return */ public static Bitmap rotateBitmap(Bitmap bitmap, int degress) { if (bitmap != null) { Matrix m = new Matrix(); m.postRotate(degress); bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m, true); return bitmap; } return bitmap; } /** * 根据路径获得突破并压缩返回bitmap用于显示 * * @return */ public static Bitmap getSmallBitmap(String filePath) { final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, 480, 800); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options); }]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝你今天心情愉快]]></title>
    <url>%2F2015%2F08%2F08%2F%E7%A5%9D%E4%BD%A0%E4%BB%8A%E5%A4%A9%E5%BF%83%E6%83%85%E6%84%89%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
